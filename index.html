<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#87CEEB">
  <meta name="google-adsense-account" content="ca-pub-3940397734826984">
  <title>Llama Time!</title>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/llama-icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Llama Time">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-68N7VH7BF2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-68N7VH7BF2');
  </script>
  <style>
    /* Basic Reset & Body Styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
        width: 100%;
        height: 100%;
        overflow: hidden; /* Prevent scrollbars */
        font-family: 'Press Start 2P', cursive;
        background-color: #f0f0f0;
        color: #333;
        transition: background-color 0.5s ease;
        -webkit-user-select: none; -ms-user-select: none; user-select: none;
    }

    /* Game Container & Canvas */
    #game-container {
      position: relative;
      width: 100%;
      height: 100%;
      max-width: none;
      border: none;
      border-radius: 0;
      overflow: hidden;
      cursor: pointer;
      background-color: #87CEEB;
      transition: background-color 0.5s ease;
      margin: 0;
    }
    canvas {
      display: block;
      width: 100%;
      height: 100%;
      background-color: transparent;
      image-rendering: pixelated;
      image-rendering: -moz-crisp-edges;
      image-rendering: crisp-edges;
    }

    /* Popups & Indicators (Unchanged) */
    #mission-complete-popup, #reward-popup, #level-up-popup, #achievement-popup {
      position: absolute; top: 15px; right: 15px;
      background-color: rgba(76, 175, 80, 0.9); color: white;
      padding: 8px 15px; border-radius: 10px; font-size: clamp(0.6em, 2vw, 0.8em);
      z-index: 30; display: none; opacity: 0; transition: opacity 0.5s ease-out;
      font-family: 'Press Start 2P', cursive; text-align: center; max-width: 80%;
      pointer-events: none;
    }
    #reward-popup { background-color: rgba(255, 215, 0, 0.9); color: #333; }
    #level-up-popup { background-color: rgba(0, 191, 255, 0.9); color: white; }
    #achievement-popup { background-color: rgba(128, 0, 128, 0.9); color: white; }

    /* Store Interface (Unchanged) */
    #store-interface {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9); display: none; flex-direction: column;
      align-items: center; justify-content: flex-start; z-index: 20; color: white;
      padding: 15px 10px; text-align: center; overflow-y: auto;
    }
    #store-interface h2 { margin-top: 10px; margin-bottom: 10px; font-size: clamp(1.2em, 4vw, 1.5em); flex-shrink: 0; }
    #store-interface > p { margin-bottom: 10px; font-size: clamp(0.8em, 3vw, 1em); flex-shrink: 0; }
    .store-section { width: 100%; margin-bottom: 15px; border-bottom: 1px solid #666; padding-bottom: 10px; }
    .store-section h3 { font-size: clamp(1em, 3.5vw, 1.2em); margin-bottom: 10px; color: gold; }
    .store-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 10px; width: 90%; max-width: 350px; border: 2px solid #fff; flex-shrink: 0; }
    .store-item h4 { font-size: clamp(0.9em, 3vw, 1.0em); margin-bottom: 5px; }
    .store-item p { margin-bottom: 8px; font-size: clamp(0.7em, 2.5vw, 0.8em); }
    .store-item .upgrade-level { font-size: clamp(0.6em, 2vw, 0.7em); color: #ccc; margin-bottom: 5px; }
    .store-item button { font-family: 'Press Start 2P', cursive; font-size: clamp(0.7em, 2.5vw, 0.8em); padding: 8px 15px; margin-top: 5px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer;}
    .store-item button:disabled { opacity: 0.5; cursor: not-allowed; }
    #close-store { margin-top: 20px; margin-bottom: 30px; padding: 10px 20px; font-size: clamp(0.9em, 3vw, 1em); flex-shrink: 0; font-family: 'Press Start 2P', cursive; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; }

    /* Powerup Indicators (Unchanged) */
    #powerup-indicators { position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; gap: 8px; pointer-events: none; }
    .indicator { font-size: clamp(1.2em, 4vw, 1.8em); opacity: 0.35; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: opacity 0.3s ease, filter 0.3s ease; filter: grayscale(50%); }
    .indicator.owned { opacity: 0.7; filter: grayscale(0%); }
    .indicator.active { opacity: 1; filter: grayscale(0%); animation: pulse 0.8s infinite; }
    #magnet-indicator.active { animation: pulse-magnet 0.6s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes pulse-magnet { 0% { transform: scale(1); text-shadow: 0 0 5px gold; } 50% { transform: scale(1.2); text-shadow: 0 0 15px gold; } 100% { transform: scale(1); text-shadow: 0 0 5px gold; } }

    /* Modal Styles (Shared Base) (Unchanged) */
    .modal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8); display: none; flex-direction: column;
      align-items: center; justify-content: center; z-index: 100; color: white;
      padding: 20px; text-align: center;
    }
    .modal-content {
      background-color: #333; padding: 20px 30px; border-radius: 15px;
      border: 3px solid #ccc; max-width: 90%; width: 450px;
      max-height: 85vh; overflow-y: auto;
    }
    .modal-content h2 { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; color: gold; }
    .modal-content p { font-size: clamp(0.8em, 3vw, 1em); margin-bottom: 20px; line-height: 1.5; }
    .modal-close-button, .modal-button { font-family: 'Press Start 2P', cursive; font-size: clamp(0.8em, 3vw, 1em); padding: 10px 20px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; margin-top: 15px; display: inline-block; margin-left: 5px; margin-right: 5px; }
    .modal-button:disabled { opacity: 0.5; cursor: not-allowed; }

    /* Daily Login Modal Specifics (Unchanged) */
    #daily-login-modal .modal-content { border-color: gold; }
    #daily-bonus-breakdown { list-style: none; padding: 0; margin: 15px 0; text-align: left; max-width: 250px; margin-left: auto; margin-right: auto; }
    #daily-bonus-breakdown li { font-size: clamp(0.7em, 2.5vw, 0.8em); margin-bottom: 5px; padding-left: 10px; border-left: 2px solid gold; }
    #daily-bonus-breakdown li.current-day { font-weight: bold; color: #FFD700; border-left-color: white; }

    /* Achievement Modal Specifics (Unchanged) */
    #achievement-modal .modal-content { border-color: purple; }
    #achievement-list { list-style: none; padding: 0; margin: 0; }
    .achievement-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #666; text-align: left; }
    .achievement-item.unlocked { border-color: gold; background-color: #5a5a4a; }
    .achievement-item h4 { font-size: clamp(0.8em, 2.8vw, 0.9em); margin-bottom: 5px; color: white; }
    .achievement-item p { font-size: clamp(0.7em, 2.3vw, 0.75em); margin-bottom: 5px; color: #ccc; }
    .achievement-item .status { font-size: clamp(0.6em, 2vw, 0.7em); font-weight: bold; float: right; }
    .achievement-item.unlocked .status { color: gold; }
    .achievement-item.locked .status { color: #888; }

    /* Settings Modal Specifics (Unchanged) */
    #settings-modal .modal-content { border-color: silver; }
    #settings-modal .modal-content h2 { color: silver; }

    /* Ad Placeholder (Unchanged) */
    #ad-placeholder {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9); color: white; display: none;
      flex-direction: column; align-items: center; justify-content: center;
      z-index: 150; text-align: center; font-size: clamp(1.2em, 4vw, 1.5em); padding: 20px;
    }
     #ad-placeholder p { margin-bottom: 20px; }
     #ad-placeholder .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #ffd700; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
     @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

     /* Pause Button (Position Updated) */
     #pause-button {
         position: absolute;
         top: 10px;
         left: 10px; /* MOVED to top-left */
         z-index: 10;
         font-size: clamp(1.5em, 5vw, 2em);
         background: rgba(255, 255, 255, 0.5);
         color: #333;
         border: 2px solid rgba(0,0,0,0.2);
         border-radius: 50%;
         width: 40px;
         height: 40px;
         line-height: 36px;
         text-align: center;
         cursor: pointer;
         display: none; /* Hidden initially */
         box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
         transition: background-color 0.2s ease;
     }
      #pause-button:hover {
          background: rgba(255, 255, 255, 0.8);
      }

     /* Responsive Adjustments (Unchanged) */
     @media (max-height: 450px) and (orientation: landscape) {
        .modal-content { padding: 10px 15px; }
        .modal-content h2 { font-size: 1em; }
        .modal-content p { font-size: 0.7em; margin-bottom: 10px;}
        .modal-close-button, .modal-button { font-size: 0.7em; padding: 6px 12px; }
        #daily-bonus-breakdown { margin: 10px auto; }
        #daily-bonus-breakdown li { font-size: 0.65em; }
        #pause-button { width: 35px; height: 35px; line-height: 31px; font-size: clamp(1.2em, 4vw, 1.7em); }
     }
     @media (max-width: 480px) {
         .modal-content { width: 95%; }
         #pause-button { width: 35px; height: 35px; line-height: 31px; font-size: clamp(1.2em, 4vw, 1.7em); }
     }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="powerup-indicators">
      <span id="shield-indicator" class="indicator">üõ°Ô∏è</span>
      <span id="magnet-indicator" class="indicator">üß≤</span>
      <span id="life-indicator" class="indicator">‚ù§Ô∏è</span>
    </div>
    <button id="pause-button">‚è∏Ô∏è</button>

    <div id="mission-complete-popup">Mission Complete!</div>
    <div id="reward-popup">Reward!</div>
    <div id="level-up-popup">Level Up!</div>
    <div id="achievement-popup">Achievement Unlocked!</div>
    <div id="store-interface">
      <h2>Power-up Store</h2>
      <p>Your Coins: <span id="store-coin-balance">0</span> ü™ô</p>
      <div class="store-section">
        <h3>Single Use Power-ups</h3>
        <div class="store-item">
          <h4>Shield (üõ°Ô∏è) - Cost: <span class="cost" data-item="shield">150</span> ü™ô</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-shield">Buy Shield</button>
          <p>Owned: <span id="shield-owned">0</span></p>
        </div>
        <div class="store-item">
          <h4>Extra Life (‚ù§Ô∏è) - Cost: <span class="cost" data-item="life">200</span> ü™ô</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-life">Buy Extra Life</button>
          <p>Owned: <span id="life-owned">0</span></p>
        </div>
        <div class="store-item">
          <h4>Coin Magnet (üß≤) - Cost: <span class="cost" data-item="magnet">175</span> ü™ô</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-magnet">Buy Coin Magnet</button>
          <p>Owned: <span id="magnet-owned">0</span></p>
        </div>
      </div>
      <div class="store-section">
        <h3>Permanent Upgrades</h3>
        <div class="store-item">
          <h4>Magnet Duration</h4>
          <p>Increase Coin Magnet active time.</p>
          <p class="upgrade-level">Level: <span id="magnet-duration-level">0</span></p>
          <button id="upgrade-magnet-duration">Upgrade (Cost: <span id="magnet-duration-cost">0</span> ü™ô)</button>
        </div>
        <div class="store-item">
          <h4>Starting Coins</h4>
          <p>Begin each run with extra coins.</p>
          <p class="upgrade-level">Level: <span id="start-coin-level">0</span></p>
          <button id="upgrade-start-coin">Upgrade (Cost: <span id="start-coin-cost">0</span> ü™ô)</button>
        </div>
        <div class="store-item">
          <h4>Life Effectiveness</h4>
          <p>Clear more obstacles when using an Extra Life.</p>
          <p class="upgrade-level">Level: <span id="life-effectiveness-level">0</span></p>
          <button id="upgrade-life-effectiveness">Upgrade (Cost: <span id="life-effectiveness-cost">0</span> ü™ô)</button>
        </div>
      </div>
      <div class="store-section">
        <h3>Extras</h3>
        <div class="store-item">
          <h4>Remove Ads (Simulation)</h4>
          <p>Permanently remove ads shown between runs.</p>
          <button id="buy-remove-ads">$5.00 Remove Ads</button>
          <p style="font-size: 0.7em; color: #ccc;">(Simulation Only - No Real Charge)</p>
          <p id="ads-removed-status" style="display: none; color: lime; margin-top: 5px;">Ads Removed!</p>
        </div>
      </div>
      <button id="close-store">Close Store</button>
    </div>
  </div>

  <div id="daily-login-modal" class="modal">
    <div class="modal-content">
      <h2 id="daily-login-title">Welcome Back!</h2>
      <p id="daily-login-message">Here's your daily reward!</p>
      <p style="font-size: 0.9em; margin-bottom: 5px; color: gold;">Consecutive Bonus:</p>
      <ul id="daily-bonus-breakdown"></ul>
      <button id="daily-login-close" class="modal-close-button">Claim & Close</button>
    </div>
  </div>

  <div id="achievement-modal" class="modal">
    <div class="modal-content">
      <h2>Achievements</h2>
      <ul id="achievement-list"></ul>
      <button id="achievement-close" class="modal-close-button">Close</button>
    </div>
  </div>

  <div id="settings-modal" class="modal">
      <div class="modal-content">
          <h2>Settings</h2>
          <button id="toggle-sound-button" class="modal-button">Sound: ON</button>
          <button id="resume-button" class="modal-button">Resume</button>
          </div>
  </div>

  <div id="ad-placeholder">
    <p>Loading Ad...</p>
    <div class="spinner"></div>
    <p style="font-size: 0.7em; margin-top: 15px;">(This is a placeholder)</p>
  </div>

  <script>
    /* Service worker script (unchanged) */
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').then(registration => {
          console.log('SW registered: ', registration);
        }).catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
      });
    }

    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const storeInterface = document.getElementById('store-interface');
    const storeCoinBalance = document.getElementById('store-coin-balance');
    const buyShieldButton = document.getElementById('buy-shield');
    const buyLifeButton = document.getElementById('buy-life');
    const buyMagnetButton = document.getElementById('buy-magnet');
    const shieldOwnedDisplay = document.getElementById('shield-owned');
    const lifeOwnedDisplay = document.getElementById('life-owned');
    const magnetOwnedDisplay = document.getElementById('magnet-owned');
    const closeStoreButton = document.getElementById('close-store');
    const shieldIndicator = document.getElementById('shield-indicator');
    const magnetIndicator = document.getElementById('magnet-indicator');
    const lifeIndicator = document.getElementById('life-indicator');
    const gameContainer = document.getElementById('game-container');
    const missionCompletePopup = document.getElementById('mission-complete-popup');
    const rewardPopup = document.getElementById('reward-popup');
    const levelUpPopup = document.getElementById('level-up-popup');
    const achievementPopup = document.getElementById('achievement-popup');
    const dailyLoginModal = document.getElementById('daily-login-modal');
    const dailyLoginTitle = document.getElementById('daily-login-title');
    const dailyLoginMessage = document.getElementById('daily-login-message');
    const dailyBonusBreakdownList = document.getElementById('daily-bonus-breakdown'); // Added
    const dailyLoginCloseButton = document.getElementById('daily-login-close');
    const magnetDurationLevelDisplay = document.getElementById('magnet-duration-level');
    const magnetDurationCostDisplay = document.getElementById('magnet-duration-cost');
    const magnetDurationUpgradeButton = document.getElementById('upgrade-magnet-duration');
    const startCoinLevelDisplay = document.getElementById('start-coin-level');
    const startCoinCostDisplay = document.getElementById('start-coin-cost');
    const startCoinUpgradeButton = document.getElementById('upgrade-start-coin');
    const lifeEffectivenessLevelDisplay = document.getElementById('life-effectiveness-level');
    const lifeEffectivenessCostDisplay = document.getElementById('life-effectiveness-cost');
    const lifeEffectivenessUpgradeButton = document.getElementById('upgrade-life-effectiveness');
    const achievementModal = document.getElementById('achievement-modal');
    const achievementList = document.getElementById('achievement-list');
    const achievementCloseButton = document.getElementById('achievement-close');
    const adPlaceholder = document.getElementById('ad-placeholder');
    const buyRemoveAdsButton = document.getElementById('buy-remove-ads');
    const adsRemovedStatus = document.getElementById('ads-removed-status');
    // --- NEW: Pause/Settings Elements ---
    const pauseButton = document.getElementById('pause-button');
    const settingsModal = document.getElementById('settings-modal');
    const resumeButton = document.getElementById('resume-button');
    const toggleSoundButton = document.getElementById('toggle-sound-button');


    // --- Game Variables ---
    let score = 0; let highScore = 0; let coins = 0;
    let shieldsOwned = 0; let livesOwned = 0; let magnetsOwned = 0;
    const initialGameSpeed = 3.5; // Keep increased speed
    let gameSpeed = initialGameSpeed; let baseGameSpeed = initialGameSpeed;
    const speedIncrement = 0.4; let lastScoreThreshold = 0; // More aggressive speed increase
    const speedIncreaseInterval = 75; // Increase speed every 75 points instead of 100
    let gravity = 0.7; const fastFallMultiplier = 2.5; // Faster gravity for snappier jumps
    let isGameOver = true; let isGameRunning = false; let animationFrameId;
    let obstacles = []; let coinObjects = []; let clouds = []; let mysteryBoxes = [];
    let frameCount = 0;
    let isShieldActive = false; let isMagnetActive = false; let magnetTimer = 0;
    let baseMagnetDuration = 600; let currentMagnetDuration = baseMagnetDuration;
    let extraLives = 0;
    let isInvincibleBoostActive = false; let invincibleBoostTimer = 0; const invincibleBoostDuration = 300;
    let isDoubleCoinsBoostActive = false; let doubleCoinsBoostTimer = 0; const doubleCoinsBoostDuration = 600;
    let isSpeedBoostActive = false; let speedBoostTimer = 0; const speedBoostAmount = 1.5;
    let isCoinRushActive = false; let coinRushTimer = 0; const coinRushDuration = 600;
    const coinRushChance = 0.0005; const coinRushMinScore = 500;
    let framesAfterReset = 0;
    let isNight = false;
    const dayNightCycleThreshold = 500; // Day/night switches every 500 points (was 700)
    const dayBgColor = '#87CEEB'; const nightBgColor = '#2c3e50';
    const dayGroundColor = '#D2B48C'; const nightGroundColor = '#B08D57';
    const dayTextColor = '#333'; const nightTextColor = '#ecf0f1';
    const dayBodyBgColor = '#f0f0f0'; const nightBodyBgColor = '#34495e';
    const nightUiBg = '#4a5a6a'; const nightUiBorder = '#7f8c8d';
    let currentBgColor = dayBgColor;
    const missionPool = [ { id: 'score100', description: 'Reach Score 100', target: 100, reward: 15, type: 'score' }, { id: 'collect5', description: 'Collect 5 coins', target: 5, reward: 15, type: 'coins' }, { id: 'score300', description: 'Reach Score 300', target: 300, reward: 30, type: 'score' }, { id: 'jump5cacti', description: 'Jump over 5 cacti', target: 5, reward: 35, type: 'jump_cactus' }, { id: 'collect15', description: 'Collect 15 coins', target: 15, reward: 40, type: 'coins' }, { id: 'score750', description: 'Reach Score 750', target: 750, reward: 75, type: 'score' }, { id: 'duck3birds', description: 'Duck under 3 birds', target: 3, reward: 45, type: 'duck_bird' }, { id: 'collect30', description: 'Collect 30 coins', target: 30, reward: 80, type: 'coins' }, ];
    let activeMission = null; let missionProgress = 0;
    let coinsCollectedThisRun = 0; let cactiJumpedThisRun = 0; let birdsDuckedThisRun = 0;
    let missionNotificationText = ""; let missionNotificationTimer = 0; const missionNotificationDuration = 180;
    const shieldCost = 150; const lifeCost = 200; const magnetCost = 175;
    let playerXP = 0; let playerLevel = 1;
    const xpPerScorePoint = 0.1;
    function xpForLevelUp(level) { return Math.floor(100 * Math.pow(level, 1.5)); }
    let magnetDurationUpgradeLevel = 0; let startCoinUpgradeLevel = 0; let lifeEffectivenessUpgradeLevel = 0;
    const baseMagnetDurationCost = 150; const baseStartCoinCost = 200; const baseLifeEffectivenessCost = 250;
    const magnetMaxLevel = 10; const startCoinMaxLevel = 10; const lifeEffectMaxLevel = 5;
    let totalDistanceRun = 0; let totalCoinsCollected = 0; let totalCactiJumped = 0;
    let totalBirdsDucked = 0; let totalShieldsUsed = 0; let totalNightsSurvived = 0;
    let runCount = 0; let adsRemoved = false; let adDisplayPending = false;
    let jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth;
    let levelUpSynth, achievementSynth;
    let audioReady = false;
    let touchStartX = 0; let touchStartY = 0; let touchStartTime = 0; let isSwiping = false;
    const minSwipeYDistance = 50; const maxSwipeXDistance = 50; const maxTapTime = 250;
    let storeButtonBounds = null; let achievementButtonBounds = null;
    const groundHeight = 120; // Keep increased ground height

    // --- NEW: Pause State ---
    let isPaused = false;
    let isSoundMuted = false; // Sound state

    // --- Daily Play Log ---
    let dailyPlayLog = [];

    // --- Llama Object (Increased Size, Adjusted X, Adjusted Jump) ---
    const llama = {
        x: 120, // Keep Llama further right
        y: 0,
        // Increased draw/hitbox size based on p=4
        drawWidth: 56 * 2, drawHeight: 56 * 2, // p=4 -> 2 * original p=2
        width: 50 * 2, height: 52 * 2,
        dy: 0,
        jumpPower: -21, // Increased for faster, snappier jumps (matches higher gravity)
        isJumping: false,
        isDucking: false,
        duckHeight: 30 * 2, // Scaled duck height
        baseY: 0,
        runFrame: 0,
        runAnimationSpeed: 5,
        // --- Llama Drawing (Using Increased Scale Factor p=4) ---
        draw() {
            const bodyHigh='#F5E5D0', bodyLight='#EAD8BF', bodyMain='#D8B898', bodyShade='#B89878';
            const legMain='#A08060', legShade='#806040', hoof='#604030';
            const faceMain='#F0D0B0', earInner='#E0C0A0', eyeWhite='#FFFFFF', eyePupil='#000000', nose='#705040', hair='#907050';
            const p = 4; // Keep increased pixel scale factor

            ctx.save();
            ctx.translate(Math.round(this.x), Math.round(this.y));

            let scaleY = 1;
            let duckOffsetY = 0;
            if (this.isDucking) {
                scaleY = this.duckHeight / this.height;
                duckOffsetY = this.drawHeight * (1 - scaleY);
                ctx.translate(0, duckOffsetY);
                ctx.scale(1, scaleY);
            }

            // Llama Body (Uses new 'p' value automatically)
            ctx.fillStyle=bodyMain; ctx.fillRect(p*4, p*4, p*18, p*14);
            ctx.fillStyle=bodyShade; ctx.fillRect(p*5, p*15, p*16, p*3);
            ctx.fillStyle=bodyLight; ctx.fillRect(p*5, p*4, p*16, p*3); ctx.fillRect(p*4, p*6, p*2, p*10); ctx.fillRect(p*3, p*8, p*1, p*6);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*2, p*7, p*2, p*8);
            ctx.fillStyle=hair; ctx.fillRect(p*0, p*10, p*4, p*4); ctx.fillRect(p*-1, p*11, p*2, p*2);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*16, p*-1, p*6, p*8);
            ctx.fillStyle=bodyShade; ctx.fillRect(p*16, p*5, p*5, p*2);
            ctx.fillStyle=hair; ctx.fillRect(p*15, p*-4, p*7, p*5); ctx.fillRect(p*17, p*-6, p*3, p*2); ctx.fillRect(p*14, p*-1, p*3, p*3);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-9, p*9, p*10);
            ctx.fillStyle=faceMain; ctx.fillRect(p*26, p*-6, p*4, p*6);
            ctx.fillStyle=nose; ctx.fillRect(p*28, p*-3, p*2, p*1); ctx.fillRect(p*27, p*0, p*3, p*1);
            ctx.fillStyle=eyeWhite; ctx.fillRect(p*23, p*-5, p*2, p*2);
            ctx.fillStyle=eyePupil; ctx.fillRect(p*24, p*-4, p*1, p*1);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-13, p*3, p*5); ctx.fillRect(p*23, p*-13, p*3, p*5);
            ctx.fillStyle=earInner; ctx.fillRect(p*20, p*-12, p*1, p*3); ctx.fillRect(p*24, p*-12, p*1, p*3);

            // Legs (Uses new 'p' value automatically)
            const currentRunFrame = Math.floor(this.runFrame / this.runAnimationSpeed) % 2;
            const upperLegW=p*3, upperLegH=p*5, lowerLegW=p*3, lowerLegH=p*4, hoofH=p*2;
            const frontUpperX=p*6, frontUpperY=p*17;
            const backUpperX=p*14, backUpperY=p*17;

            if (this.isJumping) { // Jumping legs
                ctx.fillStyle=legShade; ctx.fillRect(frontUpperX-p*1,frontUpperY,upperLegW,upperLegH+lowerLegH);
                ctx.fillStyle=legMain; ctx.fillRect(frontUpperX-p*1+p,frontUpperY,upperLegW-p*2,upperLegH+lowerLegH);
                ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*1,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                ctx.fillStyle=legShade; ctx.fillRect(backUpperX-p*1,backUpperY,upperLegW,upperLegH+lowerLegH);
                ctx.fillStyle=legMain; ctx.fillRect(backUpperX-p*1+p,backUpperY,upperLegW-p*2,upperLegH+lowerLegH);
                ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*1,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
            } else if (this.isDucking) { // Ducking legs (shortened)
                const duckLegH=p*4; const duckHoofY=frontUpperY+duckLegH;
                ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,duckLegH);
                ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,duckLegH);
                ctx.fillStyle=hoof; ctx.fillRect(frontUpperX,duckHoofY,upperLegW,hoofH);
                ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,duckLegH);
                ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,duckLegH);
                ctx.fillStyle=hoof; ctx.fillRect(backUpperX,duckHoofY,upperLegW,hoofH);
            } else { // Running legs animation
                if(currentRunFrame === 0) {
                    ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX+p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                    ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX-p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                } else {
                    ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX-p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                    ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX+p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                }
            }

            // Powerup Effects
            if (isInvincibleBoostActive) {
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(frameCount * 0.3) * 0.3})`;
                ctx.lineWidth = 3 + Math.sin(frameCount * 0.4) * 1.5;
                ctx.beginPath();
                let hitboxVisualY = this.isDucking ? duckOffsetY : 0;
                let hitboxDrawHeight = this.height * scaleY;
                let hitboxDrawWidth = this.width;
                let radiusX = (hitboxDrawWidth / 2) + 6 + Math.sin(frameCount * 0.2) * 3;
                let radiusY = (hitboxDrawHeight / 2) + 6 + Math.sin(frameCount * 0.2) * 3;
                ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 );
                ctx.stroke();
            } else if (isShieldActive) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                ctx.lineWidth = 2 + Math.sin(frameCount * 0.2) * 1;
                ctx.beginPath();
                let hitboxVisualY = this.isDucking ? duckOffsetY : 0;
                let hitboxDrawHeight = this.height * scaleY;
                let hitboxDrawWidth = this.width;
                let radiusX = (hitboxDrawWidth / 2) + 4 + Math.sin(frameCount * 0.15) * 2;
                let radiusY = (hitboxDrawHeight / 2) + 4 + Math.sin(frameCount * 0.15) * 2;
                ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 );
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = frameCount * -1.5;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
            }
            ctx.restore();
        },
        update() { let appliedGravity = gravity; const airborne = this.y < this.baseY || this.dy > 0; if (airborne && this.isDucking) { appliedGravity *= fastFallMultiplier; } if (this.y < this.baseY || this.dy < 0) { this.dy += appliedGravity; } else { this.dy = 0; this.y = this.baseY; if (this.isJumping) { this.isJumping = false;} } this.y += this.dy; if (this.y > this.baseY) { this.y = this.baseY; this.dy = 0; if (this.isJumping) { this.isJumping = false; } } if (!this.isJumping && !this.isDucking && this.y >= this.baseY) { this.runFrame++; } else if (!this.isJumping && this.y >= this.baseY) { this.runFrame = 0; } else { this.runFrame = 0; } },
        jump() { if (isGameRunning && !this.isJumping && !this.isDucking && this.y >= this.baseY) { this.dy = this.jumpPower; this.isJumping = true; this.isDucking = false; if(!isSoundMuted && audioReady) jumpSynth?.triggerAttackRelease("F#5", "16n"); } },
        duck(shouldDuck) { if (isGameRunning) { if(shouldDuck && this.isJumping) return; this.isDucking = shouldDuck; } else { this.isDucking = false; } },
        reset() {
            this.baseY = canvas.height - groundHeight - this.height; // Uses new groundHeight & llama height
            this.y = this.baseY;
            this.dy = 0;
            this.isJumping = false;
            this.isDucking = false;
            this.runFrame = 0;
            console.log(`Llama reset. CanvasH: ${canvas.height.toFixed(2)}, Ground: ${groundHeight}, LlamaH: ${this.height}, BaseY: ${this.baseY.toFixed(2)}`);
            if (this.baseY < 0 || this.baseY > canvas.height) {
                 console.warn(`Llama baseY (${this.baseY.toFixed(2)}) might be outside canvas height (${canvas.height.toFixed(2)})`);
            }
        }
    };

    // --- Obstacle Class ---
    class Obstacle { constructor(x, y, width, height, type) { this.x = x; this.y = y; this.width = width; this.height = height; this.type = type; }
        // --- Obstacle Drawing (Increased Scale Factor p=4) ---
        draw() {
            if (this.type === 'cactus') {
                const p = 4; // <<< INCREASED PIXEL SCALE FACTOR (was 3)
                const mainColor='#2E8B57', darkColor='#228B22', lightColor='#3CB371', spineColor='#1A4D2E';
                ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y));
                const conceptualHeight = this.height / p;
                const conceptualWidth = this.width / p;
                const segmentHeight = Math.max(2, Math.floor(conceptualHeight / 5));
                for (let i_concept = 0; i_concept < conceptualHeight; i_concept += 1) { const i_draw = i_concept * p; const segmentIndex = Math.floor(i_concept / segmentHeight); const currentMain = (segmentIndex % 2 === 0) ? mainColor : lightColor; const currentDark = (segmentIndex % 2 === 0) ? darkColor : mainColor; const currentLight = (segmentIndex % 2 === 0) ? lightColor : '#54C581'; ctx.fillStyle = currentMain; ctx.fillRect(p * 2, i_draw, conceptualWidth*p - p * 4, p); ctx.fillStyle = currentDark; ctx.fillRect(p * 2, i_draw, p * 1, p); ctx.fillRect(conceptualWidth*p - p * 3, i_draw, p * 1, p); ctx.fillStyle = currentLight; ctx.fillRect(p * 3, i_draw, p * (conceptualWidth > 4 ? 2 : 1), p); }
                ctx.fillStyle = darkColor; ctx.fillRect(p * 2, this.height - p * 2, conceptualWidth*p - p * 4, p * 2);
                const armW_concept = Math.max(3, Math.floor(conceptualWidth * 0.4)); const armH_concept = Math.max(5, Math.floor(conceptualHeight * 0.5)); const armLX_concept = 2 - armW_concept; const armLY_concept = conceptualHeight * 0.3;
                ctx.fillStyle = mainColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, p, armH_concept*p); ctx.fillRect((armLX_concept+armW_concept)*p-p, armLY_concept*p, p, armH_concept*p); ctx.fillRect(armLX_concept*p, (armLY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armLX_concept+1)*p, armLY_concept*p, (armW_concept-2)*p, p);
                const armRX_concept = conceptualWidth - 2; const armRY_concept = conceptualHeight * 0.15;
                ctx.fillStyle = mainColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, p, armH_concept*p); ctx.fillRect((armRX_concept+armW_concept)*p-p, armRY_concept*p, p, armH_concept*p); ctx.fillRect(armRX_concept*p, (armRY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armRX_concept+1)*p, armRY_concept*p, (armW_concept-2)*p, p);
                ctx.fillStyle = spineColor; for(let i = 0; i < conceptualHeight / 2; i++) { ctx.fillRect(p*2 + Math.random()*(this.width-p*4), Math.random()*this.height, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armLX_concept*p + Math.random()*armW_concept*p, armLY_concept*p + Math.random()*armH_concept*p, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armRX_concept*p + Math.random()*armW_concept*p, armRY_concept*p + Math.random()*armH_concept*p, p/2, p/2); }
                ctx.restore();
            } else if (this.type === 'bird') {
                const p_bird = 4; // <<< INCREASED PIXEL SCALE FACTOR (was 3)
                const cs = { bodyLight: '#FFDAB9', bodyMain: '#FFA500', bodyDark: '#CD853F', wingHigh: '#FFF8DC', wingLight: '#FFE4B5', wingMain: '#FFDEAD', beak: '#A0522D', eye: '#000000', eyeWhite: '#FFFFFF' };
                ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y));
                ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*8); ctx.fillStyle = cs.bodyLight; ctx.fillRect(p_bird*6, p_bird*8, p_bird*10, p_bird*4); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*2); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*5); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*1); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*6); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*1); ctx.fillStyle = cs.beak; ctx.fillRect(p_bird*-3, p_bird*3, p_bird*4, p_bird*2); ctx.fillRect(p_bird*-2, p_bird*4, p_bird*2, p_bird*1); ctx.fillStyle = cs.eyeWhite; ctx.fillRect(p_bird*2, p_bird*3, p_bird*3, p_bird*3); ctx.fillStyle = cs.eye; ctx.fillRect(p_bird*3, p_bird*4, p_bird*1, p_bird*1);
                const flap = Math.sin(frameCount * 0.4) * p_bird * 5;
                ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*5); ctx.lineTo(p_bird*10, p_bird*-1 + flap); ctx.lineTo(p_bird*8, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*5); ctx.lineTo(p_bird*10, p_bird*1 + flap); ctx.lineTo(p_bird*9, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*5); ctx.lineTo(p_bird*10, p_bird*2 + flap); ctx.lineTo(p_bird*9.5, p_bird*6); ctx.closePath(); ctx.fill();
                ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*10); ctx.lineTo(p_bird*10, p_bird*14 - flap); ctx.lineTo(p_bird*8, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*10); ctx.lineTo(p_bird*10, p_bird*13 - flap); ctx.lineTo(p_bird*9, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*10); ctx.lineTo(p_bird*10, p_bird*12 - flap); ctx.lineTo(p_bird*9.5, p_bird*9); ctx.closePath(); ctx.fill();
                ctx.restore();
            }
        }
        update() { this.x -= gameSpeed; }
    }
    class Cloud { constructor(x, y, width, height, speed) { this.x = x; this.y = y; this.width = width; this.height = height; this.speed = speed; } draw() { const p = 1; const c1='#FFFFFF', c2='#F0F8FF', c3='#E0E8EF'; ctx.save(); ctx.globalAlpha = 0.8; ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle=c1; ctx.fillRect(0, p*5, this.width, this.height - p*5); ctx.beginPath(); ctx.arc(this.width * 0.25, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.arc(this.width * 0.75, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = c2; ctx.fillRect(this.width * 0.1, this.height - p*5, this.width*0.8, p*5); ctx.restore(); } update() { this.x -= this.speed; } }
    // --- Coin Class (Increased Radius) ---
    class Coin {
        constructor(x,y,r = 20){ // <<< INCREASED default radius (was 15)
            this.x=x; this.y=y; this.radius=r; this.collected=false;
        }
        draw() { if (!this.collected) { const bob = Math.sin(frameCount * 0.1 + this.x * 0.05) * 3; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const centerX = drawX + this.radius; const centerY = drawY + this.radius; const outlineColor = '#B8860B'; const mainColor = '#FFD700'; const shadowColor = '#DAA520'; const highlightColor = '#FFFFE0'; ctx.save(); ctx.translate(centerX, centerY); ctx.fillStyle = outlineColor; ctx.beginPath(); ctx.arc(0, 0, this.radius + 1, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = mainColor; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = shadowColor; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = highlightColor; ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, Math.PI * 1.2, Math.PI * 1.9); ctx.fill(); ctx.restore(); } }
        update(){ this.x-=gameSpeed; }
    }
    // --- Mystery Box Class (Increased Size) ---
    class MysteryBox {
        constructor(x, y, size = 65) { // <<< INCREASED default size (was 50)
            this.x = x; this.y = y; this.width = size; this.height = size;
            this.collected = false; this.openTimer = 0; this.openDuration = 30;
            this.bobOffset = Math.random() * Math.PI * 2;
        }
        draw() { const bob = Math.sin(frameCount * 0.08 + this.bobOffset) * 4; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const size = this.width; ctx.save(); ctx.translate(drawX, drawY); if (this.collected && this.openTimer > 0) { const progress = 1 - (this.openTimer / this.openDuration); const spinAngle = progress * Math.PI * 2; const scale = 1 + progress * 0.5; const alpha = 1 - progress; ctx.globalAlpha = alpha; ctx.translate(size / 2, size / 2); ctx.rotate(spinAngle); ctx.scale(scale, scale); ctx.translate(-size / 2, -size / 2); ctx.fillStyle = '#c0c0c0'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = '#ffd700'; ctx.fillRect(size * 0.3, size * 0.2, size * 0.4, size * 0.6); } else if (!this.collected) { const p = Math.max(2, Math.floor(size / 10)); const mainColor = '#a0522d'; const bandColor = '#ffd700'; const shadowColor = '#8b4513'; const rivetColor = '#c0c0c0'; ctx.fillStyle = mainColor; ctx.fillRect(0, 0, size, size); ctx.fillStyle = shadowColor; ctx.fillRect(0, size - p, size, p); ctx.fillRect(size - p, 0, p, size); ctx.fillStyle = bandColor; ctx.fillRect(0, size * 0.4, size, size * 0.2); ctx.fillRect(size * 0.4, 0, size * 0.2, size); ctx.fillStyle = rivetColor; ctx.fillRect(p, p, p, p); ctx.fillRect(size - p * 2, p, p, p); ctx.fillRect(p, size - p * 2, p, p); ctx.fillRect(size - p * 2, size - p * 2, p, p); ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.sin(frameCount * 0.15) * 0.3})`; ctx.font = `bold ${size * 0.6}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("?", size / 2, size / 2 + p); } ctx.restore(); }
        update() { this.x -= gameSpeed; if (this.collected && this.openTimer > 0) { this.openTimer--; } }
        collect() { if (!this.collected) { this.collected = true; this.openTimer = this.openDuration; if(!isSoundMuted && audioReady) mysteryCollectSynth?.triggerAttackRelease("C5", "8n", Tone.now()); setTimeout(() => grantMysteryReward(this), 100); } }
    }

    // --- PowerUp Class (Random spawning power-ups) ---
    let powerUpObjects = []; // Array to hold spawned power-ups
    const powerUpTypes = ['shield', 'magnet', 'invincible', 'double_coins', 'speed_boost'];
    const powerUpEmojis = { shield: 'üõ°Ô∏è', magnet: 'üß≤', invincible: '‚≠ê', double_coins: 'üí∞', speed_boost: '‚ö°' };
    const powerUpColors = { shield: '#00CED1', magnet: '#FFD700', invincible: '#FFD700', double_coins: '#32CD32', speed_boost: '#FF6347' };

    class PowerUp {
        constructor(x, y, type, size = 50) {
            this.x = x; this.y = y; this.width = size; this.height = size;
            this.type = type; this.collected = false;
            this.bobOffset = Math.random() * Math.PI * 2;
            this.glowPhase = Math.random() * Math.PI * 2;
        }
        draw() {
            if (this.collected) return;
            const bob = Math.sin(frameCount * 0.1 + this.bobOffset) * 5;
            const drawX = Math.round(this.x);
            const drawY = Math.round(this.y + bob);
            const size = this.width;
            ctx.save();
            ctx.translate(drawX, drawY);
            // Glowing circle background
            const glowIntensity = 0.5 + Math.sin(frameCount * 0.15 + this.glowPhase) * 0.3;
            ctx.fillStyle = `rgba(255, 255, 255, ${glowIntensity * 0.5})`;
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2 + 5, 0, Math.PI * 2);
            ctx.fill();
            // Main circle
            ctx.fillStyle = powerUpColors[this.type] || '#FFFFFF';
            ctx.beginPath();
            ctx.arc(size/2, size/2, size/2, 0, Math.PI * 2);
            ctx.fill();
            // Border
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 3;
            ctx.stroke();
            // Emoji
            ctx.fillStyle = 'white';
            ctx.font = `${size * 0.5}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(powerUpEmojis[this.type] || '?', size/2, size/2);
            ctx.restore();
        }
        update() { this.x -= gameSpeed; }
        collect() {
            if (this.collected) return;
            this.collected = true;
            if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["E4", "G4", "B4"], "8n");
            // Apply power-up effect
            switch(this.type) {
                case 'shield':
                    if (!isShieldActive && !isInvincibleBoostActive) {
                        isShieldActive = true;
                        showPopup(rewardPopup, 'Shield Activated!');
                    } else { coins += 25; showPopup(rewardPopup, '+25 Coins!'); }
                    break;
                case 'magnet':
                    if (!isMagnetActive) {
                        isMagnetActive = true;
                        magnetTimer = currentMagnetDuration;
                        showPopup(rewardPopup, 'Coin Magnet!');
                    } else { magnetTimer += 300; showPopup(rewardPopup, '+Magnet Time!'); }
                    break;
                case 'invincible':
                    isInvincibleBoostActive = true;
                    invincibleBoostTimer = invincibleBoostDuration + 150; // Slightly longer from pickup
                    showPopup(rewardPopup, 'Invincible! (7s)');
                    break;
                case 'double_coins':
                    isDoubleCoinsBoostActive = true;
                    doubleCoinsBoostTimer = doubleCoinsBoostDuration;
                    showPopup(rewardPopup, '2x Coins! (10s)');
                    break;
                case 'speed_boost':
                    // Speed boost gives temporary invincibility + speed
                    isInvincibleBoostActive = true;
                    invincibleBoostTimer = 180; // 3 seconds
                    gameSpeed += 2;
                    showPopup(rewardPopup, 'Speed Boost!');
                    break;
            }
            updatePowerupIndicators();
            updateDisplays();
        }
    }

    // --- Utility Functions ---
    function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
    // Calculate coin value based on current score (coins worth more as game progresses)
    function getCoinValue() {
        let baseValue = 1;
        // Every 250 points, coins are worth 1 more (up to max of 5)
        const scoreBonus = Math.min(4, Math.floor(score / 250));
        baseValue += scoreBonus;
        // Double coins boost doubles the final value
        if (isDoubleCoinsBoostActive) baseValue *= 2;
        return baseValue;
    }
    function showPopup(element, message, duration = 2000) { element.textContent = message; element.style.display = 'block'; requestAnimationFrame(() => { element.style.opacity = 1; }); setTimeout(() => { element.style.opacity = 0; setTimeout(() => { element.style.display = 'none'; }, 500); }, duration); }
    function getCurrentDateString() { return new Date().toISOString().split('T')[0]; }

    // --- Achievement Definitions & Handling (Unchanged) ---
    let achievements = [ { id: 'score_500', name: "Getting Started", description: "Reach a score of 500 points in a single run.", type: 'score', target: 500, reward: 25, unlocked: false }, { id: 'score_1500', name: "Pro Runner", description: "Reach a score of 1500 points in a single run.", type: 'score', target: 1500, reward: 75, unlocked: false }, { id: 'high_score_1000', name: "High Scorer", description: "Achieve a lifetime high score over 1000.", type: 'highScore', target: 1000, reward: 100, unlocked: false }, { id: 'coins_run_50', name: "Coin Collector", description: "Collect 50 coins in a single run.", type: 'coinsRun', target: 50, reward: 30, unlocked: false }, { id: 'coins_total_1000', name: "Coin Hoarder", description: "Collect 1000 coins across all runs.", type: 'totalCoins', target: 1000, reward: 100, unlocked: false }, { id: 'jump_total_100', name: "Frequent Flyer", description: "Jump over 100 cacti in total.", type: 'totalJumpCactus', target: 100, reward: 50, unlocked: false }, { id: 'duck_total_50', name: "Limbo Master", description: "Duck under 50 birds in total.", type: 'totalDuckBird', target: 50, reward: 50, unlocked: false }, { id: 'use_shield_10', name: "Shield User", description: "Successfully use 10 shields.", type: 'totalShieldsUsed', target: 10, reward: 40, unlocked: false }, { id: 'survive_night_1', name: "Night Owl", description: "Survive through a full night cycle (score ~700).", type: 'surviveNight', target: 1, reward: 60, unlocked: false }, { id: 'level_5', name: "Level 5 Reached", description: "Reach Player Level 5.", type: 'level', target: 5, reward: 50, unlocked: false }, { id: 'level_10', name: "Level 10 Reached", description: "Reach Player Level 10.", type: 'level', target: 10, reward: 150, unlocked: false }, ];
    function loadAchievements() { const savedAchievements = localStorage.getItem('llamaAchievements'); if (savedAchievements) { try { const loaded = JSON.parse(savedAchievements); achievements = achievements.map(def => { const saved = loaded.find(s => s.id === def.id); return { ...def, unlocked: saved ? saved.unlocked : false }; }); } catch (e) { console.error("Failed to parse saved achievements:", e); } } totalDistanceRun = parseInt(localStorage.getItem('llamaTotalDistance') || 0); totalCoinsCollected = parseInt(localStorage.getItem('llamaTotalCoinsCollected') || coins); totalCactiJumped = parseInt(localStorage.getItem('llamaTotalCactiJumped') || 0); totalBirdsDucked = parseInt(localStorage.getItem('llamaTotalBirdsDucked') || 0); totalShieldsUsed = parseInt(localStorage.getItem('llamaTotalShieldsUsed') || 0); totalNightsSurvived = parseInt(localStorage.getItem('llamaTotalNightsSurvived') || 0); }
    function saveAchievements() { try { const stateToSave = achievements.map(a => ({ id: a.id, unlocked: a.unlocked })); localStorage.setItem('llamaAchievements', JSON.stringify(stateToSave)); localStorage.setItem('llamaTotalDistance', totalDistanceRun); localStorage.setItem('llamaTotalCoinsCollected', totalCoinsCollected); localStorage.setItem('llamaTotalCactiJumped', totalCactiJumped); localStorage.setItem('llamaTotalBirdsDucked', totalBirdsDucked); localStorage.setItem('llamaTotalShieldsUsed', totalShieldsUsed); localStorage.setItem('llamaTotalNightsSurvived', totalNightsSurvived); } catch (e) { console.error("Failed to save achievements:", e); } }
    function checkAchievements(checkDuringRun = false) { let newUnlock = false; let nightSurvivedThisRun = isNight; achievements.forEach(ach => { if (!ach.unlocked) { let criteriaMet = false; switch (ach.type) { case 'score': criteriaMet = !checkDuringRun && score >= ach.target; break; case 'highScore': criteriaMet = !checkDuringRun && highScore >= ach.target; break; case 'coinsRun': criteriaMet = !checkDuringRun && coinsCollectedThisRun >= ach.target; break; case 'totalCoins': criteriaMet = totalCoinsCollected >= ach.target; break; case 'totalJumpCactus': criteriaMet = totalCactiJumped >= ach.target; break; case 'totalDuckBird': criteriaMet = totalBirdsDucked >= ach.target; break; case 'totalShieldsUsed': criteriaMet = totalShieldsUsed >= ach.target; break; case 'surviveNight': criteriaMet = !checkDuringRun && nightSurvivedThisRun; break; case 'level': criteriaMet = playerLevel >= ach.target; break; } if (criteriaMet) { ach.unlocked = true; newUnlock = true; coins += ach.reward; showPopup(achievementPopup, `Achievement Unlocked!\n${ach.name}\n+${ach.reward} Coins!`, 3000); if(!isSoundMuted && audioReady) achievementSynth?.triggerAttackRelease("C4", "1n"); console.log(`Achievement unlocked: ${ach.name}`); } } }); if (newUnlock) { saveAchievements(); updateDisplays(); } }
    function populateAchievementModal() { achievementList.innerHTML = ''; achievements.forEach(ach => { const li = document.createElement('li'); li.classList.add('achievement-item'); li.classList.toggle('unlocked', ach.unlocked); li.classList.toggle('locked', !ach.unlocked); const status = ach.unlocked ? 'Unlocked' : 'Locked'; let progressText = ''; if (!ach.unlocked) { if (ach.type === 'totalCoins') progressText = ` (${totalCoinsCollected}/${ach.target})`; else if (ach.type === 'totalJumpCactus') progressText = ` (${totalCactiJumped}/${ach.target})`; else if (ach.type === 'totalDuckBird') progressText = ` (${totalBirdsDucked}/${ach.target})`; else if (ach.type === 'totalShieldsUsed') progressText = ` (${totalShieldsUsed}/${ach.target})`; else if (ach.type === 'level') progressText = ` (Lv ${playerLevel}/${ach.target})`; } li.innerHTML = ` <span class="status">[${status}]</span> <h4>${ach.name}</h4> <p>${ach.description}${progressText}</p> ${ach.unlocked ? `<p>Reward: ${ach.reward} ü™ô</p>` : ''} `; achievementList.appendChild(li); }); }

    // --- Audio Setup ---
    function setupAudio() { if (audioReady) return; try { [jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth, levelUpSynth, achievementSynth].forEach(synth => { if (synth && typeof synth.dispose === 'function') { synth.dispose(); } }); jumpSynth = new Tone.Synth({ oscillator: { type: "square" }, volume: -8, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination(); coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 3, volume: -6, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.4, attackCurve: "exponential" } }).toDestination(); uiClickSynth = new Tone.Synth({ volume: -15, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 } }).toDestination(); missionSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); mysteryAppearSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.6 }, volume: -12, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(); mysteryCollectSynth = new Tone.Synth({ oscillator: { type: "fmtriangle", modulationType: "sine", harmonicity: 1.5 }, volume: -9, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination(); rewardSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, volume: -7, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination(); dailyBonusSynth = new Tone.Synth({ oscillator: { type: "fatsawtooth", count: 3, spread: 20 }, volume: -6, envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.4 } }).toDestination(); coinRushSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, volume: -10, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination(); levelUpSynth = new Tone.Synth({ oscillator: { type: "fatsquare", count: 4, spread: 30 }, volume: -5, envelope: { attack: 0.05, decay: 0.5, sustain: 0.3, release: 0.6 } }).toDestination(); achievementSynth = new Tone.Synth({ oscillator: { type: "pwm", modulationFrequency: 0.5 }, volume: -7, envelope: { attack: 0.02, decay: 0.6, sustain: 0.2, release: 0.5 } }).toDestination();
        // Apply initial mute state
        if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; }
        audioReady = true; console.log("Audio ready."); } catch (err) { console.error("Error setting up audio:", err); audioReady = false; } }

    // --- Game Functions ---
    function setBackground(isNightTime) { currentBgColor = isNightTime ? nightBgColor : dayBgColor; const bodyBg = isNightTime ? nightBodyBgColor : dayBodyBgColor; gameContainer.style.backgroundColor = currentBgColor; document.body.style.backgroundColor = bodyBg; document.querySelector('meta[name="theme-color"]').setAttribute('content', isNightTime ? nightBgColor : dayBgColor); }
    function drawStars() { if(!isNight)return; ctx.fillStyle='white'; for(let i=0;i<50;i++){ let x=(Math.random()*canvas.width*1.5 - frameCount*0.1)%(canvas.width); if(x<0)x+=(canvas.width); let y=Math.random()*canvas.height*0.7; let size=Math.random()>0.8?2:1; ctx.globalAlpha=0.5+Math.sin(frameCount*0.05+i)*0.5; ctx.fillRect(Math.round(x),Math.round(y),size,size);} ctx.globalAlpha=1.0; }
    // --- UPDATED resizeCanvas: Removed context scaling ---
    function resizeCanvas() {
        const container = document.getElementById('game-container');
        if (!container || !canvas) return;
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();

        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        canvas.style.width = `${rect.width}px`;
        canvas.style.height = `${rect.height}px`;

        // --- REMOVED --- ctx.scale(dpr, dpr);

        llama.reset();
        drawGround();
        setBackground(isNight);

        console.log(`Canvas resized. Style: ${rect.width}x${rect.height}, Buffer: ${canvas.width}x${canvas.height}`);

        if (isGameOver || !isGameRunning) {
            requestAnimationFrame(gameLoop);
        }
    }

    // --- UPDATED Drawing/Spawning Functions (Using physical canvas dimensions) ---
    function drawGround() { if (!ctx) return; ctx.fillStyle = isNight ? nightGroundColor : dayGroundColor; ctx.fillRect(0, canvas.height - groundHeight, canvas.width, groundHeight); ctx.fillStyle = isNight ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.1)'; const lineOffset = Math.floor(frameCount * gameSpeed) % 20; for(let i = -lineOffset; i < canvas.width; i+=20){ ctx.fillRect(i, canvas.height - groundHeight + 5, 2, groundHeight - 10); } }
    function spawnCloud() { const spawnChance=0.003; if(Math.random()<spawnChance){ const cw=getRandomInt(80,140); const ch=getRandomInt(40,70); const cy=Math.random()*(canvas.height * 0.3); const cs=gameSpeed*(0.05+Math.random()*0.1); clouds.push(new Cloud(canvas.width, cy, cw, ch, cs)); } }
    function updateClouds() { for(let i=clouds.length-1;i>=0;i--){ clouds[i].update(); clouds[i].draw(); if(clouds[i].x+clouds[i].width<0){ clouds.splice(i,1);}} }
    // --- UPDATED spawnObstacle (Increased Sizes & Adjusted Gaps) ---
    function spawnObstacle() {
        if (!isGameRunning || isPaused || isCoinRushActive) return;
        const speedFactor = Math.max(0.5, 1 - (gameSpeed / 25));
        // --- Adjusted Gaps ---
        const baseMinGap = 280; // <<< INCREASED (was 220)
        const randomGapAdd = 250; // Keep as is
        const absoluteMinGap = 220; // <<< INCREASED (was 180)
        // --- End Gap Adjustment ---
        const minGap = (baseMinGap + Math.random() * randomGapAdd) * speedFactor + absoluteMinGap;

        const lastObstacle = obstacles[obstacles.length - 1];
        if (!lastObstacle || (canvas.width - (lastObstacle.x + lastObstacle.width)) > minGap) {
            const type = Math.random() < 0.6 ? 'cactus' : 'bird';
            let obstacle;
            const sizeMultiplier = 2.0; // Keep larger size factor

            if (type === 'cactus') {
                const baseHeight = 46 + Math.random() * 30;
                const baseWidth = 30 + Math.random() * 10;
                const cactusHeight = baseHeight * sizeMultiplier;
                const cactusWidth = baseWidth * sizeMultiplier;
                obstacle = new Obstacle( canvas.width, canvas.height - groundHeight - cactusHeight, cactusWidth, cactusHeight, 'cactus' );
            } else {
                const baseBirdWidth = 40;
                const baseBirdHeight = 30;
                const birdHitboxWidth = baseBirdWidth * sizeMultiplier;
                const birdHitboxHeight = baseBirdHeight * sizeMultiplier;
                const clearance = 5 * sizeMultiplier;
                const birdY = canvas.height - groundHeight - llama.duckHeight - birdHitboxHeight - clearance; // Uses updated llama.duckHeight
                obstacle = new Obstacle( canvas.width, birdY, birdHitboxWidth, birdHitboxHeight, 'bird' );
            }
            obstacles.push(obstacle);
        }
    }
     // --- UPDATED spawnCoin (Using larger radius) ---
    function spawnCoin() {
        if (!isGameRunning || isPaused) return;
        let chance = 0.02;
        const minGap = 120; // Increased gap slightly for larger coins
        const lastCoin = coinObjects[coinObjects.length - 1];
        const spawnX = canvas.width;
        const r = 20; // Larger radius

        if (isCoinRushActive) {
            chance = 0.25;
            if (Math.random() < chance) {
                const numCoins = getRandomInt(2, 4);
                let startX = spawnX;
                if (lastCoin && (spawnX - (lastCoin.x + lastCoin.radius * 2)) < minGap * 0.5) {
                    startX = lastCoin.x + lastCoin.radius * 2 + minGap * 0.5;
                }
                for (let i = 0; i < numCoins; i++) {
                    const y = canvas.height - groundHeight - r*2 - 5 - Math.random() * (llama.height * 1.2); // Use llama.height
                    coinObjects.push(new Coin(startX + i * (r * 2.5), Math.max(y, r*2), r));
                }
            }
            return;
        }
        if (Math.random() < chance) {
            if (!lastCoin || (spawnX - (lastCoin.x + lastCoin.radius * 2)) > minGap) {
                const rf = Math.random();
                let y;
                if (rf < 0.5) { y = canvas.height - groundHeight - r*2 - 5; }
                else { const baseJumpHeight = canvas.height - groundHeight - r*2 - (llama.height * 0.6); y = baseJumpHeight - Math.random()*(llama.height*0.7); } // Use llama.height
                coinObjects.push(new Coin(spawnX, Math.max(y, r*2), r));
            }
        }
    }
    // --- Spawn Random PowerUp ---
    function spawnPowerUp() {
        if (!isGameRunning || isPaused || isCoinRushActive) return;
        // Power-ups spawn rarely, more common at higher scores
        const baseChance = 0.0003; // Base spawn chance
        const scoreBonus = Math.min(0.0004, score * 0.0000005); // Increases slightly with score
        const chance = baseChance + scoreBonus;
        const minGap = 600; // Minimum gap between power-ups
        const lastPowerUp = powerUpObjects[powerUpObjects.length - 1];
        const spawnX = canvas.width;
        const size = 50;

        if (Math.random() < chance && score >= 100) { // Only spawn after score 100
            const powerUpGapOk = !lastPowerUp || (spawnX - (lastPowerUp.x + lastPowerUp.width)) > minGap;
            if (powerUpGapOk) {
                // Random Y position (ground or air)
                let y;
                if (Math.random() < 0.4) {
                    y = canvas.height - groundHeight - size - 10; // Ground level
                } else {
                    y = canvas.height - groundHeight - size - (llama.height * 0.5) - Math.random() * (llama.height * 0.8); // Air
                }
                y = Math.max(size + 10, y);

                // Pick random power-up type (weighted)
                const rand = Math.random();
                let type;
                if (rand < 0.25) type = 'shield';
                else if (rand < 0.45) type = 'magnet';
                else if (rand < 0.65) type = 'double_coins';
                else if (rand < 0.85) type = 'invincible';
                else type = 'speed_boost';

                powerUpObjects.push(new PowerUp(spawnX, y, type, size));
                console.log(`Spawned ${type} power-up at score ${score}`);
            }
        }
    }

    // --- Update PowerUps ---
    function updatePowerUps() {
        for (let i = powerUpObjects.length - 1; i >= 0; i--) {
            const powerUp = powerUpObjects[i];
            if (!powerUp) continue;
            powerUp.update();
            powerUp.draw();
            if (!powerUp.collected && checkCollision(llama, powerUp)) {
                powerUp.collect();
                powerUpObjects.splice(i, 1);
            } else if (powerUp.x + powerUp.width < 0) {
                powerUpObjects.splice(i, 1);
            }
        }
    }

    // --- UPDATED spawnMysteryBox (Using larger size, reduced chance) ---
    function spawnMysteryBox() {
        if (!isGameRunning || isPaused || isCoinRushActive) return;
        const chance = 0.0004; // Rarer
        const minGap = 400;
        const obstacleSafetyMargin = 50;
        const spawnX = canvas.width;
        const lastBox = mysteryBoxes[mysteryBoxes.length - 1];
        const size = 65; // Larger size

        if (Math.random() < chance) {
            const boxGapOk = !lastBox || (spawnX - (lastBox.x + lastBox.width)) > minGap;
            if (boxGapOk) {
                let y;
                if (Math.random() < 0.5) { y = canvas.height - groundHeight - size - 5; }
                else { y = canvas.height - groundHeight - size - (llama.height * 0.7) - Math.random() * (llama.height * 0.6); } // Use llama.height
                y = Math.max(size, y);
                let cactusOverlap = false;
                for (const obs of obstacles) {
                    if (obs.type === 'cactus') {
                        const obsRightEdge = obs.x + obs.width;
                        const safetyDistance = size + obs.width + obstacleSafetyMargin;
                        if (obs.x < spawnX + size + obstacleSafetyMargin && obsRightEdge > spawnX - obstacleSafetyMargin) {
                            const boxBottom = y + size; const obsBottom = obs.y + obs.height;
                            if (y < obsBottom && boxBottom > obs.y) {
                                cactusOverlap = true;
                                console.log("Mystery box spawn skipped due to cactus overlap.");
                                break;
                            }
                        }
                    }
                }
                if (!cactusOverlap) {
                    mysteryBoxes.push(new MysteryBox(spawnX, y, size));
                    if (!isSoundMuted && audioReady) mysteryAppearSynth?.triggerAttackRelease("A4", "8n");
                }
            }
        }
    }
    function updateObstacles() { for (let i=obstacles.length-1; i>=0; i--) { const obs = obstacles[i]; if (!obs) continue; const wasBehindLlama = obs.x + obs.width < llama.x; obs.update(); obs.draw(); const isNowBehindLlama = obs.x + obs.width < llama.x; if (!wasBehindLlama && isNowBehindLlama && !isGameOver) { if (obs.type === 'cactus' && llama.isJumping) { cactiJumpedThisRun++; totalCactiJumped++; updateMissionProgress('jump_cactus', cactiJumpedThisRun); } else if (obs.type === 'bird' && llama.isDucking) { birdsDuckedThisRun++; totalBirdsDucked++; updateMissionProgress('duck_bird', birdsDuckedThisRun); } } if (checkCollision(llama, obs)) { handleCollision(obs); if (isGameOver) return; } if (obs.x + obs.width < 0) { obstacles.splice(i, 1); } } }
    function updateCoins() { const magnetRadius = isMagnetActive ? 100 : 0; for (let i=coinObjects.length-1; i>=0; i--) { const c = coinObjects[i]; if (!c) continue; c.update(); if (isMagnetActive && !c.collected) { const llamaCenterX = llama.x + llama.width / 2; const llamaHitboxY = llama.isDucking ? llama.y + (llama.height - llama.duckHeight) : llama.y; const llamaHitboxHeight = llama.isDucking ? llama.duckHeight : llama.height; const llamaCenterY = llamaHitboxY + llamaHitboxHeight / 2; const coinCenterX = c.x + c.radius; const coinCenterY = c.y + c.radius; const dx = llamaCenterX - coinCenterX; const dy = llamaCenterY - coinCenterY; const distance = Math.sqrt(dx*dx + dy*dy); if(distance < magnetRadius){ const magnetSpeed = 6; c.x += (dx / distance) * magnetSpeed; c.y += (dy / distance) * magnetSpeed;} } c.draw(); const effectiveRadius = isMagnetActive ? c.radius * 1.5 : c.radius; if (!c.collected && checkCollision(llama, c, true, effectiveRadius)) { c.collected=true; const indexToRemove = coinObjects.findIndex(coin => coin === c); if(indexToRemove !== -1) coinObjects.splice(indexToRemove,1); const coinValue = getCoinValue(); coins += coinValue; coinsCollectedThisRun += coinValue; totalCoinsCollected += coinValue; updateMissionProgress('coins', coinsCollectedThisRun); if(!isSoundMuted && audioReady) coinSynth.triggerAttackRelease("E6", "16n"); updateDisplays(); } else if (c.x + c.radius*2 < 0) { coinObjects.splice(i, 1); } } }
    function updateMysteryBoxes() { for (let i = mysteryBoxes.length - 1; i >= 0; i--) { const box = mysteryBoxes[i]; if (!box) continue; box.update(); box.draw(); if (!box.collected && checkCollision(llama, box)) { box.collect(); } if ((box.collected && box.openTimer <= 0) || box.x + box.width < 0) { mysteryBoxes.splice(i, 1); } } }
    function checkCollision(llamaRect, otherObj, isCoin = false, coinRadius = 0) { let llamaTop = llamaRect.isDucking ? llamaRect.y + (llamaRect.height - llamaRect.duckHeight) : llamaRect.y; let llamaHeight = llamaRect.isDucking ? llamaRect.duckHeight : llamaRect.height; let llamaLeft = llamaRect.x; let llamaWidth = llamaRect.width; let llamaBottom = llamaTop + llamaHeight; let llamaRight = llamaLeft + llamaWidth; if (isCoin) { let coinCenterX = otherObj.x + otherObj.radius; const bob = Math.sin(frameCount*0.1+otherObj.x*0.05)*3; let coinCenterY = otherObj.y + bob + otherObj.radius; let radius = coinRadius > 0 ? coinRadius : otherObj.radius; let closestX = Math.max(llamaLeft, Math.min(coinCenterX, llamaRight)); let closestY = Math.max(llamaTop, Math.min(coinCenterY, llamaBottom)); let distanceX = coinCenterX - closestX; let distanceY = coinCenterY - closestY; let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (radius * radius); } else { let objTop = otherObj.y; let objLeft = otherObj.x; let objWidth = otherObj.width; let objHeight = otherObj.height; let objBottom = objTop + objHeight; let objRight = objLeft + objWidth; return ( llamaLeft < objRight && llamaRight > objLeft && llamaTop < objBottom && llamaBottom > objTop ); } }
    function handleCollision(obs) { if (isInvincibleBoostActive) { const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); return; } if(isShieldActive){ isShieldActive=false; totalShieldsUsed++; updatePowerupIndicators(); const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("C4", "8n"); return; } if(extraLives>0){ extraLives--; updatePowerupIndicators(); const clearMultiplier = 1.0 + (lifeEffectivenessUpgradeLevel * 0.2); const clearRange = 75 * clearMultiplier; obstacles=obstacles.filter(o => o.x > llama.x + llama.width + clearRange || o.x + o.width < llama.x - clearRange); if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("A3", "8n"); return; } if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("G2", "4n"); gameOver(); }
    function updateScore() { if (!isGameRunning || isPaused) return; score = Math.floor(frameCount / 6); totalDistanceRun += gameSpeed * 0.1; updateMissionProgress('score', score); }
    function updateDisplays() { storeCoinBalance.textContent = coins; shieldOwnedDisplay.textContent = shieldsOwned; lifeOwnedDisplay.textContent = livesOwned; magnetOwnedDisplay.textContent = magnetsOwned; buyShieldButton.disabled = coins < shieldCost; buyLifeButton.disabled = coins < lifeCost; buyMagnetButton.disabled = coins < magnetCost; const magnetCurrentLevel = magnetDurationUpgradeLevel; const magnetNextLevelCost = calculateUpgradeCost(baseMagnetDurationCost, magnetCurrentLevel, 1.8); magnetDurationLevelDisplay.textContent = `${magnetCurrentLevel}${magnetCurrentLevel >= magnetMaxLevel ? ' (MAX)' : ''}`; magnetDurationCostDisplay.textContent = magnetCurrentLevel >= magnetMaxLevel ? '---' : magnetNextLevelCost; magnetDurationUpgradeButton.disabled = magnetCurrentLevel >= magnetMaxLevel || coins < magnetNextLevelCost; const startCoinCurrentLevel = startCoinUpgradeLevel; const startCoinNextLevelCost = calculateUpgradeCost(baseStartCoinCost, startCoinCurrentLevel, 2.0); startCoinLevelDisplay.textContent = `${startCoinCurrentLevel}${startCoinCurrentLevel >= startCoinMaxLevel ? ' (MAX)' : ''}`; startCoinCostDisplay.textContent = startCoinCurrentLevel >= startCoinMaxLevel ? '---' : startCoinNextLevelCost; startCoinUpgradeButton.disabled = startCoinCurrentLevel >= startCoinMaxLevel || coins < startCoinNextLevelCost; const lifeEffectCurrentLevel = lifeEffectivenessUpgradeLevel; const lifeEffectNextLevelCost = calculateUpgradeCost(baseLifeEffectivenessCost, lifeEffectCurrentLevel, 2.2); lifeEffectivenessLevelDisplay.textContent = `${lifeEffectCurrentLevel}${lifeEffectCurrentLevel >= lifeEffectMaxLevel ? ' (MAX)' : ''}`; lifeEffectivenessCostDisplay.textContent = lifeEffectCurrentLevel >= lifeEffectMaxLevel ? '---' : lifeEffectNextLevelCost; lifeEffectivenessUpgradeButton.disabled = lifeEffectCurrentLevel >= lifeEffectMaxLevel || coins < lifeEffectNextLevelCost; const removeAdsCost = parseInt(buyRemoveAdsButton.getAttribute('data-cost') || '1000'); if (adsRemoved) { buyRemoveAdsButton.style.display = 'none'; adsRemovedStatus.style.display = 'block'; } else { buyRemoveAdsButton.disabled = false; buyRemoveAdsButton.style.display = 'inline-block'; adsRemovedStatus.style.display = 'none'; } updatePowerupIndicators(); }
    function updatePowerupIndicators() { shieldIndicator.classList.toggle('active', isShieldActive); magnetIndicator.classList.toggle('active', isMagnetActive); lifeIndicator.classList.toggle('active', extraLives > 0); lifeIndicator.textContent = extraLives > 0 ? `‚ù§Ô∏è ${extraLives}` : '‚ù§Ô∏è'; shieldIndicator.classList.toggle('owned', shieldsOwned > 0 && !isShieldActive); magnetIndicator.classList.toggle('owned', magnetsOwned > 0 && !isMagnetActive); lifeIndicator.classList.toggle('owned', livesOwned > 0 && !(extraLives > 0)); }
    function calculateUpgradeCost(baseCost, currentLevel, multiplier) { return Math.floor(baseCost * Math.pow(multiplier, currentLevel)); }
    function updatePauseButtonVisibility() { const shouldBeVisible = isGameRunning && !isGameOver && !isPaused && !isAnyModalOpen(); pauseButton.style.display = shouldBeVisible ? 'block' : 'none'; }
    function isAnyModalOpen() { return dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex' || storeInterface.style.display === 'flex' || settingsModal.style.display === 'flex'; }
    function displayAdPlaceholder() { adDisplayPending = false; if (adsRemoved) return; console.log("Displaying ad placeholder..."); adPlaceholder.style.display = 'flex'; setTimeout(() => { adPlaceholder.style.display = 'none'; console.log("Ad placeholder hidden."); if (isGameOver && !isGameRunning) { requestAnimationFrame(gameLoop); } }, 3000); }
    function gameOver() { if(isGameOver) return; console.log("Game Over triggered"); isGameOver=true; isGameRunning=false; isPaused = false; updatePauseButtonVisibility(); isCoinRushActive = false; isInvincibleBoostActive = false; isDoubleCoinsBoostActive = false; isSpeedBoostActive = false; invincibleBoostTimer = 0; doubleCoinsBoostTimer = 0; speedBoostTimer = 0; coinRushTimer = 0; magnetTimer = 0; isMagnetActive = false; gameSpeed = baseGameSpeed; const xpEarned = Math.floor(score * xpPerScorePoint); playerXP += xpEarned; console.log(`Earned ${xpEarned} XP. Total XP: ${playerXP}`); let leveledUp = false; while (playerXP >= xpForLevelUp(playerLevel)) { const needed = xpForLevelUp(playerLevel); playerXP -= needed; playerLevel++; leveledUp = true; const levelReward = playerLevel * 25; coins += levelReward; showPopup(levelUpPopup, `Level Up! Reached Level ${playerLevel}!\n+${levelReward} Coins!`, 3000); if(!isSoundMuted && audioReady) levelUpSynth?.triggerAttackRelease("C4", "1n"); console.log(`Leveled up to ${playerLevel}! Rewarded ${levelReward} coins.`); } localStorage.setItem('llamaPlayerXP', playerXP); localStorage.setItem('llamaPlayerLevel', playerLevel); if(score > highScore) { highScore = score; localStorage.setItem('llamaHighScore', highScore); } localStorage.setItem('llamaCoins',coins); localStorage.setItem('llamaShields',shieldsOwned); localStorage.setItem('llamaLives',livesOwned); localStorage.setItem('llamaMagnets',magnetsOwned); saveAchievements(); checkAchievements(false); adDisplayPending = false; if (runCount > 0 && runCount % 5 === 0 && !adsRemoved) { console.log(`Run ${runCount}: Ad due.`); adDisplayPending = true; } else { console.log(`Run ${runCount}: No ad due or ads removed.`); } updatePowerupIndicators(); }
    function selectNewMission() { const availableMissions = missionPool; if (availableMissions.length > 0) { activeMission = availableMissions[Math.floor(Math.random() * availableMissions.length)]; missionProgress = 0; coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0; console.log("New Mission Selected:", activeMission.description); missionNotificationText = `New Mission: ${activeMission.description}`; missionNotificationTimer = missionNotificationDuration; } else { activeMission = null; console.log("No more missions available."); missionNotificationText = ""; missionNotificationTimer = 0; } }
    function showMissionCompletePopup() { showPopup(missionCompletePopup, `Mission Complete! +${activeMission.reward} Coins ü™ô`); if(!isSoundMuted && audioReady) missionSynth.triggerAttackRelease("C6", "8n"); }
    function updateMissionProgress(type, value) { if (!activeMission || activeMission.type !== type || !isGameRunning || isPaused) { return; } missionProgress = value; if (missionProgress >= activeMission.target) { console.log(`Mission Complete: ${activeMission.description}`); coins += activeMission.reward; localStorage.setItem('llamaCoins', coins); showMissionCompletePopup(); selectNewMission(); updateDisplays(); } }
    function resetGame() { console.log("Resetting game..."); score=0; obstacles=[]; coinObjects=[]; clouds=[]; mysteryBoxes = []; powerUpObjects = []; frameCount=0; lastScoreThreshold=0; isGameOver=false; isPaused = false; updatePauseButtonVisibility(); isShieldActive=false; isMagnetActive=false; magnetTimer=0; extraLives=0; isInvincibleBoostActive = false; invincibleBoostTimer = 0; isDoubleCoinsBoostActive = false; doubleCoinsBoostTimer = 0; isSpeedBoostActive = false; speedBoostTimer = 0; isCoinRushActive = false; coinRushTimer = 0; baseGameSpeed = initialGameSpeed; gameSpeed = baseGameSpeed; console.log("Speed reset to:", gameSpeed); const startingCoinBonus = startCoinUpgradeLevel * 5; if (startingCoinBonus > 0) { coins += startingCoinBonus; console.log(`Applied starting coin bonus: +${startingCoinBonus}`); } currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); if(shieldsOwned>0){isShieldActive=true;shieldsOwned--;localStorage.setItem('llamaShields',shieldsOwned);} if(livesOwned>0){extraLives=1;livesOwned--;localStorage.setItem('llamaLives',livesOwned);} if(magnetsOwned>0){isMagnetActive=true;magnetTimer=currentMagnetDuration;magnetsOwned--;localStorage.setItem('llamaMagnets',magnetsOwned);} llama.reset(); coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0; selectNewMission(); updateDisplays(); framesAfterReset = 10; console.log("Game reset complete."); }
    // --- UPDATED drawUI: Increased font size ---
    function drawUI() {
        const padding = 15;
        const baseFontSizeSmall = Math.max(8, Math.min(10, canvas.width / 40)); // Base calculation
        const fontSizeSmall = baseFontSizeSmall * 1.5; // <<< INCREASED FONT SIZE
        const uiFont = `${fontSizeSmall}px "Press Start 2P"`;

        ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
        ctx.font = uiFont;

        ctx.textAlign = 'right';
        const drawX = canvas.width - padding;
        const lineSpacing = fontSizeSmall * 1.2; // Adjust line spacing based on new font size

        ctx.fillText(`HI ${highScore}`, drawX, padding + fontSizeSmall);
        ctx.fillText(`${score}`, drawX, padding + fontSizeSmall + lineSpacing);
        ctx.fillText(`ü™ô ${coins}`, drawX, padding + fontSizeSmall + lineSpacing * 2);
        ctx.fillText(`Lv ${playerLevel}`, drawX, padding + fontSizeSmall + lineSpacing * 3);

        if (activeMission) {
            const progressText = activeMission.type === 'score' ? `${score}/${activeMission.target}` : `${missionProgress}/${activeMission.target}`;
            let missionText = `${activeMission.description} (${progressText})`;
            const maxWidth = canvas.width * 0.4;
            if (ctx.measureText(missionText).width > maxWidth) {
                missionText = activeMission.description.substring(0, 15) + `... (${progressText})`;
            }
            ctx.fillText(missionText, drawX, padding + fontSizeSmall + lineSpacing * 4);
        }

        if (missionNotificationTimer > 0 && !isPaused) {
            ctx.textAlign = 'center';
            const notificationFontSize = fontSizeSmall * 1.1; // Scale notification font too
            const notificationFont = `${notificationFontSize}px "Press Start 2P"`;
            ctx.font = notificationFont;
            const textWidth = ctx.measureText(missionNotificationText).width;
            const notificationX = canvas.width / 2;
            const notificationY = padding + notificationFontSize; // Adjust Y based on new size
            ctx.fillStyle = isNight ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.6)';
            ctx.fillRect(notificationX - textWidth / 2 - 5, notificationY - notificationFontSize, textWidth + 10, notificationFontSize * 1.5);
            ctx.fillStyle = isNight ? '#00FFFF' : '#0000FF';
            ctx.fillText(missionNotificationText, notificationX, notificationY);
            missionNotificationTimer--;
            ctx.font = uiFont; // Reset font for next elements
        }
        if (isCoinRushActive) {
            ctx.textAlign = 'center';
            ctx.font = `bold ${fontSizeSmall * 1.5}px "Press Start 2P"`;
            const rushColor = `rgba(255, ${180 + Math.sin(frameCount * 0.2) * 75}, 0, ${0.7 + Math.sin(frameCount * 0.1) * 0.3})`;
            ctx.fillStyle = rushColor;
            ctx.shadowColor = 'black'; ctx.shadowBlur = 5;
            ctx.fillText("COIN RUSH!", canvas.width / 2, canvas.height * 0.2);
            ctx.shadowBlur = 0;
            ctx.font = uiFont;
        }
        if (isDoubleCoinsBoostActive) {
            ctx.textAlign = 'center';
            ctx.font = `bold ${fontSizeSmall * 1.2}px "Press Start 2P"`;
            ctx.fillStyle = 'lime';
            ctx.shadowColor = 'black'; ctx.shadowBlur = 3;
            ctx.fillText("2x COINS!", canvas.width / 2, canvas.height * 0.25);
            ctx.shadowBlur = 0;
            ctx.font = uiFont;
        }
    }
     // --- UPDATED drawGameOverOverlay: Use canvas.width/height directly, adjust bounds calc ---
    function drawGameOverOverlay() {
        const canvasW = canvas.width; // Use physical width
        const canvasH = canvas.height; // Use physical height

        const boxWidthRatio = 0.7; const boxHeightRatio = 0.6; const maxBoxWidth = 400; const maxBoxHeight = 350;
        const boxWidth = Math.min(canvasW * boxWidthRatio, maxBoxWidth);
        const boxHeight = Math.min(canvasH * boxHeightRatio, maxBoxHeight);
        const boxX = (canvasW - boxWidth) / 2;
        const boxY = (canvasH - boxHeight) / 2;

        ctx.fillStyle = "rgba(0, 0, 0, 0.75)"; ctx.fillRect(0, 0, canvasW, canvasH);
        ctx.fillStyle = isNight ? nightUiBg : "rgba(255, 255, 255, 0.95)"; ctx.strokeStyle = isNight ? nightUiBorder : "#4a4a4a"; ctx.lineWidth = 3;
        ctx.fillRect(Math.round(boxX), Math.round(boxY), Math.round(boxWidth), Math.round(boxHeight)); ctx.strokeRect(Math.round(boxX), Math.round(boxY), Math.round(boxWidth), Math.round(boxHeight));

        const padding = boxWidth * 0.05;
        const baseFontSize = Math.max(10, Math.min(16, boxHeight / 18));
        const lineSpacing = baseFontSize * 1.7;
        ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.textAlign = "center";
        const centerX = boxX + boxWidth / 2;
        let currentY = boxY + padding + baseFontSize * 1.5;
        ctx.font = `bold ${baseFontSize * 1.3}px "Press Start 2P"`; ctx.fillText("Game Over!", centerX, Math.round(currentY));
        currentY += lineSpacing * 1.2; ctx.font = `${baseFontSize}px "Press Start 2P"`; ctx.fillText(`Score: ${score}`, centerX, Math.round(currentY));
        currentY += lineSpacing * 0.9; ctx.fillText(`Coins: ${coins} ü™ô`, centerX, Math.round(currentY));
        currentY += lineSpacing * 0.9; ctx.fillText(`Level: ${playerLevel}`, centerX, Math.round(currentY));
        currentY += lineSpacing * 1.3; ctx.font = `${baseFontSize * 0.9}px "Press Start 2P"`; ctx.fillText("Tap to Restart", centerX, Math.round(currentY));

        const buttonHeight = baseFontSize * 2.8; const buttonWidth = Math.min(boxWidth * 0.4, 150); const buttonSpacing = boxWidth * 0.05;
        const totalButtonWidth = buttonWidth * 2 + buttonSpacing; const buttonStartY = boxY + boxHeight - padding - buttonHeight; const buttonStartX = centerX - totalButtonWidth / 2;
        ctx.font = `${baseFontSize * 0.8}px "Press Start 2P"`;

        const storeButtonX = buttonStartX; const storeButtonY = buttonStartY;
        // IMPORTANT: Bounds need to be stored using the *same coordinate system* as the touch events (CSS pixels)
        const rect = canvas.getBoundingClientRect(); // Get canvas position/size in CSS pixels
        // Calculate scaling factor between canvas buffer and CSS display size
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        // Store bounds in CSS pixels by dividing physical coordinates by scale factor
        storeButtonBounds = { x: storeButtonX / scaleX, y: storeButtonY / scaleY, width: buttonWidth / scaleX, height: buttonHeight / scaleY };

        ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(Math.round(storeButtonX), Math.round(storeButtonY), Math.round(buttonWidth), Math.round(buttonHeight));
        ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(Math.round(storeButtonX), Math.round(storeButtonY), Math.round(buttonWidth), Math.round(buttonHeight));
        ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.fillText("[ Store ]", Math.round(storeButtonX + buttonWidth / 2), Math.round(storeButtonY + buttonHeight * 0.65));

        const achButtonX = buttonStartX + buttonWidth + buttonSpacing; const achButtonY = buttonStartY;
        achievementButtonBounds = { x: achButtonX / scaleX, y: achButtonY / scaleY, width: buttonWidth / scaleX, height: buttonHeight / scaleY };

        ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(Math.round(achButtonX), Math.round(achButtonY), Math.round(buttonWidth), Math.round(buttonHeight));
        ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(Math.round(achButtonX), Math.round(achButtonY), Math.round(buttonWidth), Math.round(buttonHeight));
        ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.fillText("[Achieve]", Math.round(achButtonX + buttonWidth / 2), Math.round(achButtonY + buttonHeight * 0.65));
    }
    function grantMysteryReward(box) { const rand = Math.random(); let rewardMessage = ""; if (rand < 0.4) { const coinRand = Math.random(); let amount; if (coinRand < 0.6) amount = 5; else if (coinRand < 0.9) amount = 15; else amount = 30; coins += amount; rewardMessage = `+${amount} Coins! ü™ô`; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4", "E4", "G4"], "8n"); } else if (rand < 0.75) { const boostRand = Math.random(); if (boostRand < 0.5 && !isInvincibleBoostActive) { isInvincibleBoostActive = true; invincibleBoostTimer = invincibleBoostDuration; rewardMessage = "Invincible! (5s)"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["G4", "C5", "E5"], "4n"); } else if (!isDoubleCoinsBoostActive) { isDoubleCoinsBoostActive = true; doubleCoinsBoostTimer = doubleCoinsBoostDuration; rewardMessage = "2x Coins! (10s)"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4", "G4", "C5"], "4n"); } else { coins += 3; rewardMessage = "+3 Coins! ü™ô"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4"], "8n"); } } else if (rand < 0.95) { const powerupRand = Math.random(); if (powerupRand < 0.5 && !isShieldActive && !isInvincibleBoostActive) { isShieldActive = true; updatePowerupIndicators(); rewardMessage = "Shield Activated!"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["E4", "G4", "B4"], "8n"); } else if (!isMagnetActive) { isMagnetActive = true; magnetTimer = currentMagnetDuration; updatePowerupIndicators(); rewardMessage = "Coin Magnet!"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["D4", "F#4", "A4"], "8n"); } else { coins += 10; rewardMessage = "+10 Coins! ü™ô"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["D4", "A4"], "8n"); } } else { const ownedRand = Math.random(); if (ownedRand < 0.33) { shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); rewardMessage = "+1 Shield Added!"; } else if (ownedRand < 0.66) { livesOwned++; localStorage.setItem('llamaLives', livesOwned); rewardMessage = "+1 Life Added!"; } else { magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); rewardMessage = "+1 Magnet Added!"; } if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "4n"); } if (rewardMessage) { showPopup(rewardPopup, rewardMessage); updateDisplays(); } console.log("Mystery Box Reward:", rewardMessage); }
    function checkDailyLogin() { const today = getCurrentDateString(); const lastLogin = localStorage.getItem('llamaLastLoginDate'); const consecutiveDays = parseInt(localStorage.getItem('llamaConsecutiveDays') || 0); const lastPlayDate = dailyPlayLog.length > 0 ? dailyPlayLog[dailyPlayLog.length - 1] : null; if (lastPlayDate !== today) { dailyPlayLog.push(today); try { localStorage.setItem('llamaDailyPlayLog', JSON.stringify(dailyPlayLog)); console.log(`Logged play for date: ${today}`); } catch (e) { console.error("Failed to save daily play log:", e); } } if (lastLogin === today) { return; } let currentStreak = 1; if (lastLogin) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.toISOString().split('T')[0]; if (lastLogin === yesterdayStr) { currentStreak = consecutiveDays + 1; } } localStorage.setItem('llamaLastLoginDate', today); localStorage.setItem('llamaConsecutiveDays', currentStreak); const baseReward = 10 + (currentStreak - 1) * 5; let bonusMessage = ""; let bonusCoins = 0; let bonusItem = null; const bonusRand = Math.random(); if (currentStreak >= 5 && bonusRand < 0.15) { const itemRand = Math.random(); if (itemRand < 0.33) { bonusItem = 'Shield'; shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); } else if (itemRand < 0.66) { bonusItem = 'Life'; livesOwned++; localStorage.setItem('llamaLives', livesOwned); } else { bonusItem = 'Magnet'; magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); } bonusMessage = `+ Bonus ${bonusItem}!`; } else if (bonusRand < 0.3) { bonusCoins = 5 + Math.floor(Math.random() * (currentStreak * 2)); bonusMessage = `+ Bonus ${bonusCoins} Coins!`; } const totalReward = baseReward + bonusCoins; coins += totalReward; localStorage.setItem('llamaCoins', coins); dailyLoginTitle.textContent = `Day ${currentStreak} Login Bonus!`; dailyLoginMessage.innerHTML = `You received ${baseReward} Coins! ü™ô<br>${bonusMessage || '(No extra bonus today)'}`; dailyBonusBreakdownList.innerHTML = ''; for (let i = 1; i <= 10; i++) { const dayReward = 10 + (i - 1) * 5; const li = document.createElement('li'); li.textContent = `Day ${i}: ${dayReward} ü™ô`; if (i === currentStreak) { li.classList.add('current-day'); li.textContent += " (Today!)"; } else if (i < currentStreak) { li.style.opacity = '0.6'; } dailyBonusBreakdownList.appendChild(li); } dailyLoginModal.style.display = 'flex'; if(!isSoundMuted && audioReady) dailyBonusSynth?.triggerAttackRelease("A4", "2n"); updateDisplays(); }
    // --- UPDATED gameLoop: Use canvas.width/height directly ---
    function gameLoop() {
        if (isPaused) { return; }
        if (adDisplayPending) { displayAdPlaceholder(); return; }
        if (isGameOver) {
            ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawGround(); clouds.forEach(c => c.draw()); drawStars(); llama.draw();
            drawGameOverOverlay();
            return; // Stop loop, bounds set in drawGameOverOverlay
        }
        isGameRunning = true; updatePauseButtonVisibility();
        if (framesAfterReset > 0) { framesAfterReset--; }
        const scoreCycle = Math.floor(score / dayNightCycleThreshold); const shouldBeNight = scoreCycle % 2 !== 0;
        if (shouldBeNight !== isNight) { isNight = shouldBeNight; setBackground(isNight); if (isGameRunning && isNight) { totalNightsSurvived++; checkAchievements(); } }
        if (!isCoinRushActive && score >= coinRushMinScore && Math.random() < coinRushChance && framesAfterReset <= 0) { isCoinRushActive = true; coinRushTimer = coinRushDuration; if(!isSoundMuted && audioReady) coinRushSynth?.triggerAttackRelease("4n"); console.log("COIN RUSH STARTED!"); }
        if (isCoinRushActive) { coinRushTimer--; if (coinRushTimer <= 0) { isCoinRushActive = false; gameSpeed = baseGameSpeed; console.log("COIN RUSH ENDED"); } }
        if (isInvincibleBoostActive) { invincibleBoostTimer--; if (invincibleBoostTimer <= 0) isInvincibleBoostActive = false; }
        if (isDoubleCoinsBoostActive) { doubleCoinsBoostTimer--; if (doubleCoinsBoostTimer <= 0) isDoubleCoinsBoostActive = false; }
        if (isMagnetActive) { magnetTimer--; if (magnetTimer <= 0) { isMagnetActive = false; updatePowerupIndicators(); } }
        ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
        spawnCloud(); updateClouds(); drawStars(); drawGround();
        llama.update(); llama.draw();
        if (framesAfterReset <= 0) { spawnObstacle(); spawnCoin(); spawnMysteryBox(); spawnPowerUp(); }
        updateObstacles(); updateCoins(); updateMysteryBoxes(); updatePowerUps();
        updateScore();
        const currentScoreThreshold = Math.floor(score / speedIncreaseInterval);
        if (currentScoreThreshold > lastScoreThreshold && !isCoinRushActive) { gameSpeed += speedIncrement; baseGameSpeed += speedIncrement; lastScoreThreshold = currentScoreThreshold; console.log(`Score ${lastScoreThreshold * speedIncreaseInterval}, Speed: ${gameSpeed.toFixed(2)}`); }
        drawUI();
        frameCount++;
        animationFrameId = requestAnimationFrame(gameLoop);
    }
    function initiateGameStart() { storeButtonBounds = null; achievementButtonBounds = null; if (isAnyModalOpen()) return; if (!isGameOver || isGameRunning) { console.log("Not starting: game over=", isGameOver, " running=", isGameRunning); return; } console.log("Initiating game start..."); runCount++; localStorage.setItem('llamaRunCount', runCount); console.log(`Starting Run #${runCount}`); resetGame(); isGameOver = false; isGameRunning = true; updatePauseButtonVisibility(); if (animationFrameId) { cancelAnimationFrame(animationFrameId); } animationFrameId = requestAnimationFrame(gameLoop); }
    function updatePauseButtonVisibility() { const shouldBeVisible = isGameRunning && !isGameOver && !isPaused && !isAnyModalOpen(); pauseButton.style.display = shouldBeVisible ? 'block' : 'none'; }
    function isAnyModalOpen() { return dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex' || storeInterface.style.display === 'flex' || settingsModal.style.display === 'flex'; }
    document.addEventListener('keydown', (e) => { if (isPaused || isAnyModalOpen()) return; if(isGameOver){if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); handleGameStartInteraction(); } return; } if(isGameRunning){ if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); llama.jump(); } else if(e.code === 'ArrowDown'){ e.preventDefault(); if (!llama.isDucking){ llama.duck(true); } } } });
    document.addEventListener('keyup', (e) => { if (isPaused || isAnyModalOpen()) return; if(isGameRunning && e.code === 'ArrowDown'){ e.preventDefault(); llama.duck(false); } });
    function playUIClick(){ if(!isSoundMuted && audioReady) uiClickSynth?.triggerAttackRelease("A5", "16n"); }
    buyShieldButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= shieldCost) { coins -= shieldCost; shieldsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaShields', shieldsOwned); updateDisplays(); } });
    buyLifeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= lifeCost) { coins -= lifeCost; livesOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLives', livesOwned); updateDisplays(); } });
    buyMagnetButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= magnetCost) { coins -= magnetCost; magnetsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnets', magnetsOwned); updateDisplays(); } });
    closeStoreButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); storeInterface.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    magnetDurationUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseMagnetDurationCost, magnetDurationUpgradeLevel, 1.8); if (coins >= cost && magnetDurationUpgradeLevel < magnetMaxLevel) { coins -= cost; magnetDurationUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnetUpgrade', magnetDurationUpgradeLevel); updateDisplays(); currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); } });
    startCoinUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseStartCoinCost, startCoinUpgradeLevel, 2.0); if (coins >= cost && startCoinUpgradeLevel < startCoinMaxLevel) { coins -= cost; startCoinUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaStartCoinUpgrade', startCoinUpgradeLevel); updateDisplays(); } });
    lifeEffectivenessUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseLifeEffectivenessCost, lifeEffectivenessUpgradeLevel, 2.2); if (coins >= cost && lifeEffectivenessUpgradeLevel < lifeEffectMaxLevel) { coins -= cost; lifeEffectivenessUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLifeEffectUpgrade', lifeEffectivenessUpgradeLevel); updateDisplays(); } });
    buyRemoveAdsButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (!adsRemoved) { if (confirm("Confirm purchase to remove ads for $5.00?\n(This is a simulation - no real money will be charged)")) { adsRemoved = true; localStorage.setItem('llamaAdsRemoved', 'true'); console.log("Ads Removed (Simulated Purchase Confirmed)!"); updateDisplays(); alert("Ad removal purchased (Simulation Complete)!"); } else { console.log("Simulated purchase cancelled."); } } });
    dailyLoginCloseButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); dailyLoginModal.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    achievementCloseButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); achievementModal.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    pauseButton.addEventListener('click', (e) => { e.stopPropagation(); if (!isGameRunning || isGameOver || isPaused || isAnyModalOpen()) return; playUIClick(); isPaused = true; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } settingsModal.style.display = 'flex'; updatePauseButtonVisibility(); console.log("Game Paused"); });
    resumeButton.addEventListener('click', (e) => { e.stopPropagation(); if (!isPaused) return; playUIClick(); isPaused = false; settingsModal.style.display = 'none'; updatePauseButtonVisibility(); if (!animationFrameId && isGameRunning && !isGameOver) { animationFrameId = requestAnimationFrame(gameLoop); } console.log("Game Resumed"); });
    toggleSoundButton.addEventListener('click', (e) => { e.stopPropagation(); isSoundMuted = !isSoundMuted; if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; } localStorage.setItem('llamaSoundMuted', isSoundMuted); toggleSoundButton.textContent = `Sound: ${isSoundMuted ? 'OFF' : 'ON'}`; playUIClick(); console.log(`Sound Muted: ${isSoundMuted}`); });
    function handleGameStartInteraction() { if (isAnyModalOpen()) return; if (!isGameOver || isGameRunning) { console.log("Interaction ignored: game not ready."); return; } console.log("Handle Interaction - Game Over: ", isGameOver, " Running: ", isGameRunning); if (!audioReady) { try { console.log("Attempting Tone.start()..."); Tone.start().then(() => { console.log("Audio context started successfully."); setupAudio(); initiateGameStart(); }).catch(e => { console.error("Tone.start() failed:", e); initiateGameStart(); }); } catch (e) { console.error("Error calling Tone.start():", e); initiateGameStart(); } } else { console.log("Audio ready, starting game directly."); initiateGameStart(); } }
    gameContainer.addEventListener('touchstart', (e) => { if (isPaused || isAnyModalOpen()) return; const touch = e.changedTouches[0]; const rect = canvas.getBoundingClientRect(); if (isGameOver) { e.preventDefault(); const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top;
        console.log(`GameOver Tap: touchX=${touchX.toFixed(2)}, touchY=${touchY.toFixed(2)}`);
        console.log('Store Bounds:', storeButtonBounds);
        console.log('Achieve Bounds:', achievementButtonBounds);
        if (storeButtonBounds && touchX >= storeButtonBounds.x && touchX <= storeButtonBounds.x + storeButtonBounds.width && touchY >= storeButtonBounds.y && touchY <= storeButtonBounds.y + storeButtonBounds.height) {
            console.log(">>> Store button condition MET");
            playUIClick(); storeInterface.style.display = 'flex'; updateDisplays(); updatePauseButtonVisibility();
        } else if (achievementButtonBounds && touchX >= achievementButtonBounds.x && touchX <= achievementButtonBounds.x + achievementButtonBounds.width && touchY >= achievementButtonBounds.y && touchY <= achievementButtonBounds.y + achievementButtonBounds.height) {
            console.log(">>> Achievement button condition MET");
            playUIClick(); populateAchievementModal(); achievementModal.style.display = 'flex'; updatePauseButtonVisibility();
        } else {
            console.log(">>> Neither button condition met, handling restart.");
            handleGameStartInteraction();
        } return; } if (isGameRunning) { touchStartX = touch.screenX; touchStartY = touch.screenY; touchStartTime = Date.now(); isSwiping = false; } }, {passive: false});
    gameContainer.addEventListener('touchmove', (e) => { if (isPaused || isAnyModalOpen()) return; if (!isGameRunning || touchStartY === 0) return; const touch = e.changedTouches[0]; const currentX = touch.screenX; const currentY = touch.screenY; let distY = currentY - touchStartY; let distX = currentX - touchStartX; if (!isSwiping && (Math.abs(distY) > 10 || Math.abs(distX) > 10)) { if (Math.abs(distY) > Math.abs(distX)) { e.preventDefault(); } isSwiping = true; } if (isSwiping && distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { if (!llama.isDucking) { llama.duck(true); } } }, {passive: false});
    gameContainer.addEventListener('touchend', (e) => { if (isPaused || isAnyModalOpen()) return; if (!isGameRunning || touchStartY === 0) { touchStartY = 0; isSwiping = false; return; } const touchEndTime = Date.now(); const touchDuration = touchEndTime - touchStartTime; const touchEndY = e.changedTouches[0].screenY; const touchEndX = e.changedTouches[0].screenX; let distY = touchEndY - touchStartY; let distX = touchEndX - touchStartX; if (touchDuration < maxTapTime && Math.abs(distX) < 20 && Math.abs(distY) < 20 && !isSwiping) { console.log("Tap -> Jump"); llama.jump(); } else if (distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Down End -> Duck End"); llama.duck(false); } else if (distY < -minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Up -> Jump"); llama.jump(); } else { if (llama.isDucking){ llama.duck(false); } } touchStartX = 0; touchStartY = 0; touchStartTime = 0; isSwiping = false; });
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', () => { console.log("Orientation changed, resizing canvas..."); setTimeout(resizeCanvas, 100); });
    window.onload = () => { console.log("Window loaded. Initializing game display."); loadGameSettings(); loadAchievements(); resizeCanvas(); isGameOver = true; isGameRunning = false; updatePauseButtonVisibility(); checkDailyLogin(); updateDisplays(); currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); if (dailyLoginModal.style.display !== 'flex') { requestAnimationFrame(gameLoop); } console.log("Game initialized. Waiting for user interaction or modal close."); };
    function loadGameSettings() { magnetDurationUpgradeLevel = parseInt(localStorage.getItem('llamaMagnetUpgrade') || 0); startCoinUpgradeLevel = parseInt(localStorage.getItem('llamaStartCoinUpgrade') || 0); lifeEffectivenessUpgradeLevel = parseInt(localStorage.getItem('llamaLifeEffectUpgrade') || 0); coins = parseInt(localStorage.getItem('llamaCoins') || 0); playerXP = parseInt(localStorage.getItem('llamaPlayerXP') || 0); playerLevel = parseInt(localStorage.getItem('llamaPlayerLevel') || 1); highScore = parseInt(localStorage.getItem('llamaHighScore') || 0); shieldsOwned = parseInt(localStorage.getItem('llamaShields') || 0); livesOwned = parseInt(localStorage.getItem('llamaLives') || 0); magnetsOwned = parseInt(localStorage.getItem('llamaMagnets') || 0); runCount = parseInt(localStorage.getItem('llamaRunCount') || 0); adsRemoved = localStorage.getItem('llamaAdsRemoved') === 'true'; isSoundMuted = localStorage.getItem('llamaSoundMuted') === 'true'; toggleSoundButton.textContent = `Sound: ${isSoundMuted ? 'OFF' : 'ON'}`; if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; } try { dailyPlayLog = JSON.parse(localStorage.getItem('llamaDailyPlayLog') || '[]'); if (!Array.isArray(dailyPlayLog)) dailyPlayLog = []; } catch(e) { console.error("Failed to load daily play log:", e); dailyPlayLog = []; } console.log("Game settings loaded."); }
  </script>
</body>
</html>
