<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#87CEEB">
    <title>Llama Time!</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/llama-icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Llama Time">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Basic Reset & Body Styles */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { display: flex; flex-direction: column; align-items: center; min-height: 100vh; background-color: #f0f0f0; font-family: 'Press Start 2P', cursive; color: #333; padding: 0; transition: background-color 0.5s ease; }

        /* Game Container & Canvas */
        #game-container { position: relative; width: 100vw; height: 100vh; max-width: none; border: none; border-radius: 0; overflow: hidden; cursor: pointer; background-color: #87CEEB; transition: background-color 0.5s ease; flex-shrink: 0; margin: 0; }
        canvas { display: block; width: 100%; height: 100%; background-color: transparent; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }

        /* Popups & Indicators */
        #mission-complete-popup, #reward-popup, #level-up-popup, #achievement-popup { /* Combined styles */
            position: absolute; top: 15px; right: 15px;
            background-color: rgba(76, 175, 80, 0.9); color: white;
            padding: 8px 15px; border-radius: 10px; font-size: 0.8em; z-index: 30;
            display: none; opacity: 0; transition: opacity 0.5s ease-out;
            font-family: 'Press Start 2P', cursive; text-align: center;
            max-width: 80%; /* Prevent very wide popups */
        }
        #reward-popup { background-color: rgba(255, 215, 0, 0.9); color: #333; } /* Gold for rewards */
        #level-up-popup { background-color: rgba(0, 191, 255, 0.9); color: white; } /* Deep sky blue for level up */
        #achievement-popup { background-color: rgba(128, 0, 128, 0.9); color: white; } /* Purple for achievements */


        /* Store Interface */
        #store-interface { /* ... existing styles ... */ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; align-items: center; justify-content: flex-start; /* Align top */ z-index: 20; color: white; padding: 15px 10px; text-align: center; overflow-y: auto; }
        #store-interface h2 { margin-top: 10px; margin-bottom: 10px; font-size: 1.5em; flex-shrink: 0; }
        #store-interface > p { margin-bottom: 10px; font-size: 1em; flex-shrink: 0; }
        .store-section { width: 100%; margin-bottom: 15px; border-bottom: 1px solid #666; padding-bottom: 10px; }
        .store-section h3 { font-size: 1.2em; margin-bottom: 10px; color: gold; }
        .store-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 10px; width: 90%; max-width: 350px; border: 2px solid #fff; flex-shrink: 0; }
        .store-item h4 { font-size: 1.0em; margin-bottom: 5px; } /* Changed from h3 */
        .store-item p { margin-bottom: 8px; font-size: 0.8em; }
        .store-item .upgrade-level { font-size: 0.7em; color: #ccc; margin-bottom: 5px; }
        .store-item button { font-family: 'Press Start 2P', cursive; font-size: 0.8em; padding: 8px 15px; margin-top: 5px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer;}
        .store-item button:disabled { opacity: 0.5; cursor: not-allowed; }
        #close-store { margin-top: 20px; margin-bottom: 30px; padding: 10px 20px; font-size: 1em; flex-shrink: 0; font-family: 'Press Start 2P', cursive; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; }

        /* Powerup Indicators */
        #powerup-indicators { /* ... existing styles ... */ position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; gap: 8px; }
        .indicator { /* ... existing styles ... */ font-size: 1.8em; opacity: 0.35; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: opacity 0.3s ease, filter 0.3s ease; filter: grayscale(50%); }
        .indicator.owned { /* ... existing styles ... */ opacity: 0.7; filter: grayscale(0%); }
        .indicator.active { /* ... existing styles ... */ opacity: 1; filter: grayscale(0%); animation: pulse 0.8s infinite; }
        #magnet-indicator.active { /* ... existing styles ... */ animation: pulse-magnet 0.6s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes pulse-magnet { 0% { transform: scale(1); text-shadow: 0 0 5px gold; } 50% { transform: scale(1.2); text-shadow: 0 0 15px gold; } 100% { transform: scale(1); text-shadow: 0 0 5px gold; } }

        /* Modal Styles (Shared Base) */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; color: white;
            padding: 20px; text-align: center;
        }
        .modal-content {
            background-color: #333; padding: 20px 30px; border-radius: 15px;
            border: 3px solid #ccc; max-width: 90%; width: 450px; /* Slightly wider */
            max-height: 80vh; /* Max height */
            overflow-y: auto; /* Scroll if needed */
        }
        .modal-content h2 { font-size: 1.4em; margin-bottom: 15px; color: gold; }
        .modal-content p { font-size: 1em; margin-bottom: 20px; line-height: 1.5; }
        .modal-close-button { font-family: 'Press Start 2P', cursive; font-size: 1em; padding: 10px 20px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; margin-top: 15px; }

        /* Daily Login Modal Specifics */
        #daily-login-modal .modal-content { border-color: gold; }

        /* Achievement Modal Specifics */
        #achievement-modal .modal-content { border-color: purple; }
        #achievement-list { list-style: none; padding: 0; margin: 0; }
        .achievement-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #666; text-align: left; }
        .achievement-item.unlocked { border-color: gold; background-color: #5a5a4a; }
        .achievement-item h4 { font-size: 0.9em; margin-bottom: 5px; color: white; }
        .achievement-item p { font-size: 0.75em; margin-bottom: 5px; color: #ccc; }
        .achievement-item .status { font-size: 0.7em; font-weight: bold; float: right; }
        .achievement-item.unlocked .status { color: gold; }
        .achievement-item.locked .status { color: #888; }


         /* Responsive Adjustments */
         @media (max-height: 450px) {
             #mission-complete-popup, #reward-popup, #level-up-popup, #achievement-popup { font-size: 0.6em; padding: 4px 8px; top: 5px; right: 5px; }
             .indicator { font-size: 1.2em; }
             .modal-content { padding: 15px; width: 95%; }
             .modal-content h2 { font-size: 1.1em; }
             .modal-content p { font-size: 0.8em; }
             .modal-close-button { font-size: 0.8em; padding: 8px 15px; }
             .achievement-item h4 { font-size: 0.8em; }
             .achievement-item p { font-size: 0.7em; }
        }
         @media (max-width: 480px) {
             .indicator { font-size: 1.2em; }
             .modal-content { width: 95%; }
             .modal-content h2 { font-size: 1.2em; }
             .modal-content p { font-size: 0.9em; }
             .modal-close-button { font-size: 0.9em; }
             .achievement-item h4 { font-size: 0.8em; }
             .achievement-item p { font-size: 0.7em; }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="powerup-indicators">
            <span id="shield-indicator" class="indicator">üõ°Ô∏è</span>
            <span id="magnet-indicator" class="indicator">üß≤</span>
            <span id="life-indicator" class="indicator">‚ù§Ô∏è</span>
        </div>
        <div id="mission-complete-popup">Mission Complete!</div>
        <div id="reward-popup">Reward!</div>
        <div id="level-up-popup">Level Up!</div>
        <div id="achievement-popup">Achievement Unlocked!</div>
        <div id="store-interface">
            <h2>Power-up Store</h2>
            <p>Your Coins: <span id="store-coin-balance">0</span> ü™ô</p>

            <div class="store-section">
                <h3>Single Use Power-ups</h3>
                <div class="store-item">
                    <h4>Shield (üõ°Ô∏è) - Cost: <span class="cost" data-item="shield">50</span> ü™ô</h4>
                    <p>Activates automatically next run!</p>
                    <button id="buy-shield">Buy Shield</button>
                    <p>Owned: <span id="shield-owned">0</span></p>
                </div>
                <div class="store-item">
                    <h4>Extra Life (‚ù§Ô∏è) - Cost: <span class="cost" data-item="life">100</span> ü™ô</h4>
                    <p>Activates automatically next run!</p>
                    <button id="buy-life">Buy Extra Life</button>
                    <p>Owned: <span id="life-owned">0</span></p>
                </div>
                <div class="store-item">
                    <h4>Coin Magnet (üß≤) - Cost: <span class="cost" data-item="magnet">75</span> ü™ô</h4>
                    <p>Activates automatically next run!</p>
                    <button id="buy-magnet">Buy Coin Magnet</button>
                    <p>Owned: <span id="magnet-owned">0</span></p>
                </div>
            </div>

            <div class="store-section">
                <h3>Permanent Upgrades</h3>
                <div class="store-item">
                    <h4>Magnet Duration</h4>
                    <p>Increase Coin Magnet active time.</p>
                    <p class="upgrade-level">Level: <span id="magnet-duration-level">0</span></p>
                    <button id="upgrade-magnet-duration">Upgrade (Cost: <span id="magnet-duration-cost">0</span> ü™ô)</button>
                </div>
                 <div class="store-item">
                    <h4>Starting Coins</h4>
                    <p>Begin each run with extra coins.</p>
                    <p class="upgrade-level">Level: <span id="start-coin-level">0</span></p>
                    <button id="upgrade-start-coin">Upgrade (Cost: <span id="start-coin-cost">0</span> ü™ô)</button>
                </div>
                <div class="store-item">
                    <h4>Life Effectiveness</h4>
                    <p>Clear more obstacles when using an Extra Life.</p>
                    <p class="upgrade-level">Level: <span id="life-effectiveness-level">0</span></p>
                    <button id="upgrade-life-effectiveness">Upgrade (Cost: <span id="life-effectiveness-cost">0</span> ü™ô)</button>
                </div>
            </div>

            <button id="close-store">Close Store</button>
        </div>
    </div>

    <div id="daily-login-modal" class="modal">
        <div class="modal-content">
            <h2 id="daily-login-title">Welcome Back!</h2>
            <p id="daily-login-message">Here's your daily reward!</p>
            <button id="daily-login-close" class="modal-close-button">Claim & Close</button>
        </div>
    </div>

    <div id="achievement-modal" class="modal">
        <div class="modal-content">
            <h2>Achievements</h2>
            <ul id="achievement-list">
                </ul>
            <button id="achievement-close" class="modal-close-button">Close</button>
        </div>
    </div>


    <script> /* ... service worker script ... */ if ('serviceWorker' in navigator) { window.addEventListener('load', () => { navigator.serviceWorker.register('sw.js').then(registration => { console.log('SW registered: ', registration); }).catch(registrationError => { console.log('SW registration failed: ', registrationError); }); }); } </script>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
        const storeInterface = document.getElementById('store-interface'); const storeCoinBalance = document.getElementById('store-coin-balance');
        const buyShieldButton = document.getElementById('buy-shield'); const buyLifeButton = document.getElementById('buy-life'); const buyMagnetButton = document.getElementById('buy-magnet');
        const shieldOwnedDisplay = document.getElementById('shield-owned'); const lifeOwnedDisplay = document.getElementById('life-owned'); const magnetOwnedDisplay = document.getElementById('magnet-owned');
        const closeStoreButton = document.getElementById('close-store');
        const shieldIndicator = document.getElementById('shield-indicator'); const magnetIndicator = document.getElementById('magnet-indicator'); const lifeIndicator = document.getElementById('life-indicator');
        const gameContainer = document.getElementById('game-container');
        const missionCompletePopup = document.getElementById('mission-complete-popup'); const rewardPopup = document.getElementById('reward-popup');
        const levelUpPopup = document.getElementById('level-up-popup'); const achievementPopup = document.getElementById('achievement-popup'); // <<< NEW Achievement Popup
        const dailyLoginModal = document.getElementById('daily-login-modal'); const dailyLoginTitle = document.getElementById('daily-login-title'); const dailyLoginMessage = document.getElementById('daily-login-message'); const dailyLoginCloseButton = document.getElementById('daily-login-close');
        // --- NEW Store Upgrade Elements ---
        const magnetDurationLevelDisplay = document.getElementById('magnet-duration-level'); const magnetDurationCostDisplay = document.getElementById('magnet-duration-cost'); const magnetDurationUpgradeButton = document.getElementById('upgrade-magnet-duration');
        const startCoinLevelDisplay = document.getElementById('start-coin-level'); const startCoinCostDisplay = document.getElementById('start-coin-cost'); const startCoinUpgradeButton = document.getElementById('upgrade-start-coin');
        const lifeEffectivenessLevelDisplay = document.getElementById('life-effectiveness-level'); const lifeEffectivenessCostDisplay = document.getElementById('life-effectiveness-cost'); const lifeEffectivenessUpgradeButton = document.getElementById('upgrade-life-effectiveness');
        // --- NEW Achievement Modal Elements ---
        const achievementModal = document.getElementById('achievement-modal'); const achievementList = document.getElementById('achievement-list'); const achievementCloseButton = document.getElementById('achievement-close');


        // --- Game Variables ---
        let score = 0; let highScore = parseInt(localStorage.getItem('llamaHighScore') || 0);
        let coins = parseInt(localStorage.getItem('llamaCoins') || 0);
        let shieldsOwned = parseInt(localStorage.getItem('llamaShields') || 0); let livesOwned = parseInt(localStorage.getItem('llamaLives') || 0); let magnetsOwned = parseInt(localStorage.getItem('llamaMagnets') || 0);
        const initialGameSpeed = 2.5; let gameSpeed = initialGameSpeed; let baseGameSpeed = initialGameSpeed; const speedIncrement = 0.3; let lastScoreThreshold = 0;
        let gravity = 0.35; const fastFallMultiplier = 3.5;
        let isGameOver = true; let isGameRunning = false; let animationFrameId;
        let obstacles = []; let coinObjects = []; let clouds = []; let mysteryBoxes = [];
        let frameCount = 0;
        let isShieldActive = false; let isMagnetActive = false; let magnetTimer = 0;
        let baseMagnetDuration = 600; // Base duration (10s) - Will be modified by upgrades
        let currentMagnetDuration = baseMagnetDuration; // Actual duration used
        let extraLives = 0;
        let isInvincibleBoostActive = false; let invincibleBoostTimer = 0; const invincibleBoostDuration = 300;
        let isDoubleCoinsBoostActive = false; let doubleCoinsBoostTimer = 0; const doubleCoinsBoostDuration = 600;
        let isSpeedBoostActive = false; let speedBoostTimer = 0; const speedBoostAmount = 1.5;
        let isCoinRushActive = false; let coinRushTimer = 0; const coinRushDuration = 600; const coinRushChance = 0.0005; const coinRushMinScore = 500;
        let framesAfterReset = 0; let isLoopRunning = false;
        let isNight = false; const dayBgColor = '#87CEEB'; const nightBgColor = '#2c3e50'; const dayGroundColor = '#D2B48C'; const nightGroundColor = '#B08D57'; const dayTextColor = '#333'; const nightTextColor = '#ecf0f1'; const dayBodyBgColor = '#f0f0f0'; const nightBodyBgColor = '#34495e'; const nightUiBg = '#4a5a6a'; const nightUiBorder = '#7f8c8d'; let currentBgColor = dayBgColor;
        const missionPool = [ /* ... mission data ... */ { id: 'score100', description: 'Reach Score 100', target: 100, reward: 15, type: 'score' }, { id: 'collect5', description: 'Collect 5 coins', target: 5, reward: 15, type: 'coins' }, { id: 'score300', description: 'Reach Score 300', target: 300, reward: 30, type: 'score' }, { id: 'jump5cacti', description: 'Jump over 5 cacti', target: 5, reward: 35, type: 'jump_cactus' }, { id: 'collect15', description: 'Collect 15 coins', target: 15, reward: 40, type: 'coins' }, { id: 'score750', description: 'Reach Score 750', target: 750, reward: 75, type: 'score' }, { id: 'duck3birds', description: 'Duck under 3 birds', target: 3, reward: 45, type: 'duck_bird' }, { id: 'collect30', description: 'Collect 30 coins', target: 30, reward: 80, type: 'coins' }, ];
        let activeMission = null; let missionProgress = 0; let coinsCollectedThisRun = 0; let cactiJumpedThisRun = 0; let birdsDuckedThisRun = 0;
        let missionNotificationText = ""; let missionNotificationTimer = 0; const missionNotificationDuration = 180;
        const shieldCost = 50; const lifeCost = 100; const magnetCost = 75;

        // --- NEW: Player Level Variables ---
        let playerXP = parseInt(localStorage.getItem('llamaPlayerXP') || 0);
        let playerLevel = parseInt(localStorage.getItem('llamaPlayerLevel') || 1); // Start at level 1
        const xpPerScorePoint = 0.1; // XP gained per score point
        function xpForLevelUp(level) { return Math.floor(100 * Math.pow(level, 1.5)); } // XP needed for next level

        // --- NEW: Permanent Upgrade Levels ---
        let magnetDurationUpgradeLevel = parseInt(localStorage.getItem('llamaMagnetUpgrade') || 0);
        let startCoinUpgradeLevel = parseInt(localStorage.getItem('llamaStartCoinUpgrade') || 0);
        let lifeEffectivenessUpgradeLevel = parseInt(localStorage.getItem('llamaLifeEffectUpgrade') || 0);
        // Add more upgrade level variables here

        // --- NEW: Achievement Tracking ---
        let totalDistanceRun = parseInt(localStorage.getItem('llamaTotalDistance') || 0); // Example stat
        let totalCoinsCollected = parseInt(localStorage.getItem('llamaTotalCoinsCollected') || coins); // Initialize with current coins if first time
        let totalCactiJumped = parseInt(localStorage.getItem('llamaTotalCactiJumped') || 0);
        let totalBirdsDucked = parseInt(localStorage.getItem('llamaTotalBirdsDucked') || 0); // Added for potential achievement
        let totalShieldsUsed = parseInt(localStorage.getItem('llamaTotalShieldsUsed') || 0);
        let totalNightsSurvived = parseInt(localStorage.getItem('llamaTotalNightsSurvived') || 0); // Added for potential achievement


        // --- Audio Synths ---
        let jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth;
        let levelUpSynth, achievementSynth; // <<< NEW Synths
        let audioReady = false;

        // --- Audio Setup ---
        function setupAudio() { /* ... existing setup + new synths ... */
             if (audioReady) return; try { [jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth, levelUpSynth, achievementSynth].forEach(synth => { if (synth && typeof synth.dispose === 'function') { synth.dispose(); } });
                jumpSynth = new Tone.Synth({ oscillator: { type: "square" }, volume: -8, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination();
                coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination();
                hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 3, volume: -6, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.4, attackCurve: "exponential" } }).toDestination();
                uiClickSynth = new Tone.Synth({ volume: -15, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 } }).toDestination();
                missionSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination();
                mysteryAppearSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.6 }, volume: -12, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination();
                mysteryCollectSynth = new Tone.Synth({ oscillator: { type: "fmtriangle", modulationType: "sine", harmonicity: 1.5 }, volume: -9, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination();
                rewardSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, volume: -7, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination();
                dailyBonusSynth = new Tone.Synth({ oscillator: { type: "fatsawtooth", count: 3, spread: 20 }, volume: -6, envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.4 } }).toDestination();
                coinRushSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, volume: -10, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination();
                // --- NEW Synths ---
                levelUpSynth = new Tone.Synth({ oscillator: { type: "fatsquare", count: 4, spread: 30 }, volume: -5, envelope: { attack: 0.05, decay: 0.5, sustain: 0.3, release: 0.6 } }).toDestination();
                achievementSynth = new Tone.Synth({ oscillator: { type: "pwm", modulationFrequency: 0.5 }, volume: -7, envelope: { attack: 0.02, decay: 0.6, sustain: 0.2, release: 0.5 } }).toDestination();

                audioReady = true; console.log("Audio ready."); } catch (err) { console.error("Error setting up audio:", err); audioReady = false; }
        }

        // --- Touch Swipe Variables --- (Remain the same)
        let touchStartX = 0; let touchStartY = 0; let touchStartTime = 0; let isSwiping = false;
        const minSwipeYDistance = 50; const maxSwipeXDistance = 50; const maxTapTime = 250;

        // --- Game Over Screen Variables ---
        let storeButtonBounds = null;
        let achievementButtonBounds = null; // <<< NEW Achievement Button Bounds

        // --- Game Objects ---
        const groundHeight = 50;
        const llama = { /* ... llama object ... */ x: 50, y: 0, drawWidth: 56, drawHeight: 56, width: 50, height: 52, dy: 0, jumpPower: -11, isJumping: false, isDucking: false, duckHeight: 30, baseY: 0, runFrame: 0, runAnimationSpeed: 6, draw() { /* ... llama draw logic ... */ const bodyHigh='#F5E5D0', bodyLight='#EAD8BF', bodyMain='#D8B898', bodyShade='#B89878'; const legMain='#A08060', legShade='#806040', hoof='#604030'; const faceMain='#F0D0B0', earInner='#E0C0A0', eyeWhite='#FFFFFF', eyePupil='#000000', nose='#705040', hair='#907050'; const p = 2; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); let scaleY=1; let duckOffsetY=0; if(this.isDucking){ scaleY=0.75; duckOffsetY = this.drawHeight * (1 - scaleY); ctx.translate(0,duckOffsetY); ctx.scale(1,scaleY); } ctx.fillStyle=bodyMain; ctx.fillRect(p*4, p*4, p*18, p*14); ctx.fillStyle=bodyShade; ctx.fillRect(p*5, p*15, p*16, p*3); ctx.fillStyle=bodyLight; ctx.fillRect(p*5, p*4, p*16, p*3); ctx.fillStyle=bodyLight; ctx.fillRect(p*4, p*6, p*2, p*10); ctx.fillRect(p*3, p*8, p*1, p*6); ctx.fillStyle=bodyMain; ctx.fillRect(p*2, p*7, p*2, p*8); ctx.fillStyle=hair; ctx.fillRect(p*0, p*10, p*4, p*4); ctx.fillRect(p*-1, p*11, p*2, p*2); ctx.fillStyle=bodyMain; ctx.fillRect(p*16, p*-1, p*6, p*8); ctx.fillStyle=bodyShade; ctx.fillRect(p*16, p*5, p*5, p*2); ctx.fillStyle=hair; ctx.fillRect(p*15, p*-4, p*7, p*5); ctx.fillRect(p*17, p*-6, p*3, p*2); ctx.fillRect(p*14, p*-1, p*3, p*3); ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-9, p*9, p*10); ctx.fillStyle=faceMain; ctx.fillRect(p*26, p*-6, p*4, p*6); ctx.fillStyle=nose; ctx.fillRect(p*28, p*-3, p*2, p*1); ctx.fillRect(p*27, p*0, p*3, p*1); ctx.fillStyle=eyeWhite; ctx.fillRect(p*23, p*-5, p*2, p*2); ctx.fillStyle=eyePupil; ctx.fillRect(p*24, p*-4, p*1, p*1); ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-13, p*3, p*5); ctx.fillRect(p*23, p*-13, p*3, p*5); ctx.fillStyle=earInner; ctx.fillRect(p*20, p*-12, p*1, p*3); ctx.fillRect(p*24, p*-12, p*1, p*3); const currentRunFrame = Math.floor(this.runFrame / this.runAnimationSpeed) % 2; const upperLegW=p*3, upperLegH=p*5, lowerLegW=p*3, lowerLegH=p*4, hoofH=p*2; const frontUpperX=p*6, frontUpperY=p*17; const backUpperX=p*14, backUpperY=p*17; if(this.isJumping) { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX-p*1,frontUpperY,upperLegW,upperLegH+lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX-p*1+p,frontUpperY,upperLegW-p*2,upperLegH+lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*1,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX-p*1,backUpperY,upperLegW,upperLegH+lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX-p*1+p,backUpperY,upperLegW-p*2,upperLegH+lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*1,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } else if (this.isDucking) { const duckLegH=p*4; const duckHoofY=frontUpperY+duckLegH; ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,duckLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,duckLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX,duckHoofY,upperLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,duckLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,duckLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX,duckHoofY,upperLegW,hoofH); } else { if(currentRunFrame === 0) { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX+p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX-p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } else { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX-p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX+p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } } if (isInvincibleBoostActive) { ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(frameCount * 0.3) * 0.3})`; ctx.lineWidth = 3 + Math.sin(frameCount * 0.4) * 1.5; ctx.beginPath(); let hitboxVisualY = this.isDucking ? duckOffsetY : 0; let hitboxDrawHeight = this.height * scaleY; let hitboxDrawWidth = this.width; let radiusX = (hitboxDrawWidth / 2) + 6 + Math.sin(frameCount * 0.2) * 3; let radiusY = (hitboxDrawHeight / 2) + 6 + Math.sin(frameCount * 0.2) * 3; ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 ); ctx.stroke(); } else if (isShieldActive) { ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)'; ctx.lineWidth = 2 + Math.sin(frameCount * 0.2) * 1; ctx.beginPath(); let hitboxVisualY = this.isDucking ? duckOffsetY : 0; let hitboxDrawHeight = this.height * scaleY; let hitboxDrawWidth = this.width; let radiusX = (hitboxDrawWidth / 2) + 4 + Math.sin(frameCount * 0.15) * 2; let radiusY = (hitboxDrawHeight / 2) + 4 + Math.sin(frameCount * 0.15) * 2; ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 ); ctx.setLineDash([10, 5]); ctx.lineDashOffset = frameCount * -1.5; ctx.stroke(); ctx.setLineDash([]); ctx.lineDashOffset = 0; } ctx.restore(); }, update() { /* ... llama update logic ... */ let appliedGravity = gravity; const airborne = this.y < this.baseY || this.dy > 0; if (airborne && this.isDucking) { appliedGravity *= fastFallMultiplier; } if (this.y < this.baseY || this.dy < 0) { this.dy += appliedGravity; } else { this.dy = 0; this.y = this.baseY; if (this.isJumping) { this.isJumping = false;} } this.y += this.dy; if (this.y > this.baseY) { this.y = this.baseY; this.dy = 0; if (this.isJumping) { this.isJumping = false; } } if (!this.isJumping && !this.isDucking && this.y >= this.baseY) { this.runFrame++; } else if (!this.isJumping && this.y >= this.baseY) { this.runFrame = 0; } else { this.runFrame = 0; } }, jump() { /* ... llama jump logic ... */ if (isGameRunning && !this.isJumping && !this.isDucking && this.y >= this.baseY) { this.dy = this.jumpPower; this.isJumping = true; this.isDucking = false; if(audioReady) jumpSynth.triggerAttackRelease("F#5", "16n"); } }, duck(shouldDuck) { /* ... llama duck logic ... */ if (isGameRunning) { if(shouldDuck && this.isJumping) return; this.isDucking = shouldDuck; } else { this.isDucking = false; } }, reset() { /* ... llama reset logic ... */ this.baseY = canvas.height - groundHeight - this.height; this.y = this.baseY; this.dy = 0; this.isJumping = false; this.isDucking = false; this.runFrame = 0; } };
        class Obstacle { /* ... obstacle class ... */ constructor(x, y, width, height, type, colorScheme = null) { this.x = x; this.y = y; this.width = width; this.height = height; this.type = type; } draw() { /* ... detailed obstacle draw logic ... */ if (this.type === 'cactus') { const p = 2; const mainColor='#2E8B57', darkColor='#228B22', lightColor='#3CB371', spineColor='#1A4D2E'; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); const conceptualHeight = this.height / p; const conceptualWidth = this.width / p; const segmentHeight = Math.max(2, Math.floor(conceptualHeight / 5)); for (let i_concept = 0; i_concept < conceptualHeight; i_concept += 1) { const i_draw = i_concept * p; const segmentIndex = Math.floor(i_concept / segmentHeight); const currentMain = (segmentIndex % 2 === 0) ? mainColor : lightColor; const currentDark = (segmentIndex % 2 === 0) ? darkColor : mainColor; const currentLight = (segmentIndex % 2 === 0) ? lightColor : '#54C581'; ctx.fillStyle = currentMain; ctx.fillRect(p * 2, i_draw, conceptualWidth*p - p * 4, p); ctx.fillStyle = currentDark; ctx.fillRect(p * 2, i_draw, p * 1, p); ctx.fillRect(conceptualWidth*p - p * 3, i_draw, p * 1, p); ctx.fillStyle = currentLight; ctx.fillRect(p * 3, i_draw, p * (conceptualWidth > 4 ? 2 : 1), p); } ctx.fillStyle = darkColor; ctx.fillRect(p * 2, this.height - p * 2, conceptualWidth*p - p * 4, p * 2); const armW_concept = Math.max(3, Math.floor(conceptualWidth * 0.4)); const armH_concept = Math.max(5, Math.floor(conceptualHeight * 0.5)); const armLX_concept = 2 - armW_concept; const armLY_concept = conceptualHeight * 0.3; ctx.fillStyle = mainColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, p, armH_concept*p); ctx.fillRect((armLX_concept+armW_concept)*p-p, armLY_concept*p, p, armH_concept*p); ctx.fillRect(armLX_concept*p, (armLY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armLX_concept+1)*p, armLY_concept*p, (armW_concept-2)*p, p); const armRX_concept = conceptualWidth - 2; const armRY_concept = conceptualHeight * 0.15; ctx.fillStyle = mainColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, p, armH_concept*p); ctx.fillRect((armRX_concept+armW_concept)*p-p, armRY_concept*p, p, armH_concept*p); ctx.fillRect(armRX_concept*p, (armRY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armRX_concept+1)*p, armRY_concept*p, (armW_concept-2)*p, p); ctx.fillStyle = spineColor; for(let i = 0; i < conceptualHeight / 2; i++) { ctx.fillRect(p*2 + Math.random()*(this.width-p*4), Math.random()*this.height, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armLX_concept*p + Math.random()*armW_concept*p, armLY_concept*p + Math.random()*armH_concept*p, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armRX_concept*p + Math.random()*armW_concept*p, armRY_concept*p + Math.random()*armH_concept*p, p/2, p/2); } ctx.restore(); } else if (this.type === 'bird') { const p_bird = 2; const cs = { bodyLight: '#FFDAB9', bodyMain: '#FFA500', bodyDark: '#CD853F', wingHigh: '#FFF8DC', wingLight: '#FFE4B5', wingMain: '#FFDEAD', beak: '#A0522D', eye: '#000000', eyeWhite: '#FFFFFF' }; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*8); ctx.fillStyle = cs.bodyLight; ctx.fillRect(p_bird*6, p_bird*8, p_bird*10, p_bird*4); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*2); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*5); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*1); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*6); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*1); ctx.fillStyle = cs.beak; ctx.fillRect(p_bird*-3, p_bird*3, p_bird*4, p_bird*2); ctx.fillRect(p_bird*-2, p_bird*4, p_bird*2, p_bird*1); ctx.fillStyle = cs.eyeWhite; ctx.fillRect(p_bird*2, p_bird*3, p_bird*3, p_bird*3); ctx.fillStyle = cs.eye; ctx.fillRect(p_bird*3, p_bird*4, p_bird*1, p_bird*1); const flap = Math.sin(frameCount * 0.4) * p_bird * 5; ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*5); ctx.lineTo(p_bird*10, p_bird*-1 + flap); ctx.lineTo(p_bird*8, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*5); ctx.lineTo(p_bird*10, p_bird*1 + flap); ctx.lineTo(p_bird*9, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*5); ctx.lineTo(p_bird*10, p_bird*2 + flap); ctx.lineTo(p_bird*9.5, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*10); ctx.lineTo(p_bird*10, p_bird*14 - flap); ctx.lineTo(p_bird*8, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*10); ctx.lineTo(p_bird*10, p_bird*13 - flap); ctx.lineTo(p_bird*9, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*10); ctx.lineTo(p_bird*10, p_bird*12 - flap); ctx.lineTo(p_bird*9.5, p_bird*9); ctx.closePath(); ctx.fill(); ctx.restore(); } } update() { this.x -= gameSpeed; } }
        class Cloud { /* ... cloud class ... */ constructor(x, y, width, height, speed) { this.x = x; this.y = y; this.width = width; this.height = height; this.speed = speed; } draw() { const p = 1; const c1='#FFFFFF', c2='#F0F8FF', c3='#E0E8EF'; ctx.save(); ctx.globalAlpha = 0.8; ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle=c1; ctx.fillRect(0, p*5, this.width, this.height - p*5); ctx.beginPath(); ctx.arc(this.width * 0.25, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.arc(this.width * 0.75, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = c2; ctx.fillRect(this.width * 0.1, this.height - p*5, this.width*0.8, p*5); ctx.restore(); } update() { this.x -= this.speed; } }
        class Coin { /* ... coin class ... */ constructor(x,y,r){ this.x=x; this.y=y; this.radius=r; this.collected=false; } draw() { /* ... detailed coin draw logic ... */ if (!this.collected) { const bob = Math.sin(frameCount * 0.1 + this.x * 0.05) * 3; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const centerX = drawX + this.radius; const centerY = drawY + this.radius; const outlineColor = '#B8860B'; const mainColor = '#FFD700'; const shadowColor = '#DAA520'; const highlightColor = '#FFFFE0'; ctx.save(); ctx.translate(centerX, centerY); ctx.fillStyle = outlineColor; ctx.beginPath(); ctx.arc(0, 0, this.radius + 1, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = mainColor; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = shadowColor; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = highlightColor; ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, Math.PI * 1.2, Math.PI * 1.9); ctx.fill(); ctx.restore(); } } update(){ this.x-=gameSpeed; } }
        class MysteryBox { /* ... mystery box class ... */ constructor(x, y, size) { this.x = x; this.y = y; this.width = size; this.height = size; this.collected = false; this.openTimer = 0; this.openDuration = 30; this.bobOffset = Math.random() * Math.PI * 2; } draw() { /* ... mystery box draw logic ... */ const bob = Math.sin(frameCount * 0.08 + this.bobOffset) * 4; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const size = this.width; ctx.save(); ctx.translate(drawX, drawY); if (this.collected && this.openTimer > 0) { const progress = 1 - (this.openTimer / this.openDuration); const spinAngle = progress * Math.PI * 2; const scale = 1 + progress * 0.5; const alpha = 1 - progress; ctx.globalAlpha = alpha; ctx.translate(size / 2, size / 2); ctx.rotate(spinAngle); ctx.scale(scale, scale); ctx.translate(-size / 2, -size / 2); ctx.fillStyle = '#c0c0c0'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = '#ffd700'; ctx.fillRect(size * 0.3, size * 0.2, size * 0.4, size * 0.6); } else if (!this.collected) { const p = Math.max(2, Math.floor(size / 10)); const mainColor = '#a0522d'; const bandColor = '#ffd700'; const shadowColor = '#8b4513'; const rivetColor = '#c0c0c0'; ctx.fillStyle = mainColor; ctx.fillRect(0, 0, size, size); ctx.fillStyle = shadowColor; ctx.fillRect(0, size - p, size, p); ctx.fillRect(size - p, 0, p, size); ctx.fillStyle = bandColor; ctx.fillRect(0, size * 0.4, size, size * 0.2); ctx.fillRect(size * 0.4, 0, size * 0.2, size); ctx.fillStyle = rivetColor; ctx.fillRect(p, p, p, p); ctx.fillRect(size - p * 2, p, p, p); ctx.fillRect(p, size - p * 2, p, p); ctx.fillRect(size - p * 2, size - p * 2, p, p); ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.sin(frameCount * 0.15) * 0.3})`; ctx.font = `bold ${size * 0.6}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("?", size / 2, size / 2 + p); } ctx.restore(); } update() { this.x -= gameSpeed; if (this.collected && this.openTimer > 0) { this.openTimer--; } } collect() { if (!this.collected) { this.collected = true; this.openTimer = this.openDuration; if (audioReady) mysteryCollectSynth?.triggerAttackRelease("C5", "8n", Tone.now()); setTimeout(() => grantMysteryReward(this), 100); } } }

        // --- Utility Functions ---
        function getRandomInt(min, max) { /* ... */ min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
        function showPopup(element, message, duration = 2000) { // Generic popup function
            element.textContent = message;
            element.style.display = 'block';
            requestAnimationFrame(() => { element.style.opacity = 1; });
            setTimeout(() => {
                element.style.opacity = 0;
                setTimeout(() => { element.style.display = 'none'; }, 500);
            }, duration);
        }

        // --- NEW: Achievement Definitions ---
        // Structure: id, name, description, type, target, reward, unlocked
        let achievements = [
            { id: 'score_500', name: "Getting Started", description: "Reach a score of 500 points in a single run.", type: 'score', target: 500, reward: 25, unlocked: false },
            { id: 'score_1500', name: "Pro Runner", description: "Reach a score of 1500 points in a single run.", type: 'score', target: 1500, reward: 75, unlocked: false },
            { id: 'high_score_1000', name: "High Scorer", description: "Achieve a lifetime high score over 1000.", type: 'highScore', target: 1000, reward: 100, unlocked: false },
            { id: 'coins_run_50', name: "Coin Collector", description: "Collect 50 coins in a single run.", type: 'coinsRun', target: 50, reward: 30, unlocked: false },
            { id: 'coins_total_1000', name: "Coin Hoarder", description: "Collect 1000 coins across all runs.", type: 'totalCoins', target: 1000, reward: 100, unlocked: false },
            { id: 'jump_total_100', name: "Frequent Flyer", description: "Jump over 100 cacti in total.", type: 'totalJumpCactus', target: 100, reward: 50, unlocked: false },
            { id: 'duck_total_50', name: "Limbo Master", description: "Duck under 50 birds in total.", type: 'totalDuckBird', target: 50, reward: 50, unlocked: false },
            { id: 'use_shield_10', name: "Shield User", description: "Successfully use 10 shields.", type: 'totalShieldsUsed', target: 10, reward: 40, unlocked: false },
            { id: 'survive_night_1', name: "Night Owl", description: "Survive through a full night cycle (score ~700).", type: 'surviveNight', target: 1, reward: 60, unlocked: false },
            { id: 'level_5', name: "Level 5 Reached", description: "Reach Player Level 5.", type: 'level', target: 5, reward: 50, unlocked: false },
            { id: 'level_10', name: "Level 10 Reached", description: "Reach Player Level 10.", type: 'level', target: 10, reward: 150, unlocked: false },
        ];

        // --- NEW: Load/Save Achievement State ---
        function loadAchievements() {
            const savedAchievements = localStorage.getItem('llamaAchievements');
            if (savedAchievements) {
                const loaded = JSON.parse(savedAchievements);
                // Merge saved unlocked status with default definitions
                achievements = achievements.map(def => {
                    const saved = loaded.find(s => s.id === def.id);
                    return { ...def, unlocked: saved ? saved.unlocked : false };
                });
            }
             // Also load cumulative stats needed for achievements
             totalDistanceRun = parseInt(localStorage.getItem('llamaTotalDistance') || 0);
             totalCoinsCollected = parseInt(localStorage.getItem('llamaTotalCoinsCollected') || coins);
             totalCactiJumped = parseInt(localStorage.getItem('llamaTotalCactiJumped') || 0);
             totalBirdsDucked = parseInt(localStorage.getItem('llamaTotalBirdsDucked') || 0);
             totalShieldsUsed = parseInt(localStorage.getItem('llamaTotalShieldsUsed') || 0);
             totalNightsSurvived = parseInt(localStorage.getItem('llamaTotalNightsSurvived') || 0);
        }
        function saveAchievements() {
            // Save only id and unlocked status to keep storage small
            const stateToSave = achievements.map(a => ({ id: a.id, unlocked: a.unlocked }));
            localStorage.setItem('llamaAchievements', JSON.stringify(stateToSave));
            // Save cumulative stats
            localStorage.setItem('llamaTotalDistance', totalDistanceRun);
            localStorage.setItem('llamaTotalCoinsCollected', totalCoinsCollected);
            localStorage.setItem('llamaTotalCactiJumped', totalCactiJumped);
            localStorage.setItem('llamaTotalBirdsDucked', totalBirdsDucked);
            localStorage.setItem('llamaTotalShieldsUsed', totalShieldsUsed);
            localStorage.setItem('llamaTotalNightsSurvived', totalNightsSurvived);
        }

        // --- NEW: Check Achievements ---
        function checkAchievements(checkDuringRun = false) {
            let newUnlock = false;
            let nightSurvivedThisRun = isNight; // Track if we passed through night in this specific run

            achievements.forEach(ach => {
                if (!ach.unlocked) {
                    let criteriaMet = false;
                    switch (ach.type) {
                        case 'score': criteriaMet = !checkDuringRun && score >= ach.target; break;
                        case 'highScore': criteriaMet = !checkDuringRun && highScore >= ach.target; break;
                        case 'coinsRun': criteriaMet = !checkDuringRun && coinsCollectedThisRun >= ach.target; break;
                        case 'totalCoins': criteriaMet = totalCoinsCollected >= ach.target; break; // Check anytime
                        case 'totalJumpCactus': criteriaMet = totalCactiJumped >= ach.target; break; // Check anytime
                        case 'totalDuckBird': criteriaMet = totalBirdsDucked >= ach.target; break; // Check anytime
                        case 'totalShieldsUsed': criteriaMet = totalShieldsUsed >= ach.target; break; // Check anytime
                        case 'surviveNight': criteriaMet = !checkDuringRun && nightSurvivedThisRun; break; // Check only at game over if night was entered
                        case 'level': criteriaMet = playerLevel >= ach.target; break; // Check anytime
                        // Add more criteria types here
                    }

                    if (criteriaMet) {
                        ach.unlocked = true;
                        newUnlock = true;
                        coins += ach.reward;
                        showPopup(achievementPopup, `Achievement Unlocked!\n${ach.name}\n+${ach.reward} Coins!`, 3000);
                        if (audioReady) achievementSynth?.triggerAttackRelease("C4", "1n");
                        console.log(`Achievement unlocked: ${ach.name}`);
                    }
                }
            });

            if (newUnlock) {
                saveAchievements(); // Save immediately after unlocking
                updateDisplays(); // Update coin count
            }
        }

        // --- NEW: Populate Achievement Modal ---
        function populateAchievementModal() {
            achievementList.innerHTML = ''; // Clear previous list
            achievements.forEach(ach => {
                const li = document.createElement('li');
                li.classList.add('achievement-item');
                li.classList.toggle('unlocked', ach.unlocked);
                li.classList.toggle('locked', !ach.unlocked);

                const status = ach.unlocked ? 'Unlocked' : 'Locked';
                // Basic progress display (can be enhanced)
                let progressText = '';
                if (!ach.unlocked) {
                     if (ach.type === 'totalCoins') progressText = ` (${totalCoinsCollected}/${ach.target})`;
                     else if (ach.type === 'totalJumpCactus') progressText = ` (${totalCactiJumped}/${ach.target})`;
                     else if (ach.type === 'totalDuckBird') progressText = ` (${totalBirdsDucked}/${ach.target})`;
                     else if (ach.type === 'totalShieldsUsed') progressText = ` (${totalShieldsUsed}/${ach.target})`;
                     // Add more progress displays if needed
                }


                li.innerHTML = `
                    <span class="status">[${status}]</span>
                    <h4>${ach.name}</h4>
                    <p>${ach.description}${progressText}</p>
                    ${ach.unlocked ? `<p>Reward: ${ach.reward} ü™ô</p>` : ''}
                `;
                achievementList.appendChild(li);
            });
        }


        // --- Game Functions ---
        function setBackground(isNightTime) { /* ... */ currentBgColor = isNightTime ? nightBgColor : dayBgColor; const bodyBg=isNightTime?nightBodyBgColor:dayBodyBgColor; gameContainer.style.backgroundColor=currentBgColor; document.body.style.backgroundColor=bodyBg; }
        function drawStars() { /* ... */ if(!isNight)return; ctx.fillStyle='white'; for(let i=0;i<50;i++){ let x=(Math.random()*canvas.width*1.5 - frameCount*0.1)%canvas.width; if(x<0)x+=canvas.width; let y=Math.random()*canvas.height*0.7; let size=Math.random()>0.8?2:1; ctx.globalAlpha=0.5+Math.sin(frameCount*0.05+i)*0.5; ctx.fillRect(x,y,size,size);} ctx.globalAlpha=1.0; }
        function resizeCanvas() { /* ... */ const container=document.getElementById('game-container'); if (!container || !canvas) return; canvas.width=container.clientWidth; canvas.height=container.clientHeight; canvas.style.width = `${container.clientWidth}px`; canvas.style.height = `${container.clientHeight}px`; llama.reset(); drawGround(); setBackground(isNight); if (isGameOver || !isGameRunning) { gameLoop(); } }
        function drawGround() { /* ... */ if (!ctx) return; ctx.fillStyle=isNight?nightGroundColor:dayGroundColor; ctx.fillRect(0,canvas.height-groundHeight,canvas.width,groundHeight); ctx.fillStyle=isNight?'rgba(255,255,255,0.05)':'rgba(0,0,0,0.1)'; const lineOffset = Math.floor(frameCount * gameSpeed) % 20; for(let i = -lineOffset; i < canvas.width; i+=20){ ctx.fillRect(i, canvas.height-groundHeight+5, 2, groundHeight-10);} }
        function spawnCloud() { /* ... */ const spawnChance=0.003; if(Math.random()<spawnChance){ const cw=getRandomInt(80,140); const ch=getRandomInt(40,70); const cy=Math.random()*(canvas.height*0.3); const cs=gameSpeed*(0.05+Math.random()*0.1); clouds.push(new Cloud(canvas.width,cy,cw,ch,cs));} }
        function updateClouds() { /* ... */ for(let i=clouds.length-1;i>=0;i--){ clouds[i].update(); clouds[i].draw(); if(clouds[i].x+clouds[i].width<0){ clouds.splice(i,1);}} }
        function spawnObstacle() { /* ... Obstacle spawning logic (respects coin rush) ... */ if (!isGameRunning || isCoinRushActive) return; const speedFactor = Math.max(0.5, 1 - (gameSpeed / 25)); const baseMinGap = 190; const randomGapAdd = 230; const absoluteMinGap = 140; const minGap = (baseMinGap + Math.random() * randomGapAdd) * speedFactor + absoluteMinGap; const lastObstacle = obstacles[obstacles.length - 1]; if (!lastObstacle || (canvas.width - (lastObstacle.x + lastObstacle.width)) > minGap) { const type = Math.random() < 0.6 ? 'cactus' : 'bird'; let obstacle; if (type === 'cactus') { const cactusHeight = 46 + Math.random() * 30; const cactusWidth = 30 + Math.random() * 10; obstacle = new Obstacle( canvas.width, canvas.height - groundHeight - cactusHeight, cactusWidth, cactusHeight, 'cactus' ); } else { const birdHitboxWidth = 40; const birdHitboxHeight = 30; const clearance = 5; const birdY = canvas.height - groundHeight - llama.duckHeight - birdHitboxHeight - clearance; obstacle = new Obstacle( canvas.width, birdY, birdHitboxWidth, birdHitboxHeight, 'bird' ); } obstacles.push(obstacle); } }
        function spawnCoin() { /* ... Coin spawning logic (respects coin rush) ... */ if (!isGameRunning) return; let chance = 0.02; const minGap = 80; const lastCoin = coinObjects[coinObjects.length - 1]; if (isCoinRushActive) { chance = 0.25; if (Math.random() < chance) { const numCoins = getRandomInt(2, 4); let startX = canvas.width; if (lastCoin && (canvas.width - (lastCoin.x + lastCoin.radius * 2)) < minGap * 0.5) { startX = lastCoin.x + lastCoin.radius * 2 + minGap * 0.5; } for (let i = 0; i < numCoins; i++) { const r = 10; const y = canvas.height - groundHeight - r*2 - 5 - Math.random() * (llama.height * 1.2); coinObjects.push(new Coin(startX + i * (r * 2.5), Math.max(y, r*2), r)); } } return; } if (Math.random() < chance) { if (!lastCoin || (canvas.width - (lastCoin.x + lastCoin.radius * 2)) > minGap) { const r = 10; const rf = Math.random(); let y; if (rf < 0.5) { y = canvas.height - groundHeight - r*2 - 5; } else { const baseJumpHeight = canvas.height - groundHeight - r*2 - (llama.height * 0.6); y = baseJumpHeight - Math.random()*(llama.height*0.7); } coinObjects.push(new Coin(canvas.width, Math.max(y, r*2), r)); } } }
        function spawnMysteryBox() { /* ... Mystery box spawning logic ... */ if (!isGameRunning || isCoinRushActive) return; const chance = 0.0015; const minGap = 400; const lastBox = mysteryBoxes[mysteryBoxes.length - 1]; const lastObstacle = obstacles[obstacles.length - 1]; if (Math.random() < chance) { const boxGapOk = !lastBox || (canvas.width - (lastBox.x + lastBox.width)) > minGap; const obsGapOk = !lastObstacle || (canvas.width - (lastObstacle.x + lastObstacle.width)) > minGap * 0.8; if (boxGapOk && obsGapOk) { const size = 35; let y; if (Math.random() < 0.5) { y = canvas.height - groundHeight - size - 5; } else { y = canvas.height - groundHeight - size - (llama.height * 0.7) - Math.random() * (llama.height * 0.6); } y = Math.max(size, y); mysteryBoxes.push(new MysteryBox(canvas.width, y, size)); if (audioReady) mysteryAppearSynth?.triggerAttackRelease("A4", "8n"); } } }
        function updateObstacles() { /* ... Obstacle update, draw, mission, collision logic + Achievement Tracking ... */
            for (let i=obstacles.length-1; i>=0; i--) { const obs = obstacles[i]; if (!obs) continue; const wasBehindLlama = obs.x + obs.width < llama.x; obs.update(); obs.draw(); const isNowBehindLlama = obs.x + obs.width < llama.x;
                if (!wasBehindLlama && isNowBehindLlama && !isGameOver) { // Check if just passed
                    if (obs.type === 'cactus' && llama.isJumping) {
                         cactiJumpedThisRun++;
                         totalCactiJumped++; // <<< Track total for achievement
                         updateMissionProgress('jump_cactus', cactiJumpedThisRun);
                    } else if (obs.type === 'bird' && llama.isDucking) {
                         birdsDuckedThisRun++;
                         totalBirdsDucked++; // <<< Track total for achievement
                         updateMissionProgress('duck_bird', birdsDuckedThisRun);
                    }
                }
                if (checkCollision(llama, obs)) { handleCollision(obs); if (isGameOver) return; } if (obs.x + obs.width < 0) { obstacles.splice(i, 1); } }
        }
        function updateCoins() { /* ... Coin update, magnet, draw, collision logic (respects double coins) ... */ const magnetRadius = isMagnetActive ? 100 : 0; for (let i=coinObjects.length-1; i>=0; i--) { const c = coinObjects[i]; if (!c) continue; c.update(); if (isMagnetActive && !c.collected) { /* magnet logic */ const llamaCenterX = llama.x + llama.width / 2; const llamaHitboxY = llama.isDucking ? llama.y + (llama.height - llama.duckHeight) : llama.y; const llamaHitboxHeight = llama.isDucking ? llama.duckHeight : llama.height; const llamaCenterY = llamaHitboxY + llamaHitboxHeight / 2; const coinCenterX = c.x + c.radius; const coinCenterY = c.y + c.radius; const dx = llamaCenterX - coinCenterX; const dy = llamaCenterY - coinCenterY; const distance = Math.sqrt(dx*dx + dy*dy); if(distance < magnetRadius){ const magnetSpeed = 6; c.x += (dx / distance) * magnetSpeed; c.y += (dy / distance) * magnetSpeed;} } c.draw(); const effectiveRadius = isMagnetActive ? c.radius * 1.5 : c.radius; if (!c.collected && checkCollision(llama, c, true, effectiveRadius)) { c.collected=true; const indexToRemove = coinObjects.findIndex(coin => coin === c); if(indexToRemove !== -1) coinObjects.splice(indexToRemove,1); const coinValue = isDoubleCoinsBoostActive ? 2 : 1; coins += coinValue; coinsCollectedThisRun += coinValue; totalCoinsCollected += coinValue; // <<< Track total for achievement
                     updateMissionProgress('coins', coinsCollectedThisRun); if(audioReady) coinSynth.triggerAttackRelease("E6", "16n"); updateDisplays(); } else if (c.x + c.radius*2 < 0) { coinObjects.splice(i, 1); } } }
        function updateMysteryBoxes() { /* ... Mystery box update, draw, collision logic ... */ for (let i = mysteryBoxes.length - 1; i >= 0; i--) { const box = mysteryBoxes[i]; if (!box) continue; box.update(); box.draw(); if (!box.collected && checkCollision(llama, box)) { box.collect(); } if ((box.collected && box.openTimer <= 0) || box.x + box.width < 0) { mysteryBoxes.splice(i, 1); } } }
        function checkCollision(llamaRect, otherObj, isCoin = false, coinRadius = 0) { /* ... Collision detection logic ... */ let llamaTop = llamaRect.isDucking ? llamaRect.y + (llamaRect.height - llamaRect.duckHeight) : llamaRect.y; let llamaHeight = llamaRect.isDucking ? llamaRect.duckHeight : llamaRect.height; let llamaLeft = llamaRect.x; let llamaWidth = llamaRect.width; let llamaBottom = llamaTop + llamaHeight; let llamaRight = llamaLeft + llamaWidth; if (isCoin) { let coinCenterX = otherObj.x + otherObj.radius; const bob = Math.sin(frameCount*0.1+otherObj.x*0.05)*3; let coinCenterY = otherObj.y + bob + otherObj.radius; let radius = coinRadius > 0 ? coinRadius : otherObj.radius; let closestX = Math.max(llamaLeft, Math.min(coinCenterX, llamaRight)); let closestY = Math.max(llamaTop, Math.min(coinCenterY, llamaBottom)); let distanceX = coinCenterX - closestX; let distanceY = coinCenterY - closestY; let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (radius * radius); } else { let objTop = otherObj.y; let objLeft = otherObj.x; let objWidth = otherObj.width; let objHeight = otherObj.height; let objBottom = objTop + objHeight; let objRight = objLeft + objWidth; return ( llamaLeft < objRight && llamaRight > objLeft && llamaTop < objBottom && llamaBottom > objTop ); } }
        function handleCollision(obs) { /* ... Collision handling logic (respects invincibility) + Achievement Tracking ... */
             if (isInvincibleBoostActive) { const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); return; }
             if(isShieldActive){ isShieldActive=false; totalShieldsUsed++; updatePowerupIndicators(); const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); if(audioReady) hitSynth.triggerAttackRelease("C4", "8n"); return; }
             if(extraLives>0){ extraLives--; updatePowerupIndicators();
                  // --- Apply Life Effectiveness Upgrade ---
                  const clearMultiplier = 1.0 + (lifeEffectivenessUpgradeLevel * 0.2); // 20% more range per level
                  const clearRange = 75 * clearMultiplier;
                  obstacles=obstacles.filter(o => o.x > llama.x + llama.width + clearRange || o.x + o.width < llama.x - clearRange);
                  if(audioReady) hitSynth.triggerAttackRelease("A3", "8n"); return;
             }
             if(audioReady) hitSynth.triggerAttackRelease("G2", "4n"); gameOver();
        }
        function updateScore() { /* ... Score update logic + track total distance ... */ if (!isGameRunning) return; score = Math.floor(frameCount / 6); totalDistanceRun += gameSpeed * 0.1; // Approximate distance tracking
             updateMissionProgress('score', score); }

        // --- Update Displays (Modified for Level and Upgrade Costs) ---
        function updateDisplays() {
            // Update store coin balance
            storeCoinBalance.textContent = coins;

            // Update single-use item counts
            shieldOwnedDisplay.textContent = shieldsOwned;
            lifeOwnedDisplay.textContent = livesOwned;
            magnetOwnedDisplay.textContent = magnetsOwned;

            // Update single-use item button states
            buyShieldButton.disabled = coins < shieldCost;
            buyLifeButton.disabled = coins < lifeCost;
            buyMagnetButton.disabled = coins < magnetCost;

            // --- Update Permanent Upgrade Displays ---
            // Magnet Duration
            const magnetMaxLevel = 10; // Example max level
            const magnetCurrentLevel = magnetDurationUpgradeLevel;
            const magnetNextLevelCost = calculateUpgradeCost(50, magnetCurrentLevel, 1.8); // Base 50, 1.8x multiplier
            magnetDurationLevelDisplay.textContent = `${magnetCurrentLevel}${magnetCurrentLevel >= magnetMaxLevel ? ' (MAX)' : ''}`;
            magnetDurationCostDisplay.textContent = magnetCurrentLevel >= magnetMaxLevel ? '---' : magnetNextLevelCost;
            magnetDurationUpgradeButton.disabled = magnetCurrentLevel >= magnetMaxLevel || coins < magnetNextLevelCost;

            // Starting Coins
            const startCoinMaxLevel = 10;
            const startCoinCurrentLevel = startCoinUpgradeLevel;
            const startCoinNextLevelCost = calculateUpgradeCost(100, startCoinCurrentLevel, 2.0); // Base 100, 2x multiplier
            startCoinLevelDisplay.textContent = `${startCoinCurrentLevel}${startCoinCurrentLevel >= startCoinMaxLevel ? ' (MAX)' : ''}`;
            startCoinCostDisplay.textContent = startCoinCurrentLevel >= startCoinMaxLevel ? '---' : startCoinNextLevelCost;
            startCoinUpgradeButton.disabled = startCoinCurrentLevel >= startCoinMaxLevel || coins < startCoinNextLevelCost;

             // Life Effectiveness
            const lifeEffectMaxLevel = 5;
            const lifeEffectCurrentLevel = lifeEffectivenessUpgradeLevel;
            const lifeEffectNextLevelCost = calculateUpgradeCost(150, lifeEffectCurrentLevel, 2.2); // Base 150, 2.2x multiplier
            lifeEffectivenessLevelDisplay.textContent = `${lifeEffectCurrentLevel}${lifeEffectCurrentLevel >= lifeEffectMaxLevel ? ' (MAX)' : ''}`;
            lifeEffectivenessCostDisplay.textContent = lifeEffectCurrentLevel >= lifeEffectMaxLevel ? '---' : lifeEffectNextLevelCost;
            lifeEffectivenessUpgradeButton.disabled = lifeEffectCurrentLevel >= lifeEffectMaxLevel || coins < lifeEffectNextLevelCost;

            // Update powerup indicators on game screen
            updatePowerupIndicators();
        }
        function updatePowerupIndicators() { /* ... */ shieldIndicator.classList.toggle('active', isShieldActive); magnetIndicator.classList.toggle('active', isMagnetActive); lifeIndicator.classList.toggle('active', extraLives > 0); lifeIndicator.textContent = extraLives > 0 ? `‚ù§Ô∏è ${extraLives}` : '‚ù§Ô∏è'; shieldIndicator.classList.toggle('owned', shieldsOwned > 0 && !isShieldActive); magnetIndicator.classList.toggle('owned', magnetsOwned > 0 && !isMagnetActive); lifeIndicator.classList.toggle('owned', livesOwned > 0 && !(extraLives > 0)); }

        // --- NEW: Calculate Upgrade Cost ---
        function calculateUpgradeCost(baseCost, currentLevel, multiplier) {
            return Math.floor(baseCost * Math.pow(multiplier, currentLevel));
        }

        // --- Game Over (Modified for XP and Achievement Check) ---
        function gameOver() {
            if(isGameOver) return;
            console.log("Game Over triggered");
            isGameOver=true; isGameRunning=false; isCoinRushActive = false;
            isInvincibleBoostActive = false; isDoubleCoinsBoostActive = false; isSpeedBoostActive = false;
            invincibleBoostTimer = 0; doubleCoinsBoostTimer = 0; speedBoostTimer = 0; coinRushTimer = 0;
            gameSpeed = baseGameSpeed;

            // --- XP Calculation & Level Up ---
            const xpEarned = Math.floor(score * xpPerScorePoint);
            playerXP += xpEarned;
            console.log(`Earned ${xpEarned} XP. Total XP: ${playerXP}`);
            let leveledUp = false;
            while (playerXP >= xpForLevelUp(playerLevel)) {
                const needed = xpForLevelUp(playerLevel);
                playerXP -= needed;
                playerLevel++;
                leveledUp = true;
                const levelReward = playerLevel * 25; // Reward scales with level
                coins += levelReward;
                showPopup(levelUpPopup, `Level Up! Reached Level ${playerLevel}!\n+${levelReward} Coins!`, 3000);
                if(audioReady) levelUpSynth?.triggerAttackRelease("C4", "1n");
                console.log(`Leveled up to ${playerLevel}! Rewarded ${levelReward} coins.`);
            }
            localStorage.setItem('llamaPlayerXP', playerXP);
            localStorage.setItem('llamaPlayerLevel', playerLevel);
            // --- End XP ---

            // Save High Score & Stats
            if(score > highScore) { highScore = score; localStorage.setItem('llamaHighScore', highScore); }
            localStorage.setItem('llamaCoins',coins); localStorage.setItem('llamaShields',shieldsOwned); localStorage.setItem('llamaLives',livesOwned); localStorage.setItem('llamaMagnets',magnetsOwned);
            saveAchievements(); // Save cumulative stats and achievement unlock status

            // --- Check Achievements ---
            checkAchievements(false); // Check achievements at end of run

            updatePowerupIndicators();
        }
        function selectNewMission() { /* ... */ const availableMissions = missionPool; if (availableMissions.length > 0) { activeMission = availableMissions[Math.floor(Math.random() * availableMissions.length)]; missionProgress = 0; coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0; console.log("New Mission Selected:", activeMission.description); missionNotificationText = `New Mission: ${activeMission.description}`; missionNotificationTimer = missionNotificationDuration; } else { activeMission = null; console.log("No more missions available."); missionNotificationText = ""; missionNotificationTimer = 0; } }
        function showMissionCompletePopup() { /* ... */ showPopup(missionCompletePopup, `Mission Complete! +${activeMission.reward} Coins ü™ô`); if(audioReady) missionSynth.triggerAttackRelease("C6", "8n"); }
        function updateMissionProgress(type, value) { /* ... */ if (!activeMission || activeMission.type !== type || !isGameRunning) { return; } missionProgress = value; if (missionProgress >= activeMission.target) { console.log(`Mission Complete: ${activeMission.description}`); coins += activeMission.reward; localStorage.setItem('llamaCoins', coins); showMissionCompletePopup(); selectNewMission(); updateDisplays(); } }

        // --- Reset Game (Modified for Starting Coins) ---
        function resetGame() {
            console.log("Resetting game...");
            score=0; obstacles=[]; coinObjects=[]; clouds=[]; mysteryBoxes = [];
            frameCount=0; lastScoreThreshold=0; isGameOver=false;
            isShieldActive=false; isMagnetActive=false; magnetTimer=0; extraLives=0;
            isInvincibleBoostActive = false; invincibleBoostTimer = 0; isDoubleCoinsBoostActive = false; doubleCoinsBoostTimer = 0; isSpeedBoostActive = false; speedBoostTimer = 0;
            isCoinRushActive = false; coinRushTimer = 0;
            baseGameSpeed = initialGameSpeed; gameSpeed = baseGameSpeed;
            console.log("Speed reset to:", gameSpeed);

            // --- Apply Starting Coin Bonus ---
            const startingCoinBonus = startCoinUpgradeLevel * 5; // 5 coins per level
            coins += startingCoinBonus;
            if (startingCoinBonus > 0) {
                 console.log(`Applied starting coin bonus: +${startingCoinBonus}`);
                 // Maybe show a quick notification?
                 // showPopup(rewardPopup, `Starting Bonus: +${startingCoinBonus} ü™ô`, 1500);
            }
            // --- End Starting Coin Bonus ---

            // Apply Magnet Duration Upgrade
            currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); // +1 sec per level

            // Auto-activate purchased Power-ups
            if(shieldsOwned>0){isShieldActive=true;shieldsOwned--;localStorage.setItem('llamaShields',shieldsOwned);}
            if(livesOwned>0){extraLives=1;livesOwned--;localStorage.setItem('llamaLives',livesOwned);}
            if(magnetsOwned>0){isMagnetActive=true;magnetTimer=currentMagnetDuration;magnetsOwned--;localStorage.setItem('llamaMagnets',magnetsOwned);} // Use upgraded duration

            llama.reset();
            coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0;
            selectNewMission();
            updateDisplays();
            framesAfterReset = 10;
            console.log("Game reset complete.");
        }

        // --- Draw UI Elements on Canvas (Modified for Level Display) ---
        function drawUI() {
            const padding = 15;
            const fontSizeSmall = Math.max(8, Math.min(10, canvas.width / 40));
            const uiFont = `${fontSizeSmall}px "Press Start 2P"`;

            ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
            ctx.font = uiFont;

            // Score & High Score (Top Right)
            ctx.textAlign = 'right';
            ctx.fillText(`HI ${highScore}`, canvas.width - padding, padding + fontSizeSmall);
            ctx.fillText(`${score}`, canvas.width - padding, padding * 2 + fontSizeSmall * 2);
            // Coins
            ctx.fillText(`ü™ô ${coins}`, canvas.width - padding, padding * 3 + fontSizeSmall * 3.5);
            // --- NEW: Level Display ---
            ctx.fillText(`Lv ${playerLevel}`, canvas.width - padding, padding * 4 + fontSizeSmall * 5);
            // Mission Display (Adjust Y position)
            if (activeMission) { /* ... mission text ... */ const progressText = activeMission.type === 'score' ? `${score}/${activeMission.target}` : `${missionProgress}/${activeMission.target}`; let missionText = `${activeMission.description} (${progressText})`; const maxWidth = canvas.width * 0.4; if (ctx.measureText(missionText).width > maxWidth) { missionText = activeMission.description.substring(0, 15) + `... (${progressText})`; } ctx.fillText(missionText, canvas.width - padding, padding * 5 + fontSizeSmall * 6.5); }

            // Mission Notification (Top Center)
            if (missionNotificationTimer > 0) { /* ... mission notification ... */ ctx.textAlign = 'center'; ctx.fillStyle = isNight ? '#00FFFF' : '#0000FF'; ctx.font = `${fontSizeSmall * 1.1}px "Press Start 2P"`; const textWidth = ctx.measureText(missionNotificationText).width; ctx.fillStyle = isNight ? 'rgba(0,0,0,0.5)' : 'rgba(255,255,255,0.5)'; ctx.fillRect(canvas.width / 2 - textWidth / 2 - 5, padding - fontSizeSmall * 0.2, textWidth + 10, fontSizeSmall * 1.5); ctx.fillStyle = isNight ? '#00FFFF' : '#0000FF'; ctx.fillText(missionNotificationText, canvas.width / 2, padding + fontSizeSmall); missionNotificationTimer--; }

            // Coin Rush Indicator
            if (isCoinRushActive) { /* ... coin rush indicator ... */ ctx.textAlign = 'center'; ctx.font = `bold ${fontSizeSmall * 1.5}px "Press Start 2P"`; const rushColor = `rgba(255, ${180 + Math.sin(frameCount * 0.2) * 75}, 0, ${0.7 + Math.sin(frameCount * 0.1) * 0.3})`; ctx.fillStyle = rushColor; ctx.shadowColor = 'black'; ctx.shadowBlur = 5; ctx.fillText("COIN RUSH!", canvas.width / 2, canvas.height * 0.2); ctx.shadowBlur = 0; }
             // Double Coins Indicator
             if (isDoubleCoinsBoostActive) { /* ... double coins indicator ... */ ctx.textAlign = 'center'; ctx.font = `bold ${fontSizeSmall * 1.2}px "Press Start 2P"`; ctx.fillStyle = 'lime'; ctx.shadowColor = 'black'; ctx.shadowBlur = 3; ctx.fillText("2x COINS!", canvas.width / 2, canvas.height * 0.25); ctx.shadowBlur = 0; }
        }

        // --- Draw Game Over Overlay (Modified for Achievement Button) ---
        function drawGameOverOverlay() {
             const boxWidth = Math.min(canvas.width * 0.7, 400);
             const boxHeight = Math.min(canvas.height * 0.6, 340); // Increased height for buttons
             const boxX = (canvas.width - boxWidth) / 2;
             const boxY = (canvas.height - boxHeight) / 2;

             ctx.fillStyle = "rgba(0, 0, 0, 0.75)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
             ctx.fillStyle = isNight ? nightUiBg : "rgba(255, 255, 255, 0.95)"; ctx.strokeStyle = isNight ? nightUiBorder : "#4a4a4a"; ctx.lineWidth = 3;
             ctx.fillRect(boxX, boxY, boxWidth, boxHeight); ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

             const padding = 20; const baseFontSize = Math.max(10, Math.min(16, boxWidth / 22)); const lineSpacing = baseFontSize * 1.8; // Slightly tighter spacing
             let currentY = boxY + padding + baseFontSize * 1.5;

             ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.font = `bold ${baseFontSize * 1.3}px "Press Start 2P"`; ctx.textAlign = "center";
             ctx.fillText("Game Over!", canvas.width / 2, currentY);

             currentY += lineSpacing * 1.2; ctx.font = `${baseFontSize}px "Press Start 2P"`;
             ctx.fillText(`Score: ${score}`, canvas.width / 2, currentY);
             currentY += lineSpacing * 0.8; ctx.fillText(`Coins: ${coins} ü™ô`, canvas.width / 2, currentY);
             currentY += lineSpacing * 0.8; ctx.fillText(`Level: ${playerLevel}`, canvas.width / 2, currentY); // Show level

             currentY += lineSpacing * 1.2; ctx.font = `${baseFontSize * 0.9}px "Press Start 2P"`;
             ctx.fillText("Tap to Restart", canvas.width / 2, currentY);

             // --- Buttons Area ---
             currentY += lineSpacing * 1.0; // Space before buttons
             const buttonHeight = baseFontSize * 2.5;
             const buttonWidth = baseFontSize * 10; // Wider buttons
             const buttonSpacing = baseFontSize * 1.5; // Space between buttons
             const totalButtonWidth = buttonWidth * 2 + buttonSpacing;
             const buttonStartX = (canvas.width - totalButtonWidth) / 2;

             // Store Button
             const storeButtonX = buttonStartX;
             const storeButtonY = currentY;
             storeButtonBounds = { x: storeButtonX, y: storeButtonY, width: buttonWidth, height: buttonHeight };
             ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(storeButtonBounds.x, storeButtonBounds.y, storeButtonBounds.width, storeButtonBounds.height);
             ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(storeButtonBounds.x, storeButtonBounds.y, storeButtonBounds.width, storeButtonBounds.height);
             ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.font = `${baseFontSize * 0.8}px "Press Start 2P"`;
             ctx.fillText("[ Store ]", storeButtonX + buttonWidth / 2, storeButtonY + buttonHeight * 0.65);

             // --- NEW: Achievement Button ---
             const achButtonX = buttonStartX + buttonWidth + buttonSpacing;
             const achButtonY = currentY;
             achievementButtonBounds = { x: achButtonX, y: achButtonY, width: buttonWidth, height: buttonHeight };
             ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(achievementButtonBounds.x, achievementButtonBounds.y, achievementButtonBounds.width, achievementButtonBounds.height);
             ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(achievementButtonBounds.x, achievementButtonBounds.y, achievementButtonBounds.width, achievementButtonBounds.height);
             ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.font = `${baseFontSize * 0.8}px "Press Start 2P"`;
             ctx.fillText("[Achieve]", achButtonX + buttonWidth / 2, achButtonY + buttonHeight * 0.65); // Shorter text
        }

        function grantMysteryReward(box) { /* ... mystery reward logic ... */ const rand = Math.random(); let rewardMessage = ""; if (rand < 0.4) { const coinRand = Math.random(); let amount; if (coinRand < 0.6) amount = 5; else if (coinRand < 0.9) amount = 15; else amount = 30; coins += amount; rewardMessage = `+${amount} Coins! ü™ô`; if (audioReady) rewardSynth?.triggerAttackRelease(["C4", "E4", "G4"], "8n"); } else if (rand < 0.75) { const boostRand = Math.random(); if (boostRand < 0.5 && !isInvincibleBoostActive) { isInvincibleBoostActive = true; invincibleBoostTimer = invincibleBoostDuration; rewardMessage = "Invincible! (5s)"; if (audioReady) rewardSynth?.triggerAttackRelease(["G4", "C5", "E5"], "4n"); } else if (!isDoubleCoinsBoostActive) { isDoubleCoinsBoostActive = true; doubleCoinsBoostTimer = doubleCoinsBoostDuration; rewardMessage = "2x Coins! (10s)"; if (audioReady) rewardSynth?.triggerAttackRelease(["C4", "G4", "C5"], "4n"); } else { coins += 3; rewardMessage = "+3 Coins! ü™ô"; if (audioReady) rewardSynth?.triggerAttackRelease(["C4"], "8n"); } } else if (rand < 0.95) { const powerupRand = Math.random(); if (powerupRand < 0.5 && !isShieldActive && !isInvincibleBoostActive) { isShieldActive = true; updatePowerupIndicators(); rewardMessage = "Shield Activated!"; if (audioReady) rewardSynth?.triggerAttackRelease(["E4", "G4", "B4"], "8n"); } else if (!isMagnetActive) { isMagnetActive = true; magnetTimer = currentMagnetDuration; updatePowerupIndicators(); rewardMessage = "Coin Magnet!"; if (audioReady) rewardSynth?.triggerAttackRelease(["D4", "F#4", "A4"], "8n"); } else { coins += 10; rewardMessage = "+10 Coins! ü™ô"; if (audioReady) rewardSynth?.triggerAttackRelease(["D4", "A4"], "8n"); } } else { const ownedRand = Math.random(); if (ownedRand < 0.33) { shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); rewardMessage = "+1 Shield Added!"; } else if (ownedRand < 0.66) { livesOwned++; localStorage.setItem('llamaLives', livesOwned); rewardMessage = "+1 Life Added!"; } else { magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); rewardMessage = "+1 Magnet Added!"; } if (audioReady) rewardSynth?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "4n"); } if (rewardMessage) { showPopup(rewardPopup, rewardMessage); updateDisplays(); } console.log("Mystery Box Reward:", rewardMessage); }
        function checkDailyLogin() { /* ... daily login logic ... */ const today = new Date().toISOString().split('T')[0]; const lastLogin = localStorage.getItem('llamaLastLoginDate'); const consecutiveDays = parseInt(localStorage.getItem('llamaConsecutiveDays') || 0); if (lastLogin === today) { return; } let currentStreak = 1; if (lastLogin) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.toISOString().split('T')[0]; if (lastLogin === yesterdayStr) { currentStreak = consecutiveDays + 1; } } localStorage.setItem('llamaLastLoginDate', today); localStorage.setItem('llamaConsecutiveDays', currentStreak); const baseReward = 10 + (currentStreak - 1) * 5; let bonusMessage = ""; let bonusCoins = 0; let bonusItem = null; const bonusRand = Math.random(); if (currentStreak >= 5 && bonusRand < 0.15) { const itemRand = Math.random(); if (itemRand < 0.33) { bonusItem = 'Shield'; shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); } else if (itemRand < 0.66) { bonusItem = 'Life'; livesOwned++; localStorage.setItem('llamaLives', livesOwned); } else { bonusItem = 'Magnet'; magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); } bonusMessage = `+ Bonus ${bonusItem}!`; } else if (bonusRand < 0.3) { bonusCoins = 5 + Math.floor(Math.random() * (currentStreak * 2)); bonusMessage = `+ Bonus ${bonusCoins} Coins!`; } const totalReward = baseReward + bonusCoins; coins += totalReward; localStorage.setItem('llamaCoins', coins); dailyLoginTitle.textContent = `Day ${currentStreak} Login Bonus!`; dailyLoginMessage.innerHTML = `You received ${baseReward} Coins! ü™ô<br>${bonusMessage}`; dailyLoginModal.style.display = 'flex'; if (audioReady) dailyBonusSynth?.triggerAttackRelease("A4", "2n"); updateDisplays(); }

        // --- Main Game Loop ---
        function gameLoop() { /* ... Main loop logic ... */ if (framesAfterReset > 0) { framesAfterReset--; } if (isGameOver) { /* Draw game over */ ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); drawGround(); clouds.forEach(c => c.draw()); drawStars(); llama.draw(); drawGameOverOverlay(); return; } isGameRunning = true; const scoreCycle = Math.floor(score / 700); const shouldBeNight = scoreCycle % 2 !== 0; if (shouldBeNight !== isNight) { isNight = shouldBeNight; setBackground(isNight); if (isGameRunning) totalNightsSurvived++; } if (!isCoinRushActive && score >= coinRushMinScore && Math.random() < coinRushChance) { isCoinRushActive = true; coinRushTimer = coinRushDuration; if (audioReady) coinRushSynth?.triggerAttackRelease("4n"); console.log("COIN RUSH STARTED!"); } if (isCoinRushActive) { coinRushTimer--; if (coinRushTimer <= 0) { isCoinRushActive = false; gameSpeed = baseGameSpeed; console.log("COIN RUSH ENDED"); } } if (isInvincibleBoostActive) { invincibleBoostTimer--; if (invincibleBoostTimer <= 0) { isInvincibleBoostActive = false; } } if (isDoubleCoinsBoostActive) { doubleCoinsBoostTimer--; if (doubleCoinsBoostTimer <= 0) { isDoubleCoinsBoostActive = false; } } if (isMagnetActive) { magnetTimer--; if (magnetTimer <= 0) { isMagnetActive = false; updatePowerupIndicators(); } } ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvas.width, canvas.height); spawnCloud(); updateClouds(); drawStars(); drawGround(); llama.update(); llama.draw(); spawnObstacle(); spawnCoin(); spawnMysteryBox(); updateObstacles(); updateCoins(); updateMysteryBoxes(); updateScore(); const currentScoreThreshold = Math.floor(score / 100); if (currentScoreThreshold > lastScoreThreshold && !isCoinRushActive) { gameSpeed += speedIncrement; baseGameSpeed += speedIncrement; lastScoreThreshold = currentScoreThreshold; console.log(`Score ${lastScoreThreshold * 100}, Speed: ${gameSpeed.toFixed(2)}`); } drawUI(); frameCount++; animationFrameId = requestAnimationFrame(gameLoop); }

        // --- Function to Initiate Game Start ---
        function initiateGameStart() { /* ... */ if (!isGameOver || isGameRunning) { console.log("Not starting: game over=", isGameOver, " running=", isGameRunning); return; } console.log("Initiating game start..."); resetGame(); isGameOver = false; isGameRunning = true; if (animationFrameId) { cancelAnimationFrame(animationFrameId); } gameLoop(); }

        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', (e) => { /* ... keydown logic, check modals ... */ if (dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex') return; if(isGameOver){if(e.code==='Space'||e.code==='ArrowUp'){ if (!storeInterface.style.display || storeInterface.style.display === 'none' || storeInterface.style.display === ''){ e.preventDefault(); handleGameStartInteraction(); } } return; } if(isGameRunning){ if(e.code==='Space'||e.code==='ArrowUp'){ e.preventDefault(); llama.jump(); } else if(e.code==='ArrowDown'){ e.preventDefault(); if (!llama.isDucking){ llama.duck(true); } } } });
        document.addEventListener('keyup', (e) => { /* ... keyup logic ... */ if(isGameRunning && e.code==='ArrowDown'){ e.preventDefault(); llama.duck(false); } });
        function playUIClick(){ if(audioReady) uiClickSynth.triggerAttackRelease("A5", "16n"); }
        // Store Buttons
        buyShieldButton.addEventListener('click', () => { /* ... */ playUIClick(); if (coins >= shieldCost) { coins -= shieldCost; shieldsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaShields', shieldsOwned); updateDisplays(); } });
        buyLifeButton.addEventListener('click', () => { /* ... */ playUIClick(); if (coins >= lifeCost) { coins -= lifeCost; livesOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLives', livesOwned); updateDisplays(); } });
        buyMagnetButton.addEventListener('click', () => { /* ... */ playUIClick(); if (coins >= magnetCost) { coins -= magnetCost; magnetsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnets', magnetsOwned); updateDisplays(); } });
        closeStoreButton.addEventListener('click', () => { /* ... */ playUIClick(); storeInterface.style.display = 'none'; if(isGameOver) { gameLoop(); } });
        // --- NEW: Permanent Upgrade Buttons ---
        magnetDurationUpgradeButton.addEventListener('click', () => {
             playUIClick();
             const cost = calculateUpgradeCost(50, magnetDurationUpgradeLevel, 1.8);
             if (coins >= cost && magnetDurationUpgradeLevel < 10) { // Check max level
                 coins -= cost; magnetDurationUpgradeLevel++;
                 localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnetUpgrade', magnetDurationUpgradeLevel);
                 updateDisplays(); // Update cost and level display
                 currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); // Update effective duration immediately
             }
        });
        startCoinUpgradeButton.addEventListener('click', () => {
             playUIClick();
             const cost = calculateUpgradeCost(100, startCoinUpgradeLevel, 2.0);
             if (coins >= cost && startCoinUpgradeLevel < 10) {
                 coins -= cost; startCoinUpgradeLevel++;
                 localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaStartCoinUpgrade', startCoinUpgradeLevel);
                 updateDisplays();
             }
        });
         lifeEffectivenessUpgradeButton.addEventListener('click', () => {
             playUIClick();
             const cost = calculateUpgradeCost(150, lifeEffectivenessUpgradeLevel, 2.2);
             if (coins >= cost && lifeEffectivenessUpgradeLevel < 5) {
                 coins -= cost; lifeEffectivenessUpgradeLevel++;
                 localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLifeEffectUpgrade', lifeEffectivenessUpgradeLevel);
                 updateDisplays();
             }
        });

        // Modal Close Buttons
        dailyLoginCloseButton.addEventListener('click', () => { playUIClick(); dailyLoginModal.style.display = 'none'; if(isGameOver) { gameLoop(); } });
        achievementCloseButton.addEventListener('click', () => { playUIClick(); achievementModal.style.display = 'none'; if(isGameOver) { gameLoop(); } });

        function handleGameStartInteraction() { /* ... Handle audio context and call initiateGameStart, check modals ... */ if (dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex') return; if (!isGameOver || isGameRunning) { console.log("Interaction ignored: game not ready."); return; } console.log("Handle Interaction - Game Over: ", isGameOver, " Running: ", isGameRunning); if (!audioReady) { try { console.log("Attempting Tone.start()..."); Tone.start().then(() => { console.log("Audio context started."); setupAudio(); initiateGameStart(); }).catch(e => { console.error("Tone.start() failed:", e); initiateGameStart(); }); } catch (e) { console.error("Error calling Tone.start():", e); initiateGameStart(); } } else { console.log("Audio ready, starting game."); initiateGameStart(); } }
        gameContainer.addEventListener('touchstart', (e) => { /* ... Touch start logic, check modals, handle store/achievement buttons ... */
             if (dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex') return;
             if (storeInterface.style.display === 'flex') return;
             const touch = e.changedTouches[0]; const rect = canvas.getBoundingClientRect();
             if (isGameOver) {
                 e.preventDefault(); const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top;
                 // Check Store Button
                 if (storeButtonBounds && touchX >= storeButtonBounds.x && touchX <= storeButtonBounds.x + storeButtonBounds.width && touchY >= storeButtonBounds.y && touchY <= storeButtonBounds.y + storeButtonBounds.height) {
                     console.log("Store button tapped"); playUIClick(); storeInterface.style.display = 'flex'; updateDisplays();
                 }
                 // --- NEW: Check Achievement Button ---
                 else if (achievementButtonBounds && touchX >= achievementButtonBounds.x && touchX <= achievementButtonBounds.x + achievementButtonBounds.width && touchY >= achievementButtonBounds.y && touchY <= achievementButtonBounds.y + achievementButtonBounds.height) {
                     console.log("Achievement button tapped"); playUIClick(); populateAchievementModal(); achievementModal.style.display = 'flex';
                 }
                 // Tap anywhere else restarts
                 else { console.log("Tap starting game"); handleGameStartInteraction(); } return;
             }
             if (isGameRunning) { touchStartX = touch.screenX; touchStartY = touch.screenY; touchStartTime = Date.now(); isSwiping = false; } }, {passive: false});
        gameContainer.addEventListener('touchmove', (e) => { /* ... Touch move logic, check modals ... */ if (dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex') return; if (!isGameRunning || touchStartY === 0 || storeInterface.style.display === 'flex') return; const touch = e.changedTouches[0]; const currentX = touch.screenX; const currentY = touch.screenY; let distY = currentY - touchStartY; let distX = currentX - touchStartX; if (!isSwiping && (Math.abs(distY) > 10 || Math.abs(distX) > 10)) { if (Math.abs(distY) > Math.abs(distX)) { e.preventDefault(); } isSwiping = true; } if (isSwiping && distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { if (!llama.isDucking) { llama.duck(true); } } }, {passive: false});
        gameContainer.addEventListener('touchend', (e) => { /* ... Touch end logic, check modals ... */ if (dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex') return; if (!isGameRunning || touchStartY === 0 || storeInterface.style.display === 'flex') { touchStartY = 0; isSwiping = false; return; } const touchEndTime = Date.now(); const touchDuration = touchEndTime - touchStartTime; const touchEndY = e.changedTouches[0].screenY; const touchEndX = e.changedTouches[0].screenX; let distY = touchEndY - touchStartY; let distX = touchEndX - touchStartX; if (touchDuration < maxTapTime && Math.abs(distX) < 20 && Math.abs(distY) < 20 && !isSwiping) { console.log("Tap -> Jump"); llama.jump(); } else if (distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Down End -> Duck End"); llama.duck(false); } else if (distY < -minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Up -> Jump"); llama.jump(); } else { if (llama.isDucking){ llama.duck(false); } } touchStartX = 0; touchStartY = 0; touchStartTime = 0; isSwiping = false; });

        // --- Initial Setup ---
        window.onload = () => {
             console.log("Window loaded. Initializing game display.");
             loadAchievements(); // <<< Load achievement status and stats
             resizeCanvas();
             isGameOver = true;
             isGameRunning = false;
             checkDailyLogin(); // Check for daily login bonus
             updateDisplays(); // Update store costs based on loaded upgrade levels
             currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); // Set initial magnet duration based on upgrades
             if (dailyLoginModal.style.display !== 'flex') { gameLoop(); } // Draw initial game over screen if modal not shown
             console.log("Game initialized. Waiting for user interaction or modal close.");
        };

    </script>
</body>
</html>
