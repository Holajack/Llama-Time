<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#87CEEB">
  <meta name="google-adsense-account" content="ca-pub-3940397734826984">
  <title>Llama Time!</title>
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icons/llama-icon-192.png">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Llama Time">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-68N7VH7BF2"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-68N7VH7BF2');
  </script>
  <style>
    /* Basic Reset & Body Styles */
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    body {
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      min-height: 100vh; background-color: #f0f0f0;
      font-family: 'Press Start 2P', cursive; color: #333; padding: 0;
      transition: background-color 0.5s ease;
      -webkit-user-select: none; -ms-user-select: none; user-select: none;
    }

    /* Game Container & Canvas */
    #game-container {
      position: relative; width: 100vw; height: 100vh;
      max-width: none; border: none; border-radius: 0;
      overflow: hidden; cursor: pointer; background-color: #87CEEB;
      transition: background-color 0.5s ease; flex-shrink: 0; margin: 0;
    }
    canvas {
      display: block; width: 100%; height: 100%; background-color: transparent;
      image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges;
    }

    /* Popups & Indicators */
    #mission-complete-popup, #reward-popup, #level-up-popup, #achievement-popup {
      position: absolute; top: 15px; right: 15px;
      background-color: rgba(76, 175, 80, 0.9); color: white;
      padding: 8px 15px; border-radius: 10px; font-size: clamp(0.6em, 2vw, 0.8em);
      z-index: 30; display: none; opacity: 0; transition: opacity 0.5s ease-out;
      font-family: 'Press Start 2P', cursive; text-align: center; max-width: 80%;
      pointer-events: none;
    }
    #reward-popup { background-color: rgba(255, 215, 0, 0.9); color: #333; }
    #level-up-popup { background-color: rgba(0, 191, 255, 0.9); color: white; }
    #achievement-popup { background-color: rgba(128, 0, 128, 0.9); color: white; }

    /* Store Interface */
    #store-interface {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9); display: none; flex-direction: column;
      align-items: center; justify-content: flex-start; z-index: 20; color: white;
      padding: 15px 10px; text-align: center; overflow-y: auto;
    }
    #store-interface h2 { margin-top: 10px; margin-bottom: 10px; font-size: clamp(1.2em, 4vw, 1.5em); flex-shrink: 0; }
    #store-interface > p { margin-bottom: 10px; font-size: clamp(0.8em, 3vw, 1em); flex-shrink: 0; }
    .store-section { width: 100%; margin-bottom: 15px; border-bottom: 1px solid #666; padding-bottom: 10px; }
    .store-section h3 { font-size: clamp(1em, 3.5vw, 1.2em); margin-bottom: 10px; color: gold; }
    .store-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 10px; width: 90%; max-width: 350px; border: 2px solid #fff; flex-shrink: 0; }
    .store-item h4 { font-size: clamp(0.9em, 3vw, 1.0em); margin-bottom: 5px; }
    .store-item p { margin-bottom: 8px; font-size: clamp(0.7em, 2.5vw, 0.8em); }
    .store-item .upgrade-level { font-size: clamp(0.6em, 2vw, 0.7em); color: #ccc; margin-bottom: 5px; }
    .store-item button { font-family: 'Press Start 2P', cursive; font-size: clamp(0.7em, 2.5vw, 0.8em); padding: 8px 15px; margin-top: 5px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer;}
    .store-item button:disabled { opacity: 0.5; cursor: not-allowed; }
    #close-store { margin-top: 20px; margin-bottom: 30px; padding: 10px 20px; font-size: clamp(0.9em, 3vw, 1em); flex-shrink: 0; font-family: 'Press Start 2P', cursive; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; }

    /* Powerup Indicators */
    #powerup-indicators { position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; gap: 8px; pointer-events: none; }
    .indicator { font-size: clamp(1.2em, 4vw, 1.8em); opacity: 0.35; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: opacity 0.3s ease, filter 0.3s ease; filter: grayscale(50%); }
    .indicator.owned { opacity: 0.7; filter: grayscale(0%); }
    .indicator.active { opacity: 1; filter: grayscale(0%); animation: pulse 0.8s infinite; }
    #magnet-indicator.active { animation: pulse-magnet 0.6s infinite; }
    @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
    @keyframes pulse-magnet { 0% { transform: scale(1); text-shadow: 0 0 5px gold; } 50% { transform: scale(1.2); text-shadow: 0 0 15px gold; } 100% { transform: scale(1); text-shadow: 0 0 5px gold; } }

    /* Modal Styles (Shared Base) */
    .modal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.8); display: none; flex-direction: column;
      align-items: center; justify-content: center; z-index: 100; color: white;
      padding: 20px; text-align: center;
    }
    .modal-content {
      background-color: #333; padding: 20px 30px; border-radius: 15px;
      border: 3px solid #ccc; max-width: 90%; width: 450px;
      max-height: 85vh; overflow-y: auto;
    }
    .modal-content h2 { font-size: clamp(1.1em, 4vw, 1.4em); margin-bottom: 15px; color: gold; }
    .modal-content p { font-size: clamp(0.8em, 3vw, 1em); margin-bottom: 20px; line-height: 1.5; }
    .modal-close-button, .modal-button { /* Shared button style */
        font-family: 'Press Start 2P', cursive; font-size: clamp(0.8em, 3vw, 1em);
        padding: 10px 20px; border-radius: 8px; border: 2px solid #aaa;
        background: #eee; color: #33; cursor: pointer; margin-top: 15px;
        display: inline-block; /* Allow multiple buttons */
        margin-left: 5px; margin-right: 5px;
    }
    .modal-button:disabled { opacity: 0.5; cursor: not-allowed; }


    /* Daily Login Modal Specifics */
    #daily-login-modal .modal-content { border-color: gold; }
    #daily-bonus-breakdown { list-style: none; padding: 0; margin: 15px 0; text-align: left; max-width: 250px; margin-left: auto; margin-right: auto; }
    #daily-bonus-breakdown li { font-size: clamp(0.7em, 2.5vw, 0.8em); margin-bottom: 5px; padding-left: 10px; border-left: 2px solid gold; }
    #daily-bonus-breakdown li.current-day { font-weight: bold; color: #FFD700; border-left-color: white; }

    /* Achievement Modal Specifics */
    #achievement-modal .modal-content { border-color: purple; }
    #achievement-list { list-style: none; padding: 0; margin: 0; }
    .achievement-item { background-color: #4a4a4a; padding: 10px; margin-bottom: 10px; border-radius: 8px; border: 1px solid #666; text-align: left; }
    .achievement-item.unlocked { border-color: gold; background-color: #5a5a4a; }
    .achievement-item h4 { font-size: clamp(0.8em, 2.8vw, 0.9em); margin-bottom: 5px; color: white; }
    .achievement-item p { font-size: clamp(0.7em, 2.3vw, 0.75em); margin-bottom: 5px; color: #ccc; }
    .achievement-item .status { font-size: clamp(0.6em, 2vw, 0.7em); font-weight: bold; float: right; }
    .achievement-item.unlocked .status { color: gold; }
    .achievement-item.locked .status { color: #888; }

    /* Settings Modal Specifics */
    #settings-modal .modal-content { border-color: silver; }
    #settings-modal .modal-content h2 { color: silver; }

    /* Ad Placeholder */
    #ad-placeholder {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0, 0, 0, 0.9); color: white; display: none;
      flex-direction: column; align-items: center; justify-content: center;
      z-index: 150; text-align: center; font-size: clamp(1.2em, 4vw, 1.5em); padding: 20px;
    }
     #ad-placeholder p { margin-bottom: 20px; }
     #ad-placeholder .spinner { border: 4px solid #f3f3f3; border-top: 4px solid #ffd700; border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; }
     @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

     /* Pause Button -- MOVED TO TOP-LEFT */
     #pause-button {
         position: absolute;
         top: 10px;
         left: 10px; /* Positioned top-left */
         z-index: 10;
         font-size: clamp(1.5em, 5vw, 2em);
         background: rgba(255, 255, 255, 0.5);
         color: #333;
         border: 2px solid rgba(0,0,0,0.2);
         border-radius: 50%;
         width: 40px;
         height: 40px;
         line-height: 36px;
         text-align: center;
         cursor: pointer;
         display: none; /* Hidden initially */
         box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
         transition: background-color 0.2s ease;
     }
      #pause-button:hover {
          background: rgba(255, 255, 255, 0.8);
      }

     /* Responsive Adjustments */
     @media (max-height: 450px) and (orientation: landscape) {
        .modal-content { padding: 10px 15px; }
        .modal-content h2 { font-size: 1em; }
        .modal-content p { font-size: 0.7em; margin-bottom: 10px;}
        .modal-close-button, .modal-button { font-size: 0.7em; padding: 6px 12px; }
        #daily-bonus-breakdown { margin: 10px auto; }
        #daily-bonus-breakdown li { font-size: 0.65em; }
        #pause-button { width: 35px; height: 35px; line-height: 31px; font-size: clamp(1.2em, 4vw, 1.7em); }
     }
     @media (max-width: 480px) {
         .modal-content { width: 95%; }
         #pause-button { width: 35px; height: 35px; line-height: 31px; font-size: clamp(1.2em, 4vw, 1.7em); }
     }
  </style>
</head>
<body>
  <div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="powerup-indicators">
      <span id="shield-indicator" class="indicator">🛡️</span>
      <span id="magnet-indicator" class="indicator">🧲</span>
      <span id="life-indicator" class="indicator">❤️</span>
    </div>
    <button id="pause-button">⏸️</button>

    <div id="mission-complete-popup">Mission Complete!</div>
    <div id="reward-popup">Reward!</div>
    <div id="level-up-popup">Level Up!</div>
    <div id="achievement-popup">Achievement Unlocked!</div>
    <div id="store-interface">
      <h2>Power-up Store</h2>
      <p>Your Coins: <span id="store-coin-balance">0</span> 🪙</p>
      <div class="store-section">
        <h3>Single Use Power-ups</h3>
        <div class="store-item">
          <h4>Shield (🛡️) - Cost: <span class="cost" data-item="shield">150</span> 🪙</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-shield">Buy Shield</button>
          <p>Owned: <span id="shield-owned">0</span></p>
        </div>
        <div class="store-item">
          <h4>Extra Life (❤️) - Cost: <span class="cost" data-item="life">200</span> 🪙</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-life">Buy Extra Life</button>
          <p>Owned: <span id="life-owned">0</span></p>
        </div>
        <div class="store-item">
          <h4>Coin Magnet (🧲) - Cost: <span class="cost" data-item="magnet">175</span> 🪙</h4>
          <p>Activates automatically next run!</p>
          <button id="buy-magnet">Buy Coin Magnet</button>
          <p>Owned: <span id="magnet-owned">0</span></p>
        </div>
      </div>
      <div class="store-section">
        <h3>Permanent Upgrades</h3>
        <div class="store-item">
          <h4>Magnet Duration</h4>
          <p>Increase Coin Magnet active time.</p>
          <p class="upgrade-level">Level: <span id="magnet-duration-level">0</span></p>
          <button id="upgrade-magnet-duration">Upgrade (Cost: <span id="magnet-duration-cost">0</span> 🪙)</button>
        </div>
        <div class="store-item">
          <h4>Starting Coins</h4>
          <p>Begin each run with extra coins.</p>
          <p class="upgrade-level">Level: <span id="start-coin-level">0</span></p>
          <button id="upgrade-start-coin">Upgrade (Cost: <span id="start-coin-cost">0</span> 🪙)</button>
        </div>
        <div class="store-item">
          <h4>Life Effectiveness</h4>
          <p>Clear more obstacles when using an Extra Life.</p>
          <p class="upgrade-level">Level: <span id="life-effectiveness-level">0</span></p>
          <button id="upgrade-life-effectiveness">Upgrade (Cost: <span id="life-effectiveness-cost">0</span> 🪙)</button>
        </div>
      </div>
      <div class="store-section">
        <h3>Extras</h3>
        <div class="store-item">
          <h4>Remove Ads (Simulation)</h4>
          <p>Permanently remove ads shown between runs.</p>
          <button id="buy-remove-ads">$5.00 Remove Ads</button>
          <p style="font-size: 0.7em; color: #ccc;">(Simulation Only - No Real Charge)</p>
          <p id="ads-removed-status" style="display: none; color: lime; margin-top: 5px;">Ads Removed!</p>
        </div>
      </div>
      <button id="close-store">Close Store</button>
    </div>
  </div>

  <div id="daily-login-modal" class="modal">
    <div class="modal-content">
      <h2 id="daily-login-title">Welcome Back!</h2>
      <p id="daily-login-message">Here's your daily reward!</p>
      <p style="font-size: 0.9em; margin-bottom: 5px; color: gold;">Consecutive Bonus:</p>
      <ul id="daily-bonus-breakdown"></ul>
      <button id="daily-login-close" class="modal-close-button">Claim & Close</button>
    </div>
  </div>

  <div id="achievement-modal" class="modal">
    <div class="modal-content">
      <h2>Achievements</h2>
      <ul id="achievement-list"></ul>
      <button id="achievement-close" class="modal-close-button">Close</button>
    </div>
  </div>

  <div id="settings-modal" class="modal">
      <div class="modal-content">
          <h2>Settings</h2>
          <button id="toggle-sound-button" class="modal-button">Sound: ON</button>
          <button id="resume-button" class="modal-button">Resume</button>
          </div>
  </div>

  <div id="ad-placeholder">
    <p>Loading Ad...</p>
    <div class="spinner"></div>
    <p style="font-size: 0.7em; margin-top: 15px;">(This is a placeholder)</p>
  </div>

  <script>
    /* Service worker script (unchanged) */
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('sw.js').then(registration => {
          console.log('SW registered: ', registration);
        }).catch(registrationError => {
          console.log('SW registration failed: ', registrationError);
        });
      });
    }

    // --- DOM Elements ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const storeInterface = document.getElementById('store-interface');
    const storeCoinBalance = document.getElementById('store-coin-balance');
    const buyShieldButton = document.getElementById('buy-shield');
    const buyLifeButton = document.getElementById('buy-life');
    const buyMagnetButton = document.getElementById('buy-magnet');
    const shieldOwnedDisplay = document.getElementById('shield-owned');
    const lifeOwnedDisplay = document.getElementById('life-owned');
    const magnetOwnedDisplay = document.getElementById('magnet-owned');
    const closeStoreButton = document.getElementById('close-store');
    const shieldIndicator = document.getElementById('shield-indicator');
    const magnetIndicator = document.getElementById('magnet-indicator');
    const lifeIndicator = document.getElementById('life-indicator');
    const gameContainer = document.getElementById('game-container');
    const missionCompletePopup = document.getElementById('mission-complete-popup');
    const rewardPopup = document.getElementById('reward-popup');
    const levelUpPopup = document.getElementById('level-up-popup');
    const achievementPopup = document.getElementById('achievement-popup');
    const dailyLoginModal = document.getElementById('daily-login-modal');
    const dailyLoginTitle = document.getElementById('daily-login-title');
    const dailyLoginMessage = document.getElementById('daily-login-message');
    const dailyBonusBreakdownList = document.getElementById('daily-bonus-breakdown'); // Added
    const dailyLoginCloseButton = document.getElementById('daily-login-close');
    const magnetDurationLevelDisplay = document.getElementById('magnet-duration-level');
    const magnetDurationCostDisplay = document.getElementById('magnet-duration-cost');
    const magnetDurationUpgradeButton = document.getElementById('upgrade-magnet-duration');
    const startCoinLevelDisplay = document.getElementById('start-coin-level');
    const startCoinCostDisplay = document.getElementById('start-coin-cost');
    const startCoinUpgradeButton = document.getElementById('upgrade-start-coin');
    const lifeEffectivenessLevelDisplay = document.getElementById('life-effectiveness-level');
    const lifeEffectivenessCostDisplay = document.getElementById('life-effectiveness-cost');
    const lifeEffectivenessUpgradeButton = document.getElementById('upgrade-life-effectiveness');
    const achievementModal = document.getElementById('achievement-modal');
    const achievementList = document.getElementById('achievement-list');
    const achievementCloseButton = document.getElementById('achievement-close');
    const adPlaceholder = document.getElementById('ad-placeholder');
    const buyRemoveAdsButton = document.getElementById('buy-remove-ads');
    const adsRemovedStatus = document.getElementById('ads-removed-status');
    // --- NEW: Pause/Settings Elements ---
    const pauseButton = document.getElementById('pause-button');
    const settingsModal = document.getElementById('settings-modal');
    const resumeButton = document.getElementById('resume-button');
    const toggleSoundButton = document.getElementById('toggle-sound-button');


    // --- Game Variables ---
    let score = 0; let highScore = 0; let coins = 0;
    let shieldsOwned = 0; let livesOwned = 0; let magnetsOwned = 0;
    const initialGameSpeed = 2.5; let gameSpeed = initialGameSpeed; let baseGameSpeed = initialGameSpeed;
    const speedIncrement = 0.3; let lastScoreThreshold = 0;
    let gravity = 0.35; const fastFallMultiplier = 3.5;
    let isGameOver = true; let isGameRunning = false; let animationFrameId;
    let obstacles = []; let coinObjects = []; let clouds = []; let mysteryBoxes = [];
    let frameCount = 0;
    let isShieldActive = false; let isMagnetActive = false; let magnetTimer = 0;
    let baseMagnetDuration = 600; let currentMagnetDuration = baseMagnetDuration;
    let extraLives = 0;
    let isInvincibleBoostActive = false; let invincibleBoostTimer = 0; const invincibleBoostDuration = 300;
    let isDoubleCoinsBoostActive = false; let doubleCoinsBoostTimer = 0; const doubleCoinsBoostDuration = 600;
    let isSpeedBoostActive = false; let speedBoostTimer = 0; const speedBoostAmount = 1.5;
    let isCoinRushActive = false; let coinRushTimer = 0; const coinRushDuration = 600;
    const coinRushChance = 0.0005; const coinRushMinScore = 500;
    let framesAfterReset = 0;
    let isNight = false;
    const dayBgColor = '#87CEEB'; const nightBgColor = '#2c3e50';
    const dayGroundColor = '#D2B48C'; const nightGroundColor = '#B08D57';
    const dayTextColor = '#333'; const nightTextColor = '#ecf0f1';
    const dayBodyBgColor = '#f0f0f0'; const nightBodyBgColor = '#34495e';
    const nightUiBg = '#4a5a6a'; const nightUiBorder = '#7f8c8d';
    let currentBgColor = dayBgColor;
    const missionPool = [ { id: 'score100', description: 'Reach Score 100', target: 100, reward: 15, type: 'score' }, { id: 'collect5', description: 'Collect 5 coins', target: 5, reward: 15, type: 'coins' }, { id: 'score300', description: 'Reach Score 300', target: 300, reward: 30, type: 'score' }, { id: 'jump5cacti', description: 'Jump over 5 cacti', target: 5, reward: 35, type: 'jump_cactus' }, { id: 'collect15', description: 'Collect 15 coins', target: 15, reward: 40, type: 'coins' }, { id: 'score750', description: 'Reach Score 750', target: 750, reward: 75, type: 'score' }, { id: 'duck3birds', description: 'Duck under 3 birds', target: 3, reward: 45, type: 'duck_bird' }, { id: 'collect30', description: 'Collect 30 coins', target: 30, reward: 80, type: 'coins' }, ];
    let activeMission = null; let missionProgress = 0;
    let coinsCollectedThisRun = 0; let cactiJumpedThisRun = 0; let birdsDuckedThisRun = 0;
    let missionNotificationText = ""; let missionNotificationTimer = 0; const missionNotificationDuration = 180;
    const shieldCost = 150; const lifeCost = 200; const magnetCost = 175;
    let playerXP = 0; let playerLevel = 1;
    const xpPerScorePoint = 0.1;
    function xpForLevelUp(level) { return Math.floor(100 * Math.pow(level, 1.5)); }
    let magnetDurationUpgradeLevel = 0; let startCoinUpgradeLevel = 0; let lifeEffectivenessUpgradeLevel = 0;
    const baseMagnetDurationCost = 150; const baseStartCoinCost = 200; const baseLifeEffectivenessCost = 250;
    const magnetMaxLevel = 10; const startCoinMaxLevel = 10; const lifeEffectMaxLevel = 5;
    let totalDistanceRun = 0; let totalCoinsCollected = 0; let totalCactiJumped = 0;
    let totalBirdsDucked = 0; let totalShieldsUsed = 0; let totalNightsSurvived = 0;
    let runCount = 0; let adsRemoved = false; let adDisplayPending = false;
    let jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth;
    let levelUpSynth, achievementSynth;
    let audioReady = false;
    let touchStartX = 0; let touchStartY = 0; let touchStartTime = 0; let isSwiping = false;
    const minSwipeYDistance = 50; const maxSwipeXDistance = 50; const maxTapTime = 250;
    let storeButtonBounds = null; let achievementButtonBounds = null;
    const groundHeight = 50;
    let currentDPR = 1;

    // --- NEW: Pause State ---
    let isPaused = false;
    let isSoundMuted = false; // Sound state

    // --- Daily Play Log ---
    let dailyPlayLog = [];

    // --- Llama Object (Restored llama.draw) ---
    const llama = {
        x: 50, y: 0, drawWidth: 56, drawHeight: 56, width: 50, height: 52, dy: 0,
        jumpPower: -11, isJumping: false, isDucking: false, duckHeight: 30, baseY: 0,
        runFrame: 0, runAnimationSpeed: 6,
        // --- Llama Drawing (Restored from initial code) ---
        draw() {
            const bodyHigh='#F5E5D0', bodyLight='#EAD8BF', bodyMain='#D8B898', bodyShade='#B89878';
            const legMain='#A08060', legShade='#806040', hoof='#604030';
            const faceMain='#F0D0B0', earInner='#E0C0A0', eyeWhite='#FFFFFF', eyePupil='#000000', nose='#705040', hair='#907050';
            const p = 2; // Pixel scale factor

            ctx.save();
            ctx.translate(Math.round(this.x), Math.round(this.y));

            let scaleY = 1;
            let duckOffsetY = 0;
            if (this.isDucking) {
                scaleY = 0.75;
                duckOffsetY = this.drawHeight * (1 - scaleY);
                ctx.translate(0, duckOffsetY);
                ctx.scale(1, scaleY);
            }

            // Llama Body
            ctx.fillStyle=bodyMain; ctx.fillRect(p*4, p*4, p*18, p*14);
            ctx.fillStyle=bodyShade; ctx.fillRect(p*5, p*15, p*16, p*3);
            ctx.fillStyle=bodyLight; ctx.fillRect(p*5, p*4, p*16, p*3); ctx.fillRect(p*4, p*6, p*2, p*10); ctx.fillRect(p*3, p*8, p*1, p*6);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*2, p*7, p*2, p*8);
            ctx.fillStyle=hair; ctx.fillRect(p*0, p*10, p*4, p*4); ctx.fillRect(p*-1, p*11, p*2, p*2);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*16, p*-1, p*6, p*8);
            ctx.fillStyle=bodyShade; ctx.fillRect(p*16, p*5, p*5, p*2);
            ctx.fillStyle=hair; ctx.fillRect(p*15, p*-4, p*7, p*5); ctx.fillRect(p*17, p*-6, p*3, p*2); ctx.fillRect(p*14, p*-1, p*3, p*3);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-9, p*9, p*10);
            ctx.fillStyle=faceMain; ctx.fillRect(p*26, p*-6, p*4, p*6);
            ctx.fillStyle=nose; ctx.fillRect(p*28, p*-3, p*2, p*1); ctx.fillRect(p*27, p*0, p*3, p*1);
            ctx.fillStyle=eyeWhite; ctx.fillRect(p*23, p*-5, p*2, p*2);
            ctx.fillStyle=eyePupil; ctx.fillRect(p*24, p*-4, p*1, p*1);
            ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-13, p*3, p*5); ctx.fillRect(p*23, p*-13, p*3, p*5);
            ctx.fillStyle=earInner; ctx.fillRect(p*20, p*-12, p*1, p*3); ctx.fillRect(p*24, p*-12, p*1, p*3);

            // Legs
            const currentRunFrame = Math.floor(this.runFrame / this.runAnimationSpeed) % 2;
            const upperLegW=p*3, upperLegH=p*5, lowerLegW=p*3, lowerLegH=p*4, hoofH=p*2;
            const frontUpperX=p*6, frontUpperY=p*17;
            const backUpperX=p*14, backUpperY=p*17;

            if (this.isJumping) { // Jumping legs
                ctx.fillStyle=legShade; ctx.fillRect(frontUpperX-p*1,frontUpperY,upperLegW,upperLegH+lowerLegH);
                ctx.fillStyle=legMain; ctx.fillRect(frontUpperX-p*1+p,frontUpperY,upperLegW-p*2,upperLegH+lowerLegH);
                ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*1,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                ctx.fillStyle=legShade; ctx.fillRect(backUpperX-p*1,backUpperY,upperLegW,upperLegH+lowerLegH);
                ctx.fillStyle=legMain; ctx.fillRect(backUpperX-p*1+p,backUpperY,upperLegW-p*2,upperLegH+lowerLegH);
                ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*1,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
            } else if (this.isDucking) { // Ducking legs (shortened)
                const duckLegH=p*4; const duckHoofY=frontUpperY+duckLegH;
                ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,duckLegH);
                ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,duckLegH);
                ctx.fillStyle=hoof; ctx.fillRect(frontUpperX,duckHoofY,upperLegW,hoofH);
                ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,duckLegH);
                ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,duckLegH);
                ctx.fillStyle=hoof; ctx.fillRect(backUpperX,duckHoofY,upperLegW,hoofH);
            } else { // Running legs animation
                if(currentRunFrame === 0) {
                    ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX+p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                    ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX-p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                } else {
                    ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX-p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                    ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH,lowerLegW,lowerLegH);
                    ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX+p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH);
                    ctx.fillStyle=hoof; ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH);
                }
            }

            // Powerup Effects
            if (isInvincibleBoostActive) {
                ctx.strokeStyle = `rgba(255, 255, 0, ${0.5 + Math.sin(frameCount * 0.3) * 0.3})`;
                ctx.lineWidth = 3 + Math.sin(frameCount * 0.4) * 1.5;
                ctx.beginPath();
                let hitboxVisualY = this.isDucking ? duckOffsetY : 0;
                let hitboxDrawHeight = this.height * scaleY;
                let hitboxDrawWidth = this.width;
                let radiusX = (hitboxDrawWidth / 2) + 6 + Math.sin(frameCount * 0.2) * 3;
                let radiusY = (hitboxDrawHeight / 2) + 6 + Math.sin(frameCount * 0.2) * 3;
                ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 );
                ctx.stroke();
            } else if (isShieldActive) {
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)';
                ctx.lineWidth = 2 + Math.sin(frameCount * 0.2) * 1;
                ctx.beginPath();
                let hitboxVisualY = this.isDucking ? duckOffsetY : 0;
                let hitboxDrawHeight = this.height * scaleY;
                let hitboxDrawWidth = this.width;
                let radiusX = (hitboxDrawWidth / 2) + 4 + Math.sin(frameCount * 0.15) * 2;
                let radiusY = (hitboxDrawHeight / 2) + 4 + Math.sin(frameCount * 0.15) * 2;
                ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 );
                ctx.setLineDash([10, 5]);
                ctx.lineDashOffset = frameCount * -1.5;
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.lineDashOffset = 0;
            }
            ctx.restore();
        },
        update() { let appliedGravity = gravity; const airborne = this.y < this.baseY || this.dy > 0; if (airborne && this.isDucking) { appliedGravity *= fastFallMultiplier; } if (this.y < this.baseY || this.dy < 0) { this.dy += appliedGravity; } else { this.dy = 0; this.y = this.baseY; if (this.isJumping) { this.isJumping = false;} } this.y += this.dy; if (this.y > this.baseY) { this.y = this.baseY; this.dy = 0; if (this.isJumping) { this.isJumping = false; } } if (!this.isJumping && !this.isDucking && this.y >= this.baseY) { this.runFrame++; } else if (!this.isJumping && this.y >= this.baseY) { this.runFrame = 0; } else { this.runFrame = 0; } },
        jump() { if (isGameRunning && !this.isJumping && !this.isDucking && this.y >= this.baseY) { this.dy = this.jumpPower; this.isJumping = true; this.isDucking = false; if(!isSoundMuted && audioReady) jumpSynth?.triggerAttackRelease("F#5", "16n"); } },
        duck(shouldDuck) { if (isGameRunning) { if(shouldDuck && this.isJumping) return; this.isDucking = shouldDuck; } else { this.isDucking = false; } },
        reset() { const canvasH = canvas.height / currentDPR; this.baseY = canvasH - groundHeight - this.height; this.y = this.baseY; this.dy = 0; this.isJumping = false; this.isDucking = false; this.runFrame = 0; console.log(`Llama reset. CanvasH: ${canvasH.toFixed(2)}, Ground: ${groundHeight}, LlamaH: ${this.height}, BaseY: ${this.baseY.toFixed(2)}`); if (this.baseY < 0 || this.baseY > canvasH) { console.warn(`Llama baseY (${this.baseY.toFixed(2)}) might be outside canvas height (${canvasH.toFixed(2)})`); } }
    };

    // --- Obstacle Class ---
    class Obstacle { constructor(x, y, width, height, type) { this.x = x; this.y = y; this.width = width; this.height = height; this.type = type; } draw() { if (this.type === 'cactus') { const p = 2; const mainColor='#2E8B57', darkColor='#228B22', lightColor='#3CB371', spineColor='#1A4D2E'; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); const conceptualHeight = this.height / p; const conceptualWidth = this.width / p; const segmentHeight = Math.max(2, Math.floor(conceptualHeight / 5)); for (let i_concept = 0; i_concept < conceptualHeight; i_concept += 1) { const i_draw = i_concept * p; const segmentIndex = Math.floor(i_concept / segmentHeight); const currentMain = (segmentIndex % 2 === 0) ? mainColor : lightColor; const currentDark = (segmentIndex % 2 === 0) ? darkColor : mainColor; const currentLight = (segmentIndex % 2 === 0) ? lightColor : '#54C581'; ctx.fillStyle = currentMain; ctx.fillRect(p * 2, i_draw, conceptualWidth*p - p * 4, p); ctx.fillStyle = currentDark; ctx.fillRect(p * 2, i_draw, p * 1, p); ctx.fillRect(conceptualWidth*p - p * 3, i_draw, p * 1, p); ctx.fillStyle = currentLight; ctx.fillRect(p * 3, i_draw, p * (conceptualWidth > 4 ? 2 : 1), p); } ctx.fillStyle = darkColor; ctx.fillRect(p * 2, this.height - p * 2, conceptualWidth*p - p * 4, p * 2); const armW_concept = Math.max(3, Math.floor(conceptualWidth * 0.4)); const armH_concept = Math.max(5, Math.floor(conceptualHeight * 0.5)); const armLX_concept = 2 - armW_concept; const armLY_concept = conceptualHeight * 0.3; ctx.fillStyle = mainColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, p, armH_concept*p); ctx.fillRect((armLX_concept+armW_concept)*p-p, armLY_concept*p, p, armH_concept*p); ctx.fillRect(armLX_concept*p, (armLY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armLX_concept+1)*p, armLY_concept*p, (armW_concept-2)*p, p); const armRX_concept = conceptualWidth - 2; const armRY_concept = conceptualHeight * 0.15; ctx.fillStyle = mainColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, p, armH_concept*p); ctx.fillRect((armRX_concept+armW_concept)*p-p, armRY_concept*p, p, armH_concept*p); ctx.fillRect(armRX_concept*p, (armRY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armRX_concept+1)*p, armRY_concept*p, (armW_concept-2)*p, p); ctx.fillStyle = spineColor; for(let i = 0; i < conceptualHeight / 2; i++) { ctx.fillRect(p*2 + Math.random()*(this.width-p*4), Math.random()*this.height, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armLX_concept*p + Math.random()*armW_concept*p, armLY_concept*p + Math.random()*armH_concept*p, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armRX_concept*p + Math.random()*armW_concept*p, armRY_concept*p + Math.random()*armH_concept*p, p/2, p/2); } ctx.restore(); } else if (this.type === 'bird') { const p_bird = 2; const cs = { bodyLight: '#FFDAB9', bodyMain: '#FFA500', bodyDark: '#CD853F', wingHigh: '#FFF8DC', wingLight: '#FFE4B5', wingMain: '#FFDEAD', beak: '#A0522D', eye: '#000000', eyeWhite: '#FFFFFF' }; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*8); ctx.fillStyle = cs.bodyLight; ctx.fillRect(p_bird*6, p_bird*8, p_bird*10, p_bird*4); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*2); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*5); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*1); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*6); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*1); ctx.fillStyle = cs.beak; ctx.fillRect(p_bird*-3, p_bird*3, p_bird*4, p_bird*2); ctx.fillRect(p_bird*-2, p_bird*4, p_bird*2, p_bird*1); ctx.fillStyle = cs.eyeWhite; ctx.fillRect(p_bird*2, p_bird*3, p_bird*3, p_bird*3); ctx.fillStyle = cs.eye; ctx.fillRect(p_bird*3, p_bird*4, p_bird*1, p_bird*1); const flap = Math.sin(frameCount * 0.4) * p_bird * 5; ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*5); ctx.lineTo(p_bird*10, p_bird*-1 + flap); ctx.lineTo(p_bird*8, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*5); ctx.lineTo(p_bird*10, p_bird*1 + flap); ctx.lineTo(p_bird*9, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*5); ctx.lineTo(p_bird*10, p_bird*2 + flap); ctx.lineTo(p_bird*9.5, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*10); ctx.lineTo(p_bird*10, p_bird*14 - flap); ctx.lineTo(p_bird*8, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*10); ctx.lineTo(p_bird*10, p_bird*13 - flap); ctx.lineTo(p_bird*9, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*10); ctx.lineTo(p_bird*10, p_bird*12 - flap); ctx.lineTo(p_bird*9.5, p_bird*9); ctx.closePath(); ctx.fill(); ctx.restore(); } } update() { this.x -= gameSpeed; } }
    class Cloud { constructor(x, y, width, height, speed) { this.x = x; this.y = y; this.width = width; this.height = height; this.speed = speed; } draw() { const p = 1; const c1='#FFFFFF', c2='#F0F8FF', c3='#E0E8EF'; ctx.save(); ctx.globalAlpha = 0.8; ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle=c1; ctx.fillRect(0, p*5, this.width, this.height - p*5); ctx.beginPath(); ctx.arc(this.width * 0.25, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.arc(this.width * 0.75, p*5, this.width * 0.25, Math.PI, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.fillStyle = c2; ctx.fillRect(this.width * 0.1, this.height - p*5, this.width*0.8, p*5); ctx.restore(); } update() { this.x -= this.speed; } }
    class Coin { constructor(x,y,r){ this.x=x; this.y=y; this.radius=r; this.collected=false; } draw() { if (!this.collected) { const bob = Math.sin(frameCount * 0.1 + this.x * 0.05) * 3; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const centerX = drawX + this.radius; const centerY = drawY + this.radius; const outlineColor = '#B8860B'; const mainColor = '#FFD700'; const shadowColor = '#DAA520'; const highlightColor = '#FFFFE0'; ctx.save(); ctx.translate(centerX, centerY); ctx.fillStyle = outlineColor; ctx.beginPath(); ctx.arc(0, 0, this.radius + 1, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = mainColor; ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = shadowColor; ctx.beginPath(); ctx.arc(0, 0, this.radius * 0.7, 0, Math.PI * 2); ctx.fill(); ctx.fillStyle = highlightColor; ctx.beginPath(); ctx.arc(-this.radius * 0.3, -this.radius * 0.3, this.radius * 0.4, Math.PI * 1.2, Math.PI * 1.9); ctx.fill(); ctx.restore(); } } update(){ this.x-=gameSpeed; } }
    class MysteryBox { constructor(x, y, size) { this.x = x; this.y = y; this.width = size; this.height = size; this.collected = false; this.openTimer = 0; this.openDuration = 30; this.bobOffset = Math.random() * Math.PI * 2; } draw() { const bob = Math.sin(frameCount * 0.08 + this.bobOffset) * 4; const drawX = Math.round(this.x); const drawY = Math.round(this.y + bob); const size = this.width; ctx.save(); ctx.translate(drawX, drawY); if (this.collected && this.openTimer > 0) { const progress = 1 - (this.openTimer / this.openDuration); const spinAngle = progress * Math.PI * 2; const scale = 1 + progress * 0.5; const alpha = 1 - progress; ctx.globalAlpha = alpha; ctx.translate(size / 2, size / 2); ctx.rotate(spinAngle); ctx.scale(scale, scale); ctx.translate(-size / 2, -size / 2); ctx.fillStyle = '#c0c0c0'; ctx.fillRect(0, 0, size, size); ctx.fillStyle = '#ffd700'; ctx.fillRect(size * 0.3, size * 0.2, size * 0.4, size * 0.6); } else if (!this.collected) { const p = Math.max(2, Math.floor(size / 10)); const mainColor = '#a0522d'; const bandColor = '#ffd700'; const shadowColor = '#8b4513'; const rivetColor = '#c0c0c0'; ctx.fillStyle = mainColor; ctx.fillRect(0, 0, size, size); ctx.fillStyle = shadowColor; ctx.fillRect(0, size - p, size, p); ctx.fillRect(size - p, 0, p, size); ctx.fillStyle = bandColor; ctx.fillRect(0, size * 0.4, size, size * 0.2); ctx.fillRect(size * 0.4, 0, size * 0.2, size); ctx.fillStyle = rivetColor; ctx.fillRect(p, p, p, p); ctx.fillRect(size - p * 2, p, p, p); ctx.fillRect(p, size - p * 2, p, p); ctx.fillRect(size - p * 2, size - p * 2, p, p); ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.sin(frameCount * 0.15) * 0.3})`; ctx.font = `bold ${size * 0.6}px "Press Start 2P"`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText("?", size / 2, size / 2 + p); } ctx.restore(); } update() { this.x -= gameSpeed; if (this.collected && this.openTimer > 0) { this.openTimer--; } } collect() { if (!this.collected) { this.collected = true; this.openTimer = this.openDuration; if(!isSoundMuted && audioReady) mysteryCollectSynth?.triggerAttackRelease("C5", "8n", Tone.now()); setTimeout(() => grantMysteryReward(this), 100); } } }

    // --- Utility Functions ---
    function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }
    function showPopup(element, message, duration = 2000) { element.textContent = message; element.style.display = 'block'; requestAnimationFrame(() => { element.style.opacity = 1; }); setTimeout(() => { element.style.opacity = 0; setTimeout(() => { element.style.display = 'none'; }, 500); }, duration); }
    function getCurrentDateString() { return new Date().toISOString().split('T')[0]; }

    // --- Achievement Definitions & Handling ---
    let achievements = [ { id: 'score_500', name: "Getting Started", description: "Reach a score of 500 points in a single run.", type: 'score', target: 500, reward: 25, unlocked: false }, { id: 'score_1500', name: "Pro Runner", description: "Reach a score of 1500 points in a single run.", type: 'score', target: 1500, reward: 75, unlocked: false }, { id: 'high_score_1000', name: "High Scorer", description: "Achieve a lifetime high score over 1000.", type: 'highScore', target: 1000, reward: 100, unlocked: false }, { id: 'coins_run_50', name: "Coin Collector", description: "Collect 50 coins in a single run.", type: 'coinsRun', target: 50, reward: 30, unlocked: false }, { id: 'coins_total_1000', name: "Coin Hoarder", description: "Collect 1000 coins across all runs.", type: 'totalCoins', target: 1000, reward: 100, unlocked: false }, { id: 'jump_total_100', name: "Frequent Flyer", description: "Jump over 100 cacti in total.", type: 'totalJumpCactus', target: 100, reward: 50, unlocked: false }, { id: 'duck_total_50', name: "Limbo Master", description: "Duck under 50 birds in total.", type: 'totalDuckBird', target: 50, reward: 50, unlocked: false }, { id: 'use_shield_10', name: "Shield User", description: "Successfully use 10 shields.", type: 'totalShieldsUsed', target: 10, reward: 40, unlocked: false }, { id: 'survive_night_1', name: "Night Owl", description: "Survive through a full night cycle (score ~700).", type: 'surviveNight', target: 1, reward: 60, unlocked: false }, { id: 'level_5', name: "Level 5 Reached", description: "Reach Player Level 5.", type: 'level', target: 5, reward: 50, unlocked: false }, { id: 'level_10', name: "Level 10 Reached", description: "Reach Player Level 10.", type: 'level', target: 10, reward: 150, unlocked: false }, ];
    function loadAchievements() { const savedAchievements = localStorage.getItem('llamaAchievements'); if (savedAchievements) { try { const loaded = JSON.parse(savedAchievements); achievements = achievements.map(def => { const saved = loaded.find(s => s.id === def.id); return { ...def, unlocked: saved ? saved.unlocked : false }; }); } catch (e) { console.error("Failed to parse saved achievements:", e); } } totalDistanceRun = parseInt(localStorage.getItem('llamaTotalDistance') || 0); totalCoinsCollected = parseInt(localStorage.getItem('llamaTotalCoinsCollected') || coins); totalCactiJumped = parseInt(localStorage.getItem('llamaTotalCactiJumped') || 0); totalBirdsDucked = parseInt(localStorage.getItem('llamaTotalBirdsDucked') || 0); totalShieldsUsed = parseInt(localStorage.getItem('llamaTotalShieldsUsed') || 0); totalNightsSurvived = parseInt(localStorage.getItem('llamaTotalNightsSurvived') || 0); }
    function saveAchievements() { try { const stateToSave = achievements.map(a => ({ id: a.id, unlocked: a.unlocked })); localStorage.setItem('llamaAchievements', JSON.stringify(stateToSave)); localStorage.setItem('llamaTotalDistance', totalDistanceRun); localStorage.setItem('llamaTotalCoinsCollected', totalCoinsCollected); localStorage.setItem('llamaTotalCactiJumped', totalCactiJumped); localStorage.setItem('llamaTotalBirdsDucked', totalBirdsDucked); localStorage.setItem('llamaTotalShieldsUsed', totalShieldsUsed); localStorage.setItem('llamaTotalNightsSurvived', totalNightsSurvived); } catch (e) { console.error("Failed to save achievements:", e); } }
    function checkAchievements(checkDuringRun = false) { let newUnlock = false; let nightSurvivedThisRun = isNight; achievements.forEach(ach => { if (!ach.unlocked) { let criteriaMet = false; switch (ach.type) { case 'score': criteriaMet = !checkDuringRun && score >= ach.target; break; case 'highScore': criteriaMet = !checkDuringRun && highScore >= ach.target; break; case 'coinsRun': criteriaMet = !checkDuringRun && coinsCollectedThisRun >= ach.target; break; case 'totalCoins': criteriaMet = totalCoinsCollected >= ach.target; break; case 'totalJumpCactus': criteriaMet = totalCactiJumped >= ach.target; break; case 'totalDuckBird': criteriaMet = totalBirdsDucked >= ach.target; break; case 'totalShieldsUsed': criteriaMet = totalShieldsUsed >= ach.target; break; case 'surviveNight': criteriaMet = !checkDuringRun && nightSurvivedThisRun; break; case 'level': criteriaMet = playerLevel >= ach.target; break; } if (criteriaMet) { ach.unlocked = true; newUnlock = true; coins += ach.reward; showPopup(achievementPopup, `Achievement Unlocked!\n${ach.name}\n+${ach.reward} Coins!`, 3000); if(!isSoundMuted && audioReady) achievementSynth?.triggerAttackRelease("C4", "1n"); console.log(`Achievement unlocked: ${ach.name}`); } } }); if (newUnlock) { saveAchievements(); updateDisplays(); } }
    function populateAchievementModal() { achievementList.innerHTML = ''; achievements.forEach(ach => { const li = document.createElement('li'); li.classList.add('achievement-item'); li.classList.toggle('unlocked', ach.unlocked); li.classList.toggle('locked', !ach.unlocked); const status = ach.unlocked ? 'Unlocked' : 'Locked'; let progressText = ''; if (!ach.unlocked) { if (ach.type === 'totalCoins') progressText = ` (${totalCoinsCollected}/${ach.target})`; else if (ach.type === 'totalJumpCactus') progressText = ` (${totalCactiJumped}/${ach.target})`; else if (ach.type === 'totalDuckBird') progressText = ` (${totalBirdsDucked}/${ach.target})`; else if (ach.type === 'totalShieldsUsed') progressText = ` (${totalShieldsUsed}/${ach.target})`; else if (ach.type === 'level') progressText = ` (Lv ${playerLevel}/${ach.target})`; } li.innerHTML = ` <span class="status">[${status}]</span> <h4>${ach.name}</h4> <p>${ach.description}${progressText}</p> ${ach.unlocked ? `<p>Reward: ${ach.reward} 🪙</p>` : ''} `; achievementList.appendChild(li); }); }

    // --- Audio Setup ---
    function setupAudio() { if (audioReady) return; try { [jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth, mysteryAppearSynth, mysteryCollectSynth, rewardSynth, dailyBonusSynth, coinRushSynth, levelUpSynth, achievementSynth].forEach(synth => { if (synth && typeof synth.dispose === 'function') { synth.dispose(); } }); jumpSynth = new Tone.Synth({ oscillator: { type: "square" }, volume: -8, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination(); coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 3, volume: -6, envelope: { attack: 0.001, decay: 0.2, sustain: 0.01, release: 0.4, attackCurve: "exponential" } }).toDestination(); uiClickSynth = new Tone.Synth({ volume: -15, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 } }).toDestination(); missionSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); mysteryAppearSynth = new Tone.Synth({ oscillator: { type: "pulse", width: 0.6 }, volume: -12, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.3 } }).toDestination(); mysteryCollectSynth = new Tone.Synth({ oscillator: { type: "fmtriangle", modulationType: "sine", harmonicity: 1.5 }, volume: -9, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.2 } }).toDestination(); rewardSynth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: "triangle" }, volume: -7, envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.3 } }).toDestination(); dailyBonusSynth = new Tone.Synth({ oscillator: { type: "fatsawtooth", count: 3, spread: 20 }, volume: -6, envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.4 } }).toDestination(); coinRushSynth = new Tone.NoiseSynth({ noise: { type: "pink" }, volume: -10, envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 0.1 } }).toDestination(); levelUpSynth = new Tone.Synth({ oscillator: { type: "fatsquare", count: 4, spread: 30 }, volume: -5, envelope: { attack: 0.05, decay: 0.5, sustain: 0.3, release: 0.6 } }).toDestination(); achievementSynth = new Tone.Synth({ oscillator: { type: "pwm", modulationFrequency: 0.5 }, volume: -7, envelope: { attack: 0.02, decay: 0.6, sustain: 0.2, release: 0.5 } }).toDestination();
        // Apply initial mute state
        if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; }
        audioReady = true; console.log("Audio ready."); } catch (err) { console.error("Error setting up audio:", err); audioReady = false; } }

    // --- Game Functions ---
    function setBackground(isNightTime) { currentBgColor = isNightTime ? nightBgColor : dayBgColor; const bodyBg = isNightTime ? nightBodyBgColor : dayBodyBgColor; gameContainer.style.backgroundColor = currentBgColor; document.body.style.backgroundColor = bodyBg; document.querySelector('meta[name="theme-color"]').setAttribute('content', isNightTime ? nightBgColor : dayBgColor); }
    function drawStars() { if(!isNight)return; ctx.fillStyle='white'; for(let i=0;i<50;i++){ let x=(Math.random()*canvas.width/currentDPR*1.5 - frameCount*0.1)%(canvas.width/currentDPR); if(x<0)x+=(canvas.width/currentDPR); let y=Math.random()*canvas.height/currentDPR*0.7; let size=Math.random()>0.8?2:1; ctx.globalAlpha=0.5+Math.sin(frameCount*0.05+i)*0.5; ctx.fillRect(Math.round(x),Math.round(y),size,size);} ctx.globalAlpha=1.0; }
    function resizeCanvas() { const container = document.getElementById('game-container'); if (!container || !canvas) return; currentDPR = window.devicePixelRatio || 1; const rect = container.getBoundingClientRect(); canvas.width = rect.width * currentDPR; canvas.height = rect.height * currentDPR; canvas.style.width = `${rect.width}px`; canvas.style.height = `${rect.height}px`; ctx.scale(currentDPR, currentDPR); const logicalWidth = canvas.width / currentDPR; const logicalHeight = canvas.height / currentDPR; llama.reset(); drawGround(); setBackground(isNight); console.log(`Canvas resized. Logical: ${logicalWidth.toFixed(0)}x${logicalHeight.toFixed(0)}, Physical: ${canvas.width}x${canvas.height}, DPR: ${currentDPR}`); if (isGameOver || !isGameRunning) { requestAnimationFrame(gameLoop); } }
    function drawGround() { if (!ctx) return; const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; ctx.fillStyle = isNight ? nightGroundColor : dayGroundColor; ctx.fillRect(0, canvasH - groundHeight, canvasW, groundHeight); ctx.fillStyle = isNight ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.1)'; const lineOffset = Math.floor(frameCount * gameSpeed) % 20; for(let i = -lineOffset; i < canvasW; i+=20){ ctx.fillRect(i, canvasH - groundHeight + 5, 2, groundHeight - 10); } }
    function spawnCloud() { const spawnChance=0.003; if(Math.random()<spawnChance){ const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; const cw=getRandomInt(80,140); const ch=getRandomInt(40,70); const cy=Math.random()*(canvasH * 0.3); const cs=gameSpeed*(0.05+Math.random()*0.1); clouds.push(new Cloud(canvasW, cy, cw, ch, cs)); } }
    function updateClouds() { for(let i=clouds.length-1;i>=0;i--){ clouds[i].update(); clouds[i].draw(); if(clouds[i].x+clouds[i].width<0){ clouds.splice(i,1);}} }
    function spawnObstacle() { if (!isGameRunning || isPaused || isCoinRushActive) return; const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; const speedFactor = Math.max(0.5, 1 - (gameSpeed / 25)); const baseMinGap = 190; const randomGapAdd = 230; const absoluteMinGap = 140; const minGap = (baseMinGap + Math.random() * randomGapAdd) * speedFactor + absoluteMinGap; const lastObstacle = obstacles[obstacles.length - 1]; if (!lastObstacle || (canvasW - (lastObstacle.x + lastObstacle.width)) > minGap) { const type = Math.random() < 0.6 ? 'cactus' : 'bird'; let obstacle; if (type === 'cactus') { const cactusHeight = 46 + Math.random() * 30; const cactusWidth = 30 + Math.random() * 10; obstacle = new Obstacle( canvasW, canvasH - groundHeight - cactusHeight, cactusWidth, cactusHeight, 'cactus' ); } else { const birdHitboxWidth = 40; const birdHitboxHeight = 30; const clearance = 5; const birdY = canvasH - groundHeight - llama.duckHeight - birdHitboxHeight - clearance; obstacle = new Obstacle( canvasW, birdY, birdHitboxWidth, birdHitboxHeight, 'bird' ); } obstacles.push(obstacle); } }
    function spawnCoin() { if (!isGameRunning || isPaused) return; const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; let chance = 0.02; const minGap = 80; const lastCoin = coinObjects[coinObjects.length - 1]; const spawnX = canvasW; if (isCoinRushActive) { chance = 0.25; if (Math.random() < chance) { const numCoins = getRandomInt(2, 4); let startX = spawnX; if (lastCoin && (spawnX - (lastCoin.x + lastCoin.radius * 2)) < minGap * 0.5) { startX = lastCoin.x + lastCoin.radius * 2 + minGap * 0.5; } for (let i = 0; i < numCoins; i++) { const r = 10; const y = canvasH - groundHeight - r*2 - 5 - Math.random() * (llama.height * 1.2); coinObjects.push(new Coin(startX + i * (r * 2.5), Math.max(y, r*2), r)); } } return; } if (Math.random() < chance) { if (!lastCoin || (spawnX - (lastCoin.x + lastCoin.radius * 2)) > minGap) { const r = 10; const rf = Math.random(); let y; if (rf < 0.5) { y = canvasH - groundHeight - r*2 - 5; } else { const baseJumpHeight = canvasH - groundHeight - r*2 - (llama.height * 0.6); y = baseJumpHeight - Math.random()*(llama.height*0.7); } coinObjects.push(new Coin(spawnX, Math.max(y, r*2), r)); } } }
    // --- MODIFIED: spawnMysteryBox (Reduced Chance) ---
    function spawnMysteryBox() {
        if (!isGameRunning || isPaused || isCoinRushActive) return;
        const canvasW = canvas.width / currentDPR;
        const canvasH = canvas.height / currentDPR;
        const chance = 0.0004; // <<< REDUCED CHANCE
        const minGap = 400;
        const obstacleSafetyMargin = 50;
        const spawnX = canvasW;
        const lastBox = mysteryBoxes[mysteryBoxes.length - 1];

        if (Math.random() < chance) {
            const boxGapOk = !lastBox || (spawnX - (lastBox.x + lastBox.width)) > minGap;
            if (boxGapOk) {
                const size = 35;
                let y;
                if (Math.random() < 0.5) { y = canvasH - groundHeight - size - 5; }
                else { y = canvasH - groundHeight - size - (llama.height * 0.7) - Math.random() * (llama.height * 0.6); }
                y = Math.max(size, y);
                let cactusOverlap = false;
                for (const obs of obstacles) {
                    if (obs.type === 'cactus') {
                        const obsRightEdge = obs.x + obs.width;
                        const safetyDistance = size + obs.width + obstacleSafetyMargin;
                        if (obs.x < spawnX + size + obstacleSafetyMargin && obsRightEdge > spawnX - obstacleSafetyMargin) {
                            const boxBottom = y + size; const obsBottom = obs.y + obs.height;
                            if (y < obsBottom && boxBottom > obs.y) {
                                cactusOverlap = true;
                                console.log("Mystery box spawn skipped due to cactus overlap.");
                                break;
                            }
                        }
                    }
                }
                if (!cactusOverlap) {
                    mysteryBoxes.push(new MysteryBox(spawnX, y, size));
                    if (!isSoundMuted && audioReady) mysteryAppearSynth?.triggerAttackRelease("A4", "8n");
                }
            }
        }
    }
    function updateObstacles() { for (let i=obstacles.length-1; i>=0; i--) { const obs = obstacles[i]; if (!obs) continue; const wasBehindLlama = obs.x + obs.width < llama.x; obs.update(); obs.draw(); const isNowBehindLlama = obs.x + obs.width < llama.x; if (!wasBehindLlama && isNowBehindLlama && !isGameOver) { if (obs.type === 'cactus' && llama.isJumping) { cactiJumpedThisRun++; totalCactiJumped++; updateMissionProgress('jump_cactus', cactiJumpedThisRun); } else if (obs.type === 'bird' && llama.isDucking) { birdsDuckedThisRun++; totalBirdsDucked++; updateMissionProgress('duck_bird', birdsDuckedThisRun); } } if (checkCollision(llama, obs)) { handleCollision(obs); if (isGameOver) return; } if (obs.x + obs.width < 0) { obstacles.splice(i, 1); } } }
    function updateCoins() { const magnetRadius = isMagnetActive ? 100 : 0; for (let i=coinObjects.length-1; i>=0; i--) { const c = coinObjects[i]; if (!c) continue; c.update(); if (isMagnetActive && !c.collected) { const llamaCenterX = llama.x + llama.width / 2; const llamaHitboxY = llama.isDucking ? llama.y + (llama.height - llama.duckHeight) : llama.y; const llamaHitboxHeight = llama.isDucking ? llama.duckHeight : llama.height; const llamaCenterY = llamaHitboxY + llamaHitboxHeight / 2; const coinCenterX = c.x + c.radius; const coinCenterY = c.y + c.radius; const dx = llamaCenterX - coinCenterX; const dy = llamaCenterY - coinCenterY; const distance = Math.sqrt(dx*dx + dy*dy); if(distance < magnetRadius){ const magnetSpeed = 6; c.x += (dx / distance) * magnetSpeed; c.y += (dy / distance) * magnetSpeed;} } c.draw(); const effectiveRadius = isMagnetActive ? c.radius * 1.5 : c.radius; if (!c.collected && checkCollision(llama, c, true, effectiveRadius)) { c.collected=true; const indexToRemove = coinObjects.findIndex(coin => coin === c); if(indexToRemove !== -1) coinObjects.splice(indexToRemove,1); const coinValue = isDoubleCoinsBoostActive ? 2 : 1; coins += coinValue; coinsCollectedThisRun += coinValue; totalCoinsCollected += coinValue; updateMissionProgress('coins', coinsCollectedThisRun); if(!isSoundMuted && audioReady) coinSynth.triggerAttackRelease("E6", "16n"); updateDisplays(); } else if (c.x + c.radius*2 < 0) { coinObjects.splice(i, 1); } } }
    function updateMysteryBoxes() { for (let i = mysteryBoxes.length - 1; i >= 0; i--) { const box = mysteryBoxes[i]; if (!box) continue; box.update(); box.draw(); if (!box.collected && checkCollision(llama, box)) { box.collect(); } if ((box.collected && box.openTimer <= 0) || box.x + box.width < 0) { mysteryBoxes.splice(i, 1); } } }
    function checkCollision(llamaRect, otherObj, isCoin = false, coinRadius = 0) { let llamaTop = llamaRect.isDucking ? llamaRect.y + (llamaRect.height - llamaRect.duckHeight) : llamaRect.y; let llamaHeight = llamaRect.isDucking ? llamaRect.duckHeight : llamaRect.height; let llamaLeft = llamaRect.x; let llamaWidth = llamaRect.width; let llamaBottom = llamaTop + llamaHeight; let llamaRight = llamaLeft + llamaWidth; if (isCoin) { let coinCenterX = otherObj.x + otherObj.radius; const bob = Math.sin(frameCount*0.1+otherObj.x*0.05)*3; let coinCenterY = otherObj.y + bob + otherObj.radius; let radius = coinRadius > 0 ? coinRadius : otherObj.radius; let closestX = Math.max(llamaLeft, Math.min(coinCenterX, llamaRight)); let closestY = Math.max(llamaTop, Math.min(coinCenterY, llamaBottom)); let distanceX = coinCenterX - closestX; let distanceY = coinCenterY - closestY; let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY); return distanceSquared < (radius * radius); } else { let objTop = otherObj.y; let objLeft = otherObj.x; let objWidth = otherObj.width; let objHeight = otherObj.height; let objBottom = objTop + objHeight; let objRight = objLeft + objWidth; return ( llamaLeft < objRight && llamaRight > objLeft && llamaTop < objBottom && llamaBottom > objTop ); } }
    function handleCollision(obs) { if (isInvincibleBoostActive) { const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); return; } if(isShieldActive){ isShieldActive=false; totalShieldsUsed++; updatePowerupIndicators(); const i=obstacles.indexOf(obs); if(i>-1) obstacles.splice(i,1); if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("C4", "8n"); return; } if(extraLives>0){ extraLives--; updatePowerupIndicators(); const clearMultiplier = 1.0 + (lifeEffectivenessUpgradeLevel * 0.2); const clearRange = 75 * clearMultiplier; obstacles=obstacles.filter(o => o.x > llama.x + llama.width + clearRange || o.x + o.width < llama.x - clearRange); if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("A3", "8n"); return; } if(!isSoundMuted && audioReady) hitSynth.triggerAttackRelease("G2", "4n"); gameOver(); }
    function updateScore() { if (!isGameRunning || isPaused) return; score = Math.floor(frameCount / 6); totalDistanceRun += gameSpeed * 0.1; updateMissionProgress('score', score); }
    function updateDisplays() { storeCoinBalance.textContent = coins; shieldOwnedDisplay.textContent = shieldsOwned; lifeOwnedDisplay.textContent = livesOwned; magnetOwnedDisplay.textContent = magnetsOwned; buyShieldButton.disabled = coins < shieldCost; buyLifeButton.disabled = coins < lifeCost; buyMagnetButton.disabled = coins < magnetCost; const magnetCurrentLevel = magnetDurationUpgradeLevel; const magnetNextLevelCost = calculateUpgradeCost(baseMagnetDurationCost, magnetCurrentLevel, 1.8); magnetDurationLevelDisplay.textContent = `${magnetCurrentLevel}${magnetCurrentLevel >= magnetMaxLevel ? ' (MAX)' : ''}`; magnetDurationCostDisplay.textContent = magnetCurrentLevel >= magnetMaxLevel ? '---' : magnetNextLevelCost; magnetDurationUpgradeButton.disabled = magnetCurrentLevel >= magnetMaxLevel || coins < magnetNextLevelCost; const startCoinCurrentLevel = startCoinUpgradeLevel; const startCoinNextLevelCost = calculateUpgradeCost(baseStartCoinCost, startCoinCurrentLevel, 2.0); startCoinLevelDisplay.textContent = `${startCoinCurrentLevel}${startCoinCurrentLevel >= startCoinMaxLevel ? ' (MAX)' : ''}`; startCoinCostDisplay.textContent = startCoinCurrentLevel >= startCoinMaxLevel ? '---' : startCoinNextLevelCost; startCoinUpgradeButton.disabled = startCoinCurrentLevel >= startCoinMaxLevel || coins < startCoinNextLevelCost; const lifeEffectCurrentLevel = lifeEffectivenessUpgradeLevel; const lifeEffectNextLevelCost = calculateUpgradeCost(baseLifeEffectivenessCost, lifeEffectCurrentLevel, 2.2); lifeEffectivenessLevelDisplay.textContent = `${lifeEffectCurrentLevel}${lifeEffectCurrentLevel >= lifeEffectMaxLevel ? ' (MAX)' : ''}`; lifeEffectivenessCostDisplay.textContent = lifeEffectCurrentLevel >= lifeEffectMaxLevel ? '---' : lifeEffectNextLevelCost; lifeEffectivenessUpgradeButton.disabled = lifeEffectCurrentLevel >= lifeEffectMaxLevel || coins < lifeEffectNextLevelCost; const removeAdsCost = parseInt(buyRemoveAdsButton.getAttribute('data-cost') || '1000'); if (adsRemoved) { buyRemoveAdsButton.style.display = 'none'; adsRemovedStatus.style.display = 'block'; } else { buyRemoveAdsButton.disabled = false; buyRemoveAdsButton.style.display = 'inline-block'; adsRemovedStatus.style.display = 'none'; } updatePowerupIndicators(); }
    function updatePowerupIndicators() { shieldIndicator.classList.toggle('active', isShieldActive); magnetIndicator.classList.toggle('active', isMagnetActive); lifeIndicator.classList.toggle('active', extraLives > 0); lifeIndicator.textContent = extraLives > 0 ? `❤️ ${extraLives}` : '❤️'; shieldIndicator.classList.toggle('owned', shieldsOwned > 0 && !isShieldActive); magnetIndicator.classList.toggle('owned', magnetsOwned > 0 && !isMagnetActive); lifeIndicator.classList.toggle('owned', livesOwned > 0 && !(extraLives > 0)); }
    function calculateUpgradeCost(baseCost, currentLevel, multiplier) { return Math.floor(baseCost * Math.pow(multiplier, currentLevel)); }
    function updatePauseButtonVisibility() { const shouldBeVisible = isGameRunning && !isGameOver && !isPaused && !isAnyModalOpen(); pauseButton.style.display = shouldBeVisible ? 'block' : 'none'; }
    function isAnyModalOpen() { return dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex' || storeInterface.style.display === 'flex' || settingsModal.style.display === 'flex'; }
    function displayAdPlaceholder() { adDisplayPending = false; if (adsRemoved) return; console.log("Displaying ad placeholder..."); adPlaceholder.style.display = 'flex'; setTimeout(() => { adPlaceholder.style.display = 'none'; console.log("Ad placeholder hidden."); if (isGameOver && !isGameRunning) { requestAnimationFrame(gameLoop); } }, 3000); }
    function gameOver() { if(isGameOver) return; console.log("Game Over triggered"); isGameOver=true; isGameRunning=false; isPaused = false; updatePauseButtonVisibility(); isCoinRushActive = false; isInvincibleBoostActive = false; isDoubleCoinsBoostActive = false; isSpeedBoostActive = false; invincibleBoostTimer = 0; doubleCoinsBoostTimer = 0; speedBoostTimer = 0; coinRushTimer = 0; magnetTimer = 0; isMagnetActive = false; gameSpeed = baseGameSpeed; const xpEarned = Math.floor(score * xpPerScorePoint); playerXP += xpEarned; console.log(`Earned ${xpEarned} XP. Total XP: ${playerXP}`); let leveledUp = false; while (playerXP >= xpForLevelUp(playerLevel)) { const needed = xpForLevelUp(playerLevel); playerXP -= needed; playerLevel++; leveledUp = true; const levelReward = playerLevel * 25; coins += levelReward; showPopup(levelUpPopup, `Level Up! Reached Level ${playerLevel}!\n+${levelReward} Coins!`, 3000); if(!isSoundMuted && audioReady) levelUpSynth?.triggerAttackRelease("C4", "1n"); console.log(`Leveled up to ${playerLevel}! Rewarded ${levelReward} coins.`); } localStorage.setItem('llamaPlayerXP', playerXP); localStorage.setItem('llamaPlayerLevel', playerLevel); if(score > highScore) { highScore = score; localStorage.setItem('llamaHighScore', highScore); } localStorage.setItem('llamaCoins',coins); localStorage.setItem('llamaShields',shieldsOwned); localStorage.setItem('llamaLives',livesOwned); localStorage.setItem('llamaMagnets',magnetsOwned); saveAchievements(); checkAchievements(false); adDisplayPending = false; if (runCount > 0 && runCount % 5 === 0 && !adsRemoved) { console.log(`Run ${runCount}: Ad due.`); adDisplayPending = true; } else { console.log(`Run ${runCount}: No ad due or ads removed.`); } updatePowerupIndicators(); }
    function selectNewMission() { const availableMissions = missionPool; if (availableMissions.length > 0) { activeMission = availableMissions[Math.floor(Math.random() * availableMissions.length)]; missionProgress = 0; coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0; console.log("New Mission Selected:", activeMission.description); missionNotificationText = `New Mission: ${activeMission.description}`; missionNotificationTimer = missionNotificationDuration; } else { activeMission = null; console.log("No more missions available."); missionNotificationText = ""; missionNotificationTimer = 0; } }
    function showMissionCompletePopup() { showPopup(missionCompletePopup, `Mission Complete! +${activeMission.reward} Coins 🪙`); if(!isSoundMuted && audioReady) missionSynth.triggerAttackRelease("C6", "8n"); }
    function updateMissionProgress(type, value) { if (!activeMission || activeMission.type !== type || !isGameRunning || isPaused) { return; } missionProgress = value; if (missionProgress >= activeMission.target) { console.log(`Mission Complete: ${activeMission.description}`); coins += activeMission.reward; localStorage.setItem('llamaCoins', coins); showMissionCompletePopup(); selectNewMission(); updateDisplays(); } }
    function resetGame() { console.log("Resetting game..."); score=0; obstacles=[]; coinObjects=[]; clouds=[]; mysteryBoxes = []; frameCount=0; lastScoreThreshold=0; isGameOver=false; isPaused = false; updatePauseButtonVisibility(); isShieldActive=false; isMagnetActive=false; magnetTimer=0; extraLives=0; isInvincibleBoostActive = false; invincibleBoostTimer = 0; isDoubleCoinsBoostActive = false; doubleCoinsBoostTimer = 0; isSpeedBoostActive = false; speedBoostTimer = 0; isCoinRushActive = false; coinRushTimer = 0; baseGameSpeed = initialGameSpeed; gameSpeed = baseGameSpeed; console.log("Speed reset to:", gameSpeed); const startingCoinBonus = startCoinUpgradeLevel * 5; if (startingCoinBonus > 0) { coins += startingCoinBonus; console.log(`Applied starting coin bonus: +${startingCoinBonus}`); } currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); if(shieldsOwned>0){isShieldActive=true;shieldsOwned--;localStorage.setItem('llamaShields',shieldsOwned);} if(livesOwned>0){extraLives=1;livesOwned--;localStorage.setItem('llamaLives',livesOwned);} if(magnetsOwned>0){isMagnetActive=true;magnetTimer=currentMagnetDuration;magnetsOwned--;localStorage.setItem('llamaMagnets',magnetsOwned);} llama.reset(); coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0; selectNewMission(); updateDisplays(); framesAfterReset = 10; console.log("Game reset complete."); }
    function drawUI() { const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; const padding = 15; const fontSizeSmall = Math.max(8, Math.min(10, canvasW / 40)); const uiFont = `${fontSizeSmall}px "Press Start 2P"`; ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.font = uiFont; ctx.textAlign = 'right'; const drawX = canvasW - padding; ctx.fillText(`HI ${highScore}`, drawX, padding + fontSizeSmall); ctx.fillText(`${score}`, drawX, padding * 2 + fontSizeSmall * 2); ctx.fillText(`🪙 ${coins}`, drawX, padding * 3 + fontSizeSmall * 3.5); ctx.fillText(`Lv ${playerLevel}`, drawX, padding * 4 + fontSizeSmall * 5); if (activeMission) { const progressText = activeMission.type === 'score' ? `${score}/${activeMission.target}` : `${missionProgress}/${activeMission.target}`; let missionText = `${activeMission.description} (${progressText})`; const maxWidth = canvasW * 0.4; if (ctx.measureText(missionText).width > maxWidth) { missionText = activeMission.description.substring(0, 15) + `... (${progressText})`; } ctx.fillText(missionText, drawX, padding * 5 + fontSizeSmall * 6.5); } if (missionNotificationTimer > 0 && !isPaused) { ctx.textAlign = 'center'; const notificationFont = `${fontSizeSmall * 1.1}px "Press Start 2P"`; ctx.font = notificationFont; const textWidth = ctx.measureText(missionNotificationText).width; const notificationX = canvasW / 2; const notificationY = padding + fontSizeSmall; ctx.fillStyle = isNight ? 'rgba(0,0,0,0.6)' : 'rgba(255,255,255,0.6)'; ctx.fillRect(notificationX - textWidth / 2 - 5, notificationY - fontSizeSmall * 1.1, textWidth + 10, fontSizeSmall * 1.5); ctx.fillStyle = isNight ? '#00FFFF' : '#0000FF'; ctx.fillText(missionNotificationText, notificationX, notificationY); missionNotificationTimer--; ctx.font = uiFont; } if (isCoinRushActive) { ctx.textAlign = 'center'; ctx.font = `bold ${fontSizeSmall * 1.5}px "Press Start 2P"`; const rushColor = `rgba(255, ${180 + Math.sin(frameCount * 0.2) * 75}, 0, ${0.7 + Math.sin(frameCount * 0.1) * 0.3})`; ctx.fillStyle = rushColor; ctx.shadowColor = 'black'; ctx.shadowBlur = 5; ctx.fillText("COIN RUSH!", canvasW / 2, canvasH * 0.2); ctx.shadowBlur = 0; ctx.font = uiFont; } if (isDoubleCoinsBoostActive) { ctx.textAlign = 'center'; ctx.font = `bold ${fontSizeSmall * 1.2}px "Press Start 2P"`; ctx.fillStyle = 'lime'; ctx.shadowColor = 'black'; ctx.shadowBlur = 3; ctx.fillText("2x COINS!", canvasW / 2, canvasH * 0.25); ctx.shadowBlur = 0; ctx.font = uiFont; } }
    function drawGameOverOverlay() { const dpr = window.devicePixelRatio || 1; const canvasW = canvas.width / dpr; const canvasH = canvas.height / dpr; const boxWidthRatio = 0.7; const boxHeightRatio = 0.6; const maxBoxWidth = 400; const maxBoxHeight = 350; const boxWidth = Math.min(canvasW * boxWidthRatio, maxBoxWidth); const boxHeight = Math.min(canvasH * boxHeightRatio, maxBoxHeight); const boxX = (canvasW - boxWidth) / 2; const boxY = (canvasH - boxHeight) / 2; ctx.fillStyle = "rgba(0, 0, 0, 0.75)"; ctx.fillRect(0, 0, canvasW, canvasH); ctx.fillStyle = isNight ? nightUiBg : "rgba(255, 255, 255, 0.95)"; ctx.strokeStyle = isNight ? nightUiBorder : "#4a4a4a"; ctx.lineWidth = 3; ctx.fillRect(Math.round(boxX), Math.round(boxY), Math.round(boxWidth), Math.round(boxHeight)); ctx.strokeRect(Math.round(boxX), Math.round(boxY), Math.round(boxWidth), Math.round(boxHeight)); const padding = boxWidth * 0.05; const baseFontSize = Math.max(10, Math.min(16, boxHeight / 18)); const lineSpacing = baseFontSize * 1.7; ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.textAlign = "center"; const centerX = boxX + boxWidth / 2; let currentY = boxY + padding + baseFontSize * 1.5; ctx.font = `bold ${baseFontSize * 1.3}px "Press Start 2P"`; ctx.fillText("Game Over!", centerX, Math.round(currentY)); currentY += lineSpacing * 1.2; ctx.font = `${baseFontSize}px "Press Start 2P"`; ctx.fillText(`Score: ${score}`, centerX, Math.round(currentY)); currentY += lineSpacing * 0.9; ctx.fillText(`Coins: ${coins} 🪙`, centerX, Math.round(currentY)); currentY += lineSpacing * 0.9; ctx.fillText(`Level: ${playerLevel}`, centerX, Math.round(currentY)); currentY += lineSpacing * 1.3; ctx.font = `${baseFontSize * 0.9}px "Press Start 2P"`; ctx.fillText("Tap to Restart", centerX, Math.round(currentY)); const buttonHeight = baseFontSize * 2.8; const buttonWidth = Math.min(boxWidth * 0.4, 150); const buttonSpacing = boxWidth * 0.05; const totalButtonWidth = buttonWidth * 2 + buttonSpacing; const buttonStartY = boxY + boxHeight - padding - buttonHeight; const buttonStartX = centerX - totalButtonWidth / 2; ctx.font = `${baseFontSize * 0.8}px "Press Start 2P"`; const storeButtonX = buttonStartX; const storeButtonY = buttonStartY; storeButtonBounds = { x: storeButtonX, y: storeButtonY, width: buttonWidth, height: buttonHeight }; ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(Math.round(storeButtonBounds.x), Math.round(storeButtonBounds.y), Math.round(storeButtonBounds.width), Math.round(storeButtonBounds.height)); ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(Math.round(storeButtonBounds.x), Math.round(storeButtonBounds.y), Math.round(storeButtonBounds.width), Math.round(storeButtonBounds.height)); ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.fillText("[ Store ]", Math.round(storeButtonX + buttonWidth / 2), Math.round(storeButtonY + buttonHeight * 0.65)); const achButtonX = buttonStartX + buttonWidth + buttonSpacing; const achButtonY = buttonStartY; achievementButtonBounds = { x: achButtonX, y: achButtonY, width: buttonWidth, height: buttonHeight }; ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)'; ctx.fillRect(Math.round(achievementButtonBounds.x), Math.round(achievementButtonBounds.y), Math.round(achievementButtonBounds.width), Math.round(achievementButtonBounds.height)); ctx.strokeStyle = isNight ? nightUiBorder : "#888"; ctx.lineWidth = 1; ctx.strokeRect(Math.round(achievementButtonBounds.x), Math.round(achievementButtonBounds.y), Math.round(achievementButtonBounds.width), Math.round(achievementButtonBounds.height)); ctx.fillStyle = isNight ? nightTextColor : dayTextColor; ctx.fillText("[Achieve]", Math.round(achButtonX + buttonWidth / 2), Math.round(achButtonY + buttonHeight * 0.65)); }
    function grantMysteryReward(box) { const rand = Math.random(); let rewardMessage = ""; if (rand < 0.4) { const coinRand = Math.random(); let amount; if (coinRand < 0.6) amount = 5; else if (coinRand < 0.9) amount = 15; else amount = 30; coins += amount; rewardMessage = `+${amount} Coins! 🪙`; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4", "E4", "G4"], "8n"); } else if (rand < 0.75) { const boostRand = Math.random(); if (boostRand < 0.5 && !isInvincibleBoostActive) { isInvincibleBoostActive = true; invincibleBoostTimer = invincibleBoostDuration; rewardMessage = "Invincible! (5s)"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["G4", "C5", "E5"], "4n"); } else if (!isDoubleCoinsBoostActive) { isDoubleCoinsBoostActive = true; doubleCoinsBoostTimer = doubleCoinsBoostDuration; rewardMessage = "2x Coins! (10s)"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4", "G4", "C5"], "4n"); } else { coins += 3; rewardMessage = "+3 Coins! 🪙"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C4"], "8n"); } } else if (rand < 0.95) { const powerupRand = Math.random(); if (powerupRand < 0.5 && !isShieldActive && !isInvincibleBoostActive) { isShieldActive = true; updatePowerupIndicators(); rewardMessage = "Shield Activated!"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["E4", "G4", "B4"], "8n"); } else if (!isMagnetActive) { isMagnetActive = true; magnetTimer = currentMagnetDuration; updatePowerupIndicators(); rewardMessage = "Coin Magnet!"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["D4", "F#4", "A4"], "8n"); } else { coins += 10; rewardMessage = "+10 Coins! 🪙"; if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["D4", "A4"], "8n"); } } else { const ownedRand = Math.random(); if (ownedRand < 0.33) { shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); rewardMessage = "+1 Shield Added!"; } else if (ownedRand < 0.66) { livesOwned++; localStorage.setItem('llamaLives', livesOwned); rewardMessage = "+1 Life Added!"; } else { magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); rewardMessage = "+1 Magnet Added!"; } if(!isSoundMuted && audioReady) rewardSynth?.triggerAttackRelease(["C5", "E5", "G5", "C6"], "4n"); } if (rewardMessage) { showPopup(rewardPopup, rewardMessage); updateDisplays(); } console.log("Mystery Box Reward:", rewardMessage); }
    function checkDailyLogin() { const today = getCurrentDateString(); const lastLogin = localStorage.getItem('llamaLastLoginDate'); const consecutiveDays = parseInt(localStorage.getItem('llamaConsecutiveDays') || 0); const lastPlayDate = dailyPlayLog.length > 0 ? dailyPlayLog[dailyPlayLog.length - 1] : null; if (lastPlayDate !== today) { dailyPlayLog.push(today); try { localStorage.setItem('llamaDailyPlayLog', JSON.stringify(dailyPlayLog)); console.log(`Logged play for date: ${today}`); } catch (e) { console.error("Failed to save daily play log:", e); } } if (lastLogin === today) { return; } let currentStreak = 1; if (lastLogin) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.toISOString().split('T')[0]; if (lastLogin === yesterdayStr) { currentStreak = consecutiveDays + 1; } } localStorage.setItem('llamaLastLoginDate', today); localStorage.setItem('llamaConsecutiveDays', currentStreak); const baseReward = 10 + (currentStreak - 1) * 5; let bonusMessage = ""; let bonusCoins = 0; let bonusItem = null; const bonusRand = Math.random(); if (currentStreak >= 5 && bonusRand < 0.15) { const itemRand = Math.random(); if (itemRand < 0.33) { bonusItem = 'Shield'; shieldsOwned++; localStorage.setItem('llamaShields', shieldsOwned); } else if (itemRand < 0.66) { bonusItem = 'Life'; livesOwned++; localStorage.setItem('llamaLives', livesOwned); } else { bonusItem = 'Magnet'; magnetsOwned++; localStorage.setItem('llamaMagnets', magnetsOwned); } bonusMessage = `+ Bonus ${bonusItem}!`; } else if (bonusRand < 0.3) { bonusCoins = 5 + Math.floor(Math.random() * (currentStreak * 2)); bonusMessage = `+ Bonus ${bonusCoins} Coins!`; } const totalReward = baseReward + bonusCoins; coins += totalReward; localStorage.setItem('llamaCoins', coins); dailyLoginTitle.textContent = `Day ${currentStreak} Login Bonus!`; dailyLoginMessage.innerHTML = `You received ${baseReward} Coins! 🪙<br>${bonusMessage || '(No extra bonus today)'}`; dailyBonusBreakdownList.innerHTML = ''; for (let i = 1; i <= 10; i++) { const dayReward = 10 + (i - 1) * 5; const li = document.createElement('li'); li.textContent = `Day ${i}: ${dayReward} 🪙`; if (i === currentStreak) { li.classList.add('current-day'); li.textContent += " (Today!)"; } else if (i < currentStreak) { li.style.opacity = '0.6'; } dailyBonusBreakdownList.appendChild(li); } dailyLoginModal.style.display = 'flex'; if(!isSoundMuted && audioReady) dailyBonusSynth?.triggerAttackRelease("A4", "2n"); updateDisplays(); }
    function gameLoop() { if (isPaused) { return; } if (adDisplayPending) { displayAdPlaceholder(); return; } if (isGameOver) { const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvasW, canvasH); drawGround(); clouds.forEach(c => c.draw()); drawStars(); llama.draw(); drawGameOverOverlay(); return; } isGameRunning = true; updatePauseButtonVisibility(); if (framesAfterReset > 0) { framesAfterReset--; } const scoreCycle = Math.floor(score / 700); const shouldBeNight = scoreCycle % 2 !== 0; if (shouldBeNight !== isNight) { isNight = shouldBeNight; setBackground(isNight); if (isGameRunning && isNight) { totalNightsSurvived++; checkAchievements(); } } if (!isCoinRushActive && score >= coinRushMinScore && Math.random() < coinRushChance && framesAfterReset <= 0) { isCoinRushActive = true; coinRushTimer = coinRushDuration; if(!isSoundMuted && audioReady) coinRushSynth?.triggerAttackRelease("4n"); console.log("COIN RUSH STARTED!"); } if (isCoinRushActive) { coinRushTimer--; if (coinRushTimer <= 0) { isCoinRushActive = false; gameSpeed = baseGameSpeed; console.log("COIN RUSH ENDED"); } } if (isInvincibleBoostActive) { invincibleBoostTimer--; if (invincibleBoostTimer <= 0) isInvincibleBoostActive = false; } if (isDoubleCoinsBoostActive) { doubleCoinsBoostTimer--; if (doubleCoinsBoostTimer <= 0) isDoubleCoinsBoostActive = false; } if (isMagnetActive) { magnetTimer--; if (magnetTimer <= 0) { isMagnetActive = false; updatePowerupIndicators(); } } const canvasW = canvas.width / currentDPR; const canvasH = canvas.height / currentDPR; ctx.fillStyle = currentBgColor; ctx.fillRect(0, 0, canvasW, canvasH); spawnCloud(); updateClouds(); drawStars(); drawGround(); llama.update(); llama.draw(); if (framesAfterReset <= 0) { spawnObstacle(); spawnCoin(); spawnMysteryBox(); } updateObstacles(); updateCoins(); updateMysteryBoxes(); updateScore(); const currentScoreThreshold = Math.floor(score / 100); if (currentScoreThreshold > lastScoreThreshold && !isCoinRushActive) { gameSpeed += speedIncrement; baseGameSpeed += speedIncrement; lastScoreThreshold = currentScoreThreshold; console.log(`Score ${lastScoreThreshold * 100}, Speed: ${gameSpeed.toFixed(2)}`); } drawUI(); frameCount++; animationFrameId = requestAnimationFrame(gameLoop); }
    function initiateGameStart() { storeButtonBounds = null; achievementButtonBounds = null; if (isAnyModalOpen()) return; if (!isGameOver || isGameRunning) { console.log("Not starting: game over=", isGameOver, " running=", isGameRunning); return; } console.log("Initiating game start..."); runCount++; localStorage.setItem('llamaRunCount', runCount); console.log(`Starting Run #${runCount}`); resetGame(); isGameOver = false; isGameRunning = true; updatePauseButtonVisibility(); if (animationFrameId) { cancelAnimationFrame(animationFrameId); } animationFrameId = requestAnimationFrame(gameLoop); }
    function updatePauseButtonVisibility() { const shouldBeVisible = isGameRunning && !isGameOver && !isPaused && !isAnyModalOpen(); pauseButton.style.display = shouldBeVisible ? 'block' : 'none'; }
    function isAnyModalOpen() { return dailyLoginModal.style.display === 'flex' || achievementModal.style.display === 'flex' || storeInterface.style.display === 'flex' || settingsModal.style.display === 'flex'; }
    document.addEventListener('keydown', (e) => { if (isPaused || isAnyModalOpen()) return; if(isGameOver){if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); handleGameStartInteraction(); } return; } if(isGameRunning){ if(e.code === 'Space' || e.code === 'ArrowUp'){ e.preventDefault(); llama.jump(); } else if(e.code === 'ArrowDown'){ e.preventDefault(); if (!llama.isDucking){ llama.duck(true); } } } });
    document.addEventListener('keyup', (e) => { if (isPaused || isAnyModalOpen()) return; if(isGameRunning && e.code === 'ArrowDown'){ e.preventDefault(); llama.duck(false); } });
    function playUIClick(){ if(!isSoundMuted && audioReady) uiClickSynth?.triggerAttackRelease("A5", "16n"); }
    buyShieldButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= shieldCost) { coins -= shieldCost; shieldsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaShields', shieldsOwned); updateDisplays(); } });
    buyLifeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= lifeCost) { coins -= lifeCost; livesOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLives', livesOwned); updateDisplays(); } });
    buyMagnetButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (coins >= magnetCost) { coins -= magnetCost; magnetsOwned++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnets', magnetsOwned); updateDisplays(); } });
    closeStoreButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); storeInterface.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    magnetDurationUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseMagnetDurationCost, magnetDurationUpgradeLevel, 1.8); if (coins >= cost && magnetDurationUpgradeLevel < magnetMaxLevel) { coins -= cost; magnetDurationUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaMagnetUpgrade', magnetDurationUpgradeLevel); updateDisplays(); currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); } });
    startCoinUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseStartCoinCost, startCoinUpgradeLevel, 2.0); if (coins >= cost && startCoinUpgradeLevel < startCoinMaxLevel) { coins -= cost; startCoinUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaStartCoinUpgrade', startCoinUpgradeLevel); updateDisplays(); } });
    lifeEffectivenessUpgradeButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); const cost = calculateUpgradeCost(baseLifeEffectivenessCost, lifeEffectivenessUpgradeLevel, 2.2); if (coins >= cost && lifeEffectivenessUpgradeLevel < lifeEffectMaxLevel) { coins -= cost; lifeEffectivenessUpgradeLevel++; localStorage.setItem('llamaCoins', coins); localStorage.setItem('llamaLifeEffectUpgrade', lifeEffectivenessUpgradeLevel); updateDisplays(); } });
    buyRemoveAdsButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); if (!adsRemoved) { if (confirm("Confirm purchase to remove ads for $5.00?\n(This is a simulation - no real money will be charged)")) { adsRemoved = true; localStorage.setItem('llamaAdsRemoved', 'true'); console.log("Ads Removed (Simulated Purchase Confirmed)!"); updateDisplays(); alert("Ad removal purchased (Simulation Complete)!"); } else { console.log("Simulated purchase cancelled."); } } });
    dailyLoginCloseButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); dailyLoginModal.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    achievementCloseButton.addEventListener('click', (e) => { e.stopPropagation(); playUIClick(); achievementModal.style.display = 'none'; updatePauseButtonVisibility(); if(isGameOver) { requestAnimationFrame(gameLoop); } });
    pauseButton.addEventListener('click', (e) => { e.stopPropagation(); if (!isGameRunning || isGameOver || isPaused || isAnyModalOpen()) return; playUIClick(); isPaused = true; if (animationFrameId) { cancelAnimationFrame(animationFrameId); animationFrameId = null; } settingsModal.style.display = 'flex'; updatePauseButtonVisibility(); console.log("Game Paused"); });
    resumeButton.addEventListener('click', (e) => { e.stopPropagation(); if (!isPaused) return; playUIClick(); isPaused = false; settingsModal.style.display = 'none'; updatePauseButtonVisibility(); if (!animationFrameId && isGameRunning && !isGameOver) { animationFrameId = requestAnimationFrame(gameLoop); } console.log("Game Resumed"); });
    toggleSoundButton.addEventListener('click', (e) => { e.stopPropagation(); isSoundMuted = !isSoundMuted; if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; } localStorage.setItem('llamaSoundMuted', isSoundMuted); toggleSoundButton.textContent = `Sound: ${isSoundMuted ? 'OFF' : 'ON'}`; playUIClick(); console.log(`Sound Muted: ${isSoundMuted}`); });
    function handleGameStartInteraction() { if (isAnyModalOpen()) return; if (!isGameOver || isGameRunning) { console.log("Interaction ignored: game not ready."); return; } console.log("Handle Interaction - Game Over: ", isGameOver, " Running: ", isGameRunning); if (!audioReady) { try { console.log("Attempting Tone.start()..."); Tone.start().then(() => { console.log("Audio context started successfully."); setupAudio(); initiateGameStart(); }).catch(e => { console.error("Tone.start() failed:", e); initiateGameStart(); }); } catch (e) { console.error("Error calling Tone.start():", e); initiateGameStart(); } } else { console.log("Audio ready, starting game directly."); initiateGameStart(); } }
    gameContainer.addEventListener('touchstart', (e) => { if (isPaused || isAnyModalOpen()) return; const touch = e.changedTouches[0]; const rect = canvas.getBoundingClientRect(); if (isGameOver) { e.preventDefault(); const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top;
        // --- DEBUG LOGS ---
        console.log(`GameOver Tap: touchX=${touchX.toFixed(2)}, touchY=${touchY.toFixed(2)}`);
        console.log('Store Bounds:', storeButtonBounds);
        console.log('Achieve Bounds:', achievementButtonBounds);
        // --- END DEBUG LOGS ---
        if (storeButtonBounds && touchX >= storeButtonBounds.x && touchX <= storeButtonBounds.x + storeButtonBounds.width && touchY >= storeButtonBounds.y && touchY <= storeButtonBounds.y + storeButtonBounds.height) {
            console.log(">>> Store button condition MET"); // Debug Log
            playUIClick(); storeInterface.style.display = 'flex'; updateDisplays(); updatePauseButtonVisibility();
        } else if (achievementButtonBounds && touchX >= achievementButtonBounds.x && touchX <= achievementButtonBounds.x + achievementButtonBounds.width && touchY >= achievementButtonBounds.y && touchY <= achievementButtonBounds.y + achievementButtonBounds.height) {
            console.log(">>> Achievement button condition MET"); // Debug Log
            playUIClick(); populateAchievementModal(); achievementModal.style.display = 'flex'; updatePauseButtonVisibility();
        } else {
            console.log(">>> Neither button condition met, handling restart."); // Debug Log
            handleGameStartInteraction();
        } return; } if (isGameRunning) { touchStartX = touch.screenX; touchStartY = touch.screenY; touchStartTime = Date.now(); isSwiping = false; } }, {passive: false});
    gameContainer.addEventListener('touchmove', (e) => { if (isPaused || isAnyModalOpen()) return; if (!isGameRunning || touchStartY === 0) return; const touch = e.changedTouches[0]; const currentX = touch.screenX; const currentY = touch.screenY; let distY = currentY - touchStartY; let distX = currentX - touchStartX; if (!isSwiping && (Math.abs(distY) > 10 || Math.abs(distX) > 10)) { if (Math.abs(distY) > Math.abs(distX)) { e.preventDefault(); } isSwiping = true; } if (isSwiping && distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { if (!llama.isDucking) { llama.duck(true); } } }, {passive: false});
    gameContainer.addEventListener('touchend', (e) => { if (isPaused || isAnyModalOpen()) return; if (!isGameRunning || touchStartY === 0) { touchStartY = 0; isSwiping = false; return; } const touchEndTime = Date.now(); const touchDuration = touchEndTime - touchStartTime; const touchEndY = e.changedTouches[0].screenY; const touchEndX = e.changedTouches[0].screenX; let distY = touchEndY - touchStartY; let distX = touchEndX - touchStartX; if (touchDuration < maxTapTime && Math.abs(distX) < 20 && Math.abs(distY) < 20 && !isSwiping) { console.log("Tap -> Jump"); llama.jump(); } else if (distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Down End -> Duck End"); llama.duck(false); } else if (distY < -minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { console.log("Swipe Up -> Jump"); llama.jump(); } else { if (llama.isDucking){ llama.duck(false); } } touchStartX = 0; touchStartY = 0; touchStartTime = 0; isSwiping = false; });
    window.onload = () => { console.log("Window loaded. Initializing game display."); loadGameSettings(); loadAchievements(); resizeCanvas(); isGameOver = true; isGameRunning = false; updatePauseButtonVisibility(); checkDailyLogin(); updateDisplays(); currentMagnetDuration = baseMagnetDuration + (magnetDurationUpgradeLevel * 60); if (dailyLoginModal.style.display !== 'flex') { requestAnimationFrame(gameLoop); } console.log("Game initialized. Waiting for user interaction or modal close."); };
    function loadGameSettings() { magnetDurationUpgradeLevel = parseInt(localStorage.getItem('llamaMagnetUpgrade') || 0); startCoinUpgradeLevel = parseInt(localStorage.getItem('llamaStartCoinUpgrade') || 0); lifeEffectivenessUpgradeLevel = parseInt(localStorage.getItem('llamaLifeEffectUpgrade') || 0); coins = parseInt(localStorage.getItem('llamaCoins') || 0); playerXP = parseInt(localStorage.getItem('llamaPlayerXP') || 0); playerLevel = parseInt(localStorage.getItem('llamaPlayerLevel') || 1); highScore = parseInt(localStorage.getItem('llamaHighScore') || 0); shieldsOwned = parseInt(localStorage.getItem('llamaShields') || 0); livesOwned = parseInt(localStorage.getItem('llamaLives') || 0); magnetsOwned = parseInt(localStorage.getItem('llamaMagnets') || 0); runCount = parseInt(localStorage.getItem('llamaRunCount') || 0); adsRemoved = localStorage.getItem('llamaAdsRemoved') === 'true'; isSoundMuted = localStorage.getItem('llamaSoundMuted') === 'true'; toggleSoundButton.textContent = `Sound: ${isSoundMuted ? 'OFF' : 'ON'}`; if (typeof Tone !== 'undefined' && Tone.Master) { Tone.Master.mute = isSoundMuted; } try { dailyPlayLog = JSON.parse(localStorage.getItem('llamaDailyPlayLog') || '[]'); if (!Array.isArray(dailyPlayLog)) dailyPlayLog = []; } catch(e) { console.error("Failed to load daily play log:", e); dailyPlayLog = []; } console.log("Game settings loaded."); }
  </script>
</body>
</html>
