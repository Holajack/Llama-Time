<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#87CEEB"> <title>Llama Time!</title>
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/llama-icon-192.png">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Llama Time">
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        /* Styles remain the same as v36b */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body { height: 100%; overflow: hidden; }
        body { display: flex; flex-direction: column; align-items: center; min-height: 100vh; background-color: #f0f0f0; font-family: 'Press Start 2P', cursive; color: #333; padding: 0; transition: background-color 0.5s ease; }
        #game-container { position: relative; width: 100vw; height: 100vh; max-width: none; border: none; border-radius: 0; overflow: hidden; cursor: pointer; background-color: #87CEEB; transition: background-color 0.5s ease; flex-shrink: 0; margin: 0; }
        canvas { display: block; width: 100%; height: 100%; background-color: transparent; image-rendering: pixelated; image-rendering: -moz-crisp-edges; image-rendering: crisp-edges; }
        #message-box { display: none; }
        #mission-complete-popup { position: absolute; top: 15px; right: 15px; background-color: rgba(76, 175, 80, 0.9); color: white; padding: 8px 15px; border-radius: 10px; font-size: 0.8em; z-index: 30; display: none; opacity: 0; transition: opacity 0.5s ease-out; font-family: 'Press Start 2P', cursive; }
        #store-interface { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.9); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 20; color: white; padding: 15px 10px; text-align: center; }
        #store-interface h2 { margin-top: 10px; margin-bottom: 20px; font-size: 1.5em; flex-shrink: 0; }
        #store-interface > p { margin-bottom: 15px; font-size: 1em; flex-shrink: 0; }
        .store-item { background-color: #4a4a4a; padding: 15px; margin-bottom: 15px; border-radius: 10px; width: 90%; max-width: 350px; border: 2px solid #fff; flex-shrink: 0; }
        .store-item h3 { font-size: 1.1em; margin-bottom: 8px; }
        .store-item p { margin-bottom: 10px; font-size: 0.8em; }
        .store-item button { font-family: 'Press Start 2P', cursive; font-size: 0.8em; padding: 8px 15px; margin-top: 5px; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer;}
        .store-item button:disabled { opacity: 0.5; cursor: not-allowed; }
        #close-store { margin-top: 20px; padding: 10px 20px; font-size: 1em; flex-shrink: 0; font-family: 'Press Start 2P', cursive; border-radius: 8px; border: 2px solid #aaa; background: #eee; color: #33; cursor: pointer; }
        #powerup-indicators { position: absolute; top: 10px; left: 10px; z-index: 5; display: flex; gap: 8px; }
        .indicator { font-size: 1.8em; opacity: 0.35; text-shadow: 1px 1px 2px rgba(0,0,0,0.5); transition: opacity 0.3s ease, filter 0.3s ease; filter: grayscale(50%); }
        .indicator.owned { opacity: 0.7; filter: grayscale(0%); }
        .indicator.active { opacity: 1; filter: grayscale(0%); animation: pulse 0.8s infinite; }
        #magnet-indicator.active { animation: pulse-magnet 0.6s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes pulse-magnet { 0% { transform: scale(1); text-shadow: 0 0 5px gold; } 50% { transform: scale(1.2); text-shadow: 0 0 15px gold; } 100% { transform: scale(1); text-shadow: 0 0 5px gold; } }
         @media (max-height: 400px) {
             #mission-complete-popup { font-size: 0.6em; padding: 4px 8px; top: 5px; right: 5px; }
             .indicator { font-size: 1.2em; }
         }
         @media (max-width: 400px) {
             .indicator { font-size: 1.2em; }
         }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="message-box"></div> <div id="powerup-indicators"> <span id="shield-indicator" class="indicator">üõ°Ô∏è</span> <span id="magnet-indicator" class="indicator">üß≤</span> <span id="life-indicator" class="indicator">‚ù§Ô∏è</span> </div>
        <div id="mission-complete-popup">Mission Complete!</div>
        <div id="store-interface"> <h2>Power-up Store</h2> <p>Your Coins: <span id="store-coin-balance">0</span> ü™ô</p> <div class="store-item"> <h3>Shield (üõ°Ô∏è) - Cost: 50 ü™ô</h3> <p>Activates automatically next run!</p> <button id="buy-shield">Buy Shield</button> <p>Owned: <span id="shield-owned">0</span></p> </div> <div class="store-item"> <h3>Extra Life (‚ù§Ô∏è) - Cost: 100 ü™ô</h3> <p>Activates automatically next run!</p> <button id="buy-life">Buy Extra Life</button> <p>Owned: <span id="life-owned">0</span></p> </div> <div class="store-item"> <h3>Coin Magnet (üß≤) - Cost: 75 ü™ô</h3> <p>Activates automatically next run!</p> <button id="buy-magnet">Buy Coin Magnet</button> <p>Owned: <span id="magnet-owned">0</span></p> </div> <button id="close-store">Close Store</button> </div>
    </div>

    <script>
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js')
                    .then(registration => { console.log('SW registered: ', registration); })
                    .catch(registrationError => { console.log('SW registration failed: ', registrationError); });
            });
        }
    </script>

    <script>
        // --- DOM Elements ---
        const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); const messageBox = document.getElementById('message-box'); const storeInterface = document.getElementById('store-interface'); const storeCoinBalance = document.getElementById('store-coin-balance'); const buyShieldButton = document.getElementById('buy-shield'); const buyLifeButton = document.getElementById('buy-life'); const buyMagnetButton = document.getElementById('buy-magnet'); const shieldOwnedDisplay = document.getElementById('shield-owned'); const lifeOwnedDisplay = document.getElementById('life-owned'); const magnetOwnedDisplay = document.getElementById('magnet-owned'); const closeStoreButton = document.getElementById('close-store'); const shieldIndicator = document.getElementById('shield-indicator'); const magnetIndicator = document.getElementById('magnet-indicator'); const lifeIndicator = document.getElementById('life-indicator'); const gameContainer = document.getElementById('game-container'); const missionCompletePopup = document.getElementById('mission-complete-popup');
        // const installButton = document.getElementById('install-button'); // Button element removed

        // --- Game Variables ---
        let score = 0; let highScore = localStorage.getItem('llamaHighScore') || 0; let coins = parseInt(localStorage.getItem('llamaCoins') || 0); let shieldsOwned = parseInt(localStorage.getItem('llamaShields') || 0); let livesOwned = parseInt(localStorage.getItem('llamaLives') || 0); let magnetsOwned = parseInt(localStorage.getItem('llamaMagnets') || 0);
        const initialGameSpeed = 2.5; // --- Slower start speed ---
        let gameSpeed = initialGameSpeed;
        const speedIncrement = 0.3; let lastScoreThreshold = 0;
        let gravity = 0.35; const fastFallMultiplier = 3.5;
        let isGameOver = true; let isGameRunning = false; let animationFrameId; let obstacles = []; let coinObjects = []; let clouds = [];
        let frameCount = 0; let isShieldActive = false; let isMagnetActive = false; let magnetTimer = 0; const magnetDuration = 600; let extraLives = 0;
        let framesAfterReset = 0; // Counter for logging speed after reset

        // --- Day/Night Cycle ---
        let isNight = false; const dayBgColor = '#87CEEB'; const nightBgColor = '#2c3e50'; const dayGroundColor = '#D2B48C'; const nightGroundColor = '#B08D57'; const dayTextColor = '#333'; const nightTextColor = '#ecf0f1'; const nightMissionTextColor = '#bdc3c7'; const nightMissionStrongColor = '#ecf0f1'; const dayBodyBgColor = '#f0f0f0'; const nightBodyBgColor = '#34495e'; const nightUiBg = '#4a5a6a'; const nightUiBorder = '#7f8c8d'; const dayOutlineColor = 'rgba(0, 0, 0, 0.5)'; const nightOutlineColor = 'rgba(255, 255, 255, 0.7)';

        // --- Missions (Restored) ---
        const missionPool = [ { id: 'score100', description: 'Reach Score 100', target: 100, reward: 15, type: 'score' }, { id: 'collect5', description: 'Collect 5 coins', target: 5, reward: 15, type: 'coins' }, { id: 'score300', description: 'Reach Score 300', target: 300, reward: 30, type: 'score' }, { id: 'jump5cacti', description: 'Jump over 5 cacti', target: 5, reward: 35, type: 'jump_cactus' }, { id: 'collect15', description: 'Collect 15 coins', target: 15, reward: 40, type: 'coins' }, { id: 'score750', description: 'Reach Score 750', target: 750, reward: 75, type: 'score' }, { id: 'duck3birds', description: 'Duck under 3 birds', target: 3, reward: 45, type: 'duck_bird' }, { id: 'collect30', description: 'Collect 30 coins', target: 30, reward: 80, type: 'coins' }, ];
        let activeMission = null; let missionProgress = 0; let coinsCollectedThisRun = 0; let cactiJumpedThisRun = 0; let birdsDuckedThisRun = 0;
        let missionNotificationText = ""; let missionNotificationTimer = 0; const missionNotificationDuration = 180;

        // --- Store Costs ---
        const shieldCost = 50; const lifeCost = 100; const magnetCost = 75;

        // --- Audio Synths (Restored) ---
        let jumpSynth, coinSynth, hitSynth, uiClickSynth, missionSynth;
        let audioReady = false;

        // --- Audio Setup (Restored) ---
        function setupAudio() { /* ... setupAudio code from v32 ... */ if (audioReady) return; try { jumpSynth = new Tone.Synth({ oscillator: { type: "square" }, volume: -8, envelope: { attack: 0.005, decay: 0.05, sustain: 0.01, release: 0.1 } }).toDestination(); coinSynth = new Tone.Synth({ oscillator: { type: "sine" }, volume: -10, envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 } }).toDestination(); hitSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 4, volume: -5, envelope: { attack: 0.001, decay: 0.3, sustain: 0.01, release: 0.5, attackCurve: "exponential" } }).toDestination(); uiClickSynth = new Tone.Synth({ volume: -15, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.05 } }).toDestination(); missionSynth = new Tone.Synth({ oscillator: { type: "sawtooth" }, volume: -8, envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 } }).toDestination(); audioReady = true; console.log("Audio ready."); } catch (err) { console.error("Error setting up audio:", err); audioReady = false; } }

        // --- PWA Install Prompt ---
        let deferredPrompt;

        // --- Touch Swipe Variables ---
        let touchStartX = 0; let touchStartY = 0; let touchEndX = 0; let touchEndY = 0;
        let touchStartTime = 0; let isSwiping = false;
        const minSwipeYDistance = 50; const maxSwipeXDistance = 50; const maxTapTime = 250;

        // --- Game Over Screen Variables ---
        let storeButtonBounds = null;

        // --- Game Objects ---
        const groundHeight = 50;

        // --- Llama Object (Restored Detailed Drawing & Animation) ---
        const llama = { /* ... properties from v26 ... */
            x: 50, y: 0, drawWidth: 56, drawHeight: 56, width: 50, height: 52, dy: 0, jumpPower: -11, isJumping: false, isDucking: false, duckHeight: 30, baseY: 0, runFrame: 0, runAnimationSpeed: 6,
            draw() { /* ... Detailed drawing code from v26 ... */ const bodyHigh='#F5E5D0', bodyLight='#EAD8BF', bodyMain='#D8B898', bodyShade='#B89878'; const legMain='#A08060', legShade='#806040', hoof='#604030'; const faceMain='#F0D0B0', earInner='#E0C0A0', eyeWhite='#FFFFFF', eyePupil='#000000', nose='#705040', hair='#907050'; const p = 2; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); let scaleY=1; let duckOffsetY=0; if(this.isDucking){ scaleY=0.75; duckOffsetY = this.drawHeight * (1 - scaleY); ctx.translate(0,duckOffsetY); ctx.scale(1,scaleY); } ctx.fillStyle=bodyMain; ctx.fillRect(p*4, p*4, p*18, p*14); ctx.fillStyle=bodyShade; ctx.fillRect(p*5, p*15, p*16, p*3); ctx.fillStyle=bodyLight; ctx.fillRect(p*5, p*4, p*16, p*3); ctx.fillStyle=bodyLight; ctx.fillRect(p*4, p*6, p*2, p*10); ctx.fillRect(p*3, p*8, p*1, p*6); ctx.fillStyle=bodyMain; ctx.fillRect(p*2, p*7, p*2, p*8); ctx.fillStyle=hair; ctx.fillRect(p*0, p*10, p*4, p*4); ctx.fillRect(p*-1, p*11, p*2, p*2); ctx.fillStyle=bodyMain; ctx.fillRect(p*16, p*-1, p*6, p*8); ctx.fillStyle=bodyShade; ctx.fillRect(p*16, p*5, p*5, p*2); ctx.fillStyle=hair; ctx.fillRect(p*15, p*-4, p*7, p*5); ctx.fillRect(p*17, p*-6, p*3, p*2); ctx.fillRect(p*14, p*-1, p*3, p*3); ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-9, p*9, p*10); ctx.fillStyle=faceMain; ctx.fillRect(p*26, p*-6, p*4, p*6); ctx.fillStyle=nose; ctx.fillRect(p*28, p*-3, p*2, p*1); ctx.fillRect(p*27, p*0, p*3, p*1); ctx.fillStyle=eyeWhite; ctx.fillRect(p*23, p*-5, p*2, p*2); ctx.fillStyle=eyePupil; ctx.fillRect(p*24, p*-4, p*1, p*1); ctx.fillStyle=bodyMain; ctx.fillRect(p*19, p*-13, p*3, p*5); ctx.fillRect(p*23, p*-13, p*3, p*5); ctx.fillStyle=earInner; ctx.fillRect(p*20, p*-12, p*1, p*3); ctx.fillRect(p*24, p*-12, p*1, p*3); const currentRunFrame = Math.floor(this.runFrame / this.runAnimationSpeed) % 2; const upperLegW=p*3, upperLegH=p*5, lowerLegW=p*3, lowerLegH=p*4, hoofH=p*2; const frontUpperX=p*6, frontUpperY=p*17; const backUpperX=p*14, backUpperY=p*17; if(this.isJumping) { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX-p*1,frontUpperY,upperLegW,upperLegH+lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX-p*1+p,frontUpperY,upperLegW-p*2,upperLegH+lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*1,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX-p*1,backUpperY,upperLegW,upperLegH+lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX-p*1+p,backUpperY,upperLegW-p*2,upperLegH+lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*1,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } else if (this.isDucking) { const duckLegH=p*4; const duckHoofY=frontUpperY+duckLegH; ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,duckLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,duckLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX,duckHoofY,upperLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,duckLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,duckLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX,duckHoofY,upperLegW,hoofH); } else { if(currentRunFrame === 0) { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX+p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX+p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX-p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX-p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } else { ctx.fillStyle=legShade; ctx.fillRect(frontUpperX,frontUpperY,upperLegW,upperLegH); ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(frontUpperX+p,frontUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(frontUpperX-p*2+p,frontUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(frontUpperX-p*2,frontUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); ctx.fillStyle=legShade; ctx.fillRect(backUpperX,backUpperY,upperLegW,upperLegH); ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH,lowerLegW,lowerLegH); ctx.fillStyle=legMain; ctx.fillRect(backUpperX+p,backUpperY,upperLegW-p*2,upperLegH); ctx.fillRect(backUpperX+p*2+p,backUpperY+upperLegH,lowerLegW-p*2,lowerLegH); ctx.fillStyle=hoof; ctx.fillRect(backUpperX+p*2,backUpperY+upperLegH+lowerLegH,lowerLegW,hoofH); } } if (isShieldActive) { ctx.strokeStyle = 'rgba(0, 255, 255, 0.7)'; ctx.lineWidth = 2 + Math.sin(frameCount * 0.2) * 1; ctx.beginPath(); let hitboxVisualY = this.isDucking ? duckOffsetY : 0; let hitboxDrawHeight = this.height * scaleY; let hitboxDrawWidth = this.width; let radiusX = (hitboxDrawWidth / 2) + 4 + Math.sin(frameCount * 0.15) * 2; let radiusY = (hitboxDrawHeight / 2) + 4 + Math.sin(frameCount * 0.15) * 2; ctx.ellipse( hitboxDrawWidth / 2, hitboxVisualY + hitboxDrawHeight / 2, radiusX, radiusY, 0, 0, Math.PI * 2 ); ctx.setLineDash([10, 5]); ctx.lineDashOffset = frameCount * -1.5; ctx.stroke(); ctx.setLineDash([]); ctx.lineDashOffset = 0; } ctx.restore(); },
            update() { /* Restored runFrame update */ let appliedGravity = gravity; const airborne = this.y < this.baseY || this.dy > 0; if (airborne && this.isDucking) { appliedGravity *= fastFallMultiplier; } if (this.y < this.baseY || this.dy < 0) { this.dy += appliedGravity; } else { this.dy = 0; this.y = this.baseY; if (this.isJumping) { this.isJumping = false;} } this.y += this.dy; if (this.y > this.baseY) { this.y = this.baseY; this.dy = 0; if (this.isJumping) { this.isJumping = false; } } if (!this.isJumping && !this.isDucking && this.y >= this.baseY) { this.runFrame++; } else if (!this.isJumping && this.y >= this.baseY) { this.runFrame = 0; } else { this.runFrame = 0; } },
            jump() { if (isGameRunning && !this.isJumping && !this.isDucking) { this.dy = this.jumpPower; this.isJumping = true; this.isDucking = false; if(audioReady) jumpSynth.triggerAttackRelease("F#5", "16n"); } }, // Restored jump sound
            duck(shouldDuck) { if (isGameRunning) { this.isDucking = shouldDuck; } else { this.isDucking = false; } },
            reset() { /* Remains the same */ this.baseY = canvas.height - groundHeight - this.height; this.y = this.baseY; this.dy = 0; this.isJumping = false; this.isDucking = false; this.runFrame = 0; }
        };

        // --- Obstacle Class (Restored Detailed Drawing) ---
        class Obstacle {
             constructor(x, y, width, height, type, colorScheme = null) { this.x = x; this.y = y; this.width = width; this.height = height; this.type = type; this.colorScheme = colorScheme; }
             draw() { /* ... Detailed Obstacle drawing code from v26 ... */ if (this.type === 'cactus') { const p = 2; const mainColor='#2E8B57', darkColor='#228B22', lightColor='#3CB371', spineColor='#1A4D2E'; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); const conceptualHeight = this.height / p; const conceptualWidth = this.width / p; const segmentHeight = Math.max(2, Math.floor(conceptualHeight / 5)); for (let i_concept = 0; i_concept < conceptualHeight; i_concept += 1) { const i_draw = i_concept * p; const segmentIndex = Math.floor(i_concept / segmentHeight); const currentMain = (segmentIndex % 2 === 0) ? mainColor : lightColor; const currentDark = (segmentIndex % 2 === 0) ? darkColor : mainColor; const currentLight = (segmentIndex % 2 === 0) ? lightColor : '#54C581'; ctx.fillStyle = currentMain; ctx.fillRect(p * 2, i_draw, conceptualWidth*p - p * 4, p); ctx.fillStyle = currentDark; ctx.fillRect(p * 2, i_draw, p * 1, p); ctx.fillRect(conceptualWidth*p - p * 3, i_draw, p * 1, p); ctx.fillStyle = currentLight; ctx.fillRect(p * 3, i_draw, p * (conceptualWidth > 4 ? 2 : 1), p); } ctx.fillStyle = darkColor; ctx.fillRect(p * 2, this.height - p * 2, conceptualWidth*p - p * 4, p * 2); const armW_concept = Math.max(3, Math.floor(conceptualWidth * 0.4)); const armH_concept = Math.max(5, Math.floor(conceptualHeight * 0.5)); const armLX_concept = 2 - armW_concept; const armLY_concept = conceptualHeight * 0.3; ctx.fillStyle = mainColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armLX_concept*p, armLY_concept*p, p, armH_concept*p); ctx.fillRect((armLX_concept+armW_concept)*p-p, armLY_concept*p, p, armH_concept*p); ctx.fillRect(armLX_concept*p, (armLY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armLX_concept+1)*p, armLY_concept*p, (armW_concept-2)*p, p); const armRX_concept = conceptualWidth - 2; const armRY_concept = conceptualHeight * 0.15; ctx.fillStyle = mainColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, armW_concept*p, armH_concept*p); ctx.fillStyle = darkColor; ctx.fillRect(armRX_concept*p, armRY_concept*p, p, armH_concept*p); ctx.fillRect((armRX_concept+armW_concept)*p-p, armRY_concept*p, p, armH_concept*p); ctx.fillRect(armRX_concept*p, (armRY_concept+armH_concept)*p-p, armW_concept*p, p); ctx.fillStyle = lightColor; ctx.fillRect((armRX_concept+1)*p, armRY_concept*p, (armW_concept-2)*p, p); ctx.fillStyle = spineColor; for(let i = 0; i < conceptualHeight / 2; i++) { ctx.fillRect(p*2 + Math.random()*(this.width-p*4), Math.random()*this.height, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armLX_concept*p + Math.random()*armW_concept*p, armLY_concept*p + Math.random()*armH_concept*p, p/2, p/2); if(Math.random() < 0.4) ctx.fillRect(armRX_concept*p + Math.random()*armW_concept*p, armRY_concept*p + Math.random()*armH_concept*p, p/2, p/2); } ctx.restore(); } else if (this.type === 'bird') { const p_bird = 2; const cs = { bodyLight: '#FFDAB9', bodyMain: '#FFA500', bodyDark: '#CD853F', wingHigh: '#FFF8DC', wingLight: '#FFE4B5', wingMain: '#FFDEAD', beak: '#A0522D', eye: '#000000', eyeWhite: '#FFFFFF' }; ctx.save(); ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*8); ctx.fillStyle = cs.bodyLight; ctx.fillRect(p_bird*6, p_bird*8, p_bird*10, p_bird*4); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*5, p_bird*4, p_bird*12, p_bird*2); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*5); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*17, p_bird*6, p_bird*4, p_bird*1); ctx.fillStyle = cs.bodyMain; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*6); ctx.fillStyle = cs.bodyDark; ctx.fillRect(p_bird*0, p_bird*1, p_bird*6, p_bird*1); ctx.fillStyle = cs.beak; ctx.fillRect(p_bird*-3, p_bird*3, p_bird*4, p_bird*2); ctx.fillRect(p_bird*-2, p_bird*4, p_bird*2, p_bird*1); ctx.fillStyle = cs.eyeWhite; ctx.fillRect(p_bird*2, p_bird*3, p_bird*3, p_bird*3); ctx.fillStyle = cs.eye; ctx.fillRect(p_bird*3, p_bird*4, p_bird*1, p_bird*1); const flap = Math.sin(frameCount * 0.4) * p_bird * 5; ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*5); ctx.lineTo(p_bird*10, p_bird*-1 + flap); ctx.lineTo(p_bird*8, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*5); ctx.lineTo(p_bird*10, p_bird*1 + flap); ctx.lineTo(p_bird*9, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*5); ctx.lineTo(p_bird*10, p_bird*2 + flap); ctx.lineTo(p_bird*9.5, p_bird*6); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingMain; ctx.beginPath(); ctx.moveTo(p_bird*15, p_bird*10); ctx.lineTo(p_bird*10, p_bird*14 - flap); ctx.lineTo(p_bird*8, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingLight; ctx.beginPath(); ctx.moveTo(p_bird*14, p_bird*10); ctx.lineTo(p_bird*10, p_bird*13 - flap); ctx.lineTo(p_bird*9, p_bird*9); ctx.closePath(); ctx.fill(); ctx.fillStyle = cs.wingHigh; ctx.beginPath(); ctx.moveTo(p_bird*13, p_bird*10); ctx.lineTo(p_bird*10, p_bird*12 - flap); ctx.lineTo(p_bird*9.5, p_bird*9); ctx.closePath(); ctx.fill(); ctx.restore(); } }
             update() { this.x -= gameSpeed; }
        }

         // --- Cloud Class ---
         class Cloud { /* ... Cloud class code from v20 ... */
            constructor(x, y, width, height, speed) { this.x = x; this.y = y; this.width = width; this.height = height; this.speed = speed; }
            draw() { const p = 1; const c1='#FFFFFF', c2='#F0F8FF', c3='#E0E8EF'; ctx.save(); ctx.globalAlpha = 0.8; ctx.translate(Math.round(this.x), Math.round(this.y)); ctx.fillStyle=c1; ctx.fillRect(p*5,p*5,this.width-p*10,this.height-p*10); ctx.fillRect(p*2,p*8,this.width-p*4,this.height-p*16); ctx.fillRect(p*8,p*2,this.width-p*16,this.height-p*4); ctx.fillStyle=c2; ctx.fillRect(p*6,p*6,this.width-p*12,p*3); ctx.fillStyle=c3; ctx.fillRect(p*6,this.height-p*8,this.width-p*12,p*3); ctx.fillStyle=c1; ctx.fillRect(p*3,p*6,p*2,p*4); ctx.fillRect(this.width-p*5,p*6,p*2,p*4); ctx.fillRect(p*3,this.height-p*10,p*2,p*4); ctx.fillRect(this.width-p*5,this.height-p*10,p*2,p*4); ctx.fillRect(p*6,p*3,p*4,p*2); ctx.fillRect(this.width-p*10,p*3,p*4,p*2); ctx.fillRect(p*6,this.height-p*5,p*4,p*2); ctx.fillRect(this.width-p*10,this.height-p*5,p*4,p*2); ctx.restore(); }
            update() { this.x -= this.speed; }
         }

         // --- Coin Class (Restored) ---
         class Coin { /* ... Coin class code from v30d ... */ constructor(x,y,r){this.x=x;this.y=y;this.radius=r;this.collected=false;} draw(){if(!this.collected){const bob=Math.sin(frameCount*0.1+this.x*0.05)*3; const cy=this.y+bob; ctx.fillStyle='gold';ctx.beginPath();ctx.arc(this.x+this.radius,cy+this.radius,this.radius,0,Math.PI*2);ctx.fill(); ctx.fillStyle='darkgoldenrod';ctx.beginPath();ctx.arc(this.x+this.radius,cy+this.radius,this.radius*0.7,0,Math.PI*2);ctx.fill();}} update(){this.x-=gameSpeed;} }

        // --- Utility Functions ---
        function showCustomAlert(message) { alert(message); }
        function getRandomInt(min, max) { min = Math.ceil(min); max = Math.floor(max); return Math.floor(Math.random() * (max - min + 1)) + min; }

        // --- Game Functions ---
        function setBackground(isNightTime) { /* Remains the same */ const bgColor=isNightTime?nightBgColor:dayBgColor; const bodyBg=isNightTime?nightBodyBgColor:dayBodyBgColor; gameContainer.style.backgroundColor=bgColor; document.body.style.backgroundColor=bodyBg; messageBox.style.backgroundColor = isNight ? 'rgba(44, 62, 80, 0.95)' : 'rgba(255, 255, 255, 0.95)'; messageBox.style.color = isNight ? nightTextColor : dayTextColor; messageBox.style.borderColor = isNight ? nightUiBorder : '#4a4a4a'; }
        function drawStars() { /* Remains the same */ if(!isNight)return; ctx.fillStyle='white'; for(let i=0;i<50;i++){let x=(Math.random()*canvas.width*1.5-frameCount*0.1)%canvas.width; if(x<0)x+=canvas.width; let y=Math.random()*canvas.height*0.7; let size=Math.random()>0.8?2:1; ctx.globalAlpha=0.5+Math.sin(frameCount*0.05+i)*0.5; ctx.fillRect(x,y,size,size);} ctx.globalAlpha=1.0; }
        function resizeCanvas() { /* Remains the same */ const container=document.getElementById('game-container'); if (!container || !canvas) return; canvas.width=container.clientWidth; canvas.height=container.clientHeight; llama.reset(); drawGround(); setBackground(isNight); /* No message box show on resize */ }
        function drawGround() { /* Remains the same */ if (!ctx) return; ctx.fillStyle=isNight?nightGroundColor:dayGroundColor; ctx.fillRect(0,canvas.height-groundHeight,canvas.width,groundHeight); ctx.fillStyle=isNight?'rgba(255,255,255,0.05)':'rgba(0,0,0,0.1)'; for(let i=0;i<canvas.width;i+=20){ctx.fillRect(i+(Math.floor(frameCount*gameSpeed)%20),canvas.height-groundHeight+5,2,groundHeight-10);} }
        function spawnCloud() { /* Remains the same */ const spawnChance=0.003; if(Math.random()<spawnChance){const p=1; const cw=getRandomInt(80,140)*p; const ch=getRandomInt(40,70)*p; const cy=Math.random()*(canvas.height*0.3); const cs=gameSpeed*(0.05+Math.random()*0.1); clouds.push(new Cloud(canvas.width,cy,cw,ch,cs));} }
        function updateClouds() { /* Remains the same */ for(let i=clouds.length-1;i>=0;i--){clouds[i].update(); clouds[i].draw(); if(clouds[i].x+clouds[i].width<0){clouds.splice(i,1);}} }

        // --- Obstacle Spawning (Restored Random Sizes) ---
        function spawnObstacle() {
             if (!isGameRunning) return;
            const speedFactor = Math.max(0.5, 1 - (gameSpeed / 25));
            const minGap = (190 + Math.random() * 230) * speedFactor + 140;
            const lastObstacle = obstacles[obstacles.length - 1];

             if (!lastObstacle || (canvas.width - lastObstacle.x) > minGap) {
                const type = Math.random() < 0.6 ? 'cactus' : 'bird';
                let obstacle;
                if (type === 'cactus') {
                    const cactusHeight = 46 + Math.random() * 30;
                    const cactusWidth = 30 + Math.random() * 10;
                    obstacle = new Obstacle(canvas.width, canvas.height - groundHeight - cactusHeight, cactusWidth, cactusHeight, 'cactus');
                } else { // Bird
                    const p_bird = 2;
                    const birdDrawWidth = 24 * p_bird;
                    const birdDrawHeight = 16 * p_bird;
                    const birdHitboxWidth = birdDrawWidth * 0.85;
                    const birdHitboxHeight = birdDrawHeight * 0.85;
                    const clearance = 5;
                    const birdY = canvas.height - groundHeight - llama.duckHeight - birdHitboxHeight - clearance;
                    obstacle = new Obstacle(canvas.width, birdY, birdHitboxWidth, birdHitboxHeight, 'bird');
                }
                obstacles.push(obstacle);
            }
        }

         // --- Spawn Coin (Restored) ---
         function spawnCoin() {
             if (!isGameRunning) return;
             const chance = 0.02;
             const minGap = 80;
             const lastCoin = coinObjects[coinObjects.length - 1];
             if (Math.random() < chance) {
                 if (!lastCoin || (canvas.width - lastCoin.x) > minGap) {
                     const r = 10;
                     const rf = Math.random();
                     let y;
                     if (rf < 0.5) { y = canvas.height-groundHeight-r*2-5; }
                     else { y = canvas.height-groundHeight-r*2-(llama.height*0.6)-Math.random()*(llama.height*0.7); }
                     coinObjects.push(new Coin(canvas.width, Math.max(y, r*2), r));
                 }
             }
         }
         // --- Update Obstacles (Restored with Mission Tracking) ---
         function updateObstacles() {
             for (let i=obstacles.length-1; i>=0; i--) {
                 const obs = obstacles[i];
                 const wasBehindLlama = obs.x + obs.width < llama.x;
                 obs.update();
                 obs.draw();
                 const isNowBehindLlama = obs.x + obs.width < llama.x;
                 if (!wasBehindLlama && isNowBehindLlama && !isGameOver && activeMission) {
                     if (obs.type === 'cactus' && llama.isJumping && activeMission.type === 'jump_cactus') { cactiJumpedThisRun++; updateMissionProgress('jump_cactus', cactiJumpedThisRun); }
                     else if (obs.type === 'bird' && llama.isDucking && activeMission.type === 'duck_bird') { birdsDuckedThisRun++; updateMissionProgress('duck_bird', birdsDuckedThisRun); }
                 }
                 if (checkCollision(llama, obs)) { handleCollision(obs); }
                 if (obs.x + obs.width < 0) { obstacles.splice(i, 1); }
             }
         }
         // --- Update Coins (Restored with Mission Tracking and Sound) ---
         function updateCoins() {
             const mr = isMagnetActive ? 100 : 0;
             for (let i=coinObjects.length-1; i>=0; i--) {
                 const c = coinObjects[i]; if (!c) continue; c.update();
                 if (isMagnetActive && !c.collected) { const lcx=llama.x+llama.width/2; const lhy=llama.isDucking?llama.y+(llama.height-llama.duckHeight):llama.y; const lhh=llama.isDucking?llama.duckHeight:llama.height; const lcy=lhy+lhh/2; const ccx=c.x+c.radius; const ccy=c.y+c.radius; const dx=lcx-ccx; const dy=lcy-ccy; const d=Math.sqrt(dx*dx+dy*dy); if(d<mr){const ms=6; c.x+=(dx/d)*ms; c.y+=(dy/d)*ms;} }
                 c.draw(); const cr = isMagnetActive?c.radius*1.5:c.radius;
                 if (!c.collected && checkCollision(llama, c, true, cr)) {
                     c.collected=true; const ai=coinObjects.findIndex(x=>x===c); if(ai!==-1)coinObjects.splice(ai,1);
                     coins++;
                     coinsCollectedThisRun++;
                     updateMissionProgress('coins', coinsCollectedThisRun);
                     if(audioReady) coinSynth.triggerAttackRelease("E6", "16n");
                     updateDisplays();
                 } else if (c.x + c.radius*2 < 0) {
                     coinObjects.splice(i, 1);
                 }
             }
         }
         // --- Check Collision (Restored) ---
         function checkCollision(r1, r2, isC = false, cRad = 0) {
            let r1Y = r1.isDucking ? r1.y+(r1.height-r1.duckHeight) : r1.y;
            let r1H = r1.isDucking ? r1.duckHeight : r1.height;
            let r1X = r1.x; let r1W = r1.width;
            if (isC) { let cX = r2.x+r2.radius; const bob = Math.sin(frameCount*0.1+r2.x*0.05)*3; let cY = r2.y+bob+r2.radius; let rad = cRad > 0 ? cRad : r2.radius; let clX = Math.max(r1X, Math.min(cX, r1X+r1W)); let clY = Math.max(r1Y, Math.min(cY, r1Y+r1H)); let dX = cX-clX; let dY = cY-clY; let dSq = (dX*dX)+(dY*dY); return dSq < (rad*rad); }
            else { let oX = r2.x; let oY = r2.y; let oW = r2.width; let oH = r2.height; return (r1X < oX+oW && r1X+r1W > oX && r1Y < oY+oH && r1Y+r1H > oY); }
         }
         // --- Handle Collision (Restored with Sound) ---
         function handleCollision(obs) {
            console.log("Collision detected!");
            if(isShieldActive){ isShieldActive=false; updatePowerupIndicators(); const i=obstacles.indexOf(obs); if(i>-1)obstacles.splice(i,1); if(audioReady) hitSynth.triggerAttackRelease("C4", "8n"); return; }
            if(extraLives>0){ extraLives--; updatePowerupIndicators(); obstacles=obstacles.filter(o=>o.x>llama.x+llama.width+75||o.x<llama.x-75); if(audioReady) hitSynth.triggerAttackRelease("A3", "8n"); return; }
            if(audioReady) hitSynth.triggerAttackRelease("G2", "4n"); gameOver();
        }
         // --- Update Score (Restored Mission Call) ---
         function updateScore() {
             if (!isGameRunning) return;
             score = Math.floor(frameCount / 6);
             updateMissionProgress('score', score);
             // updateDisplays(); // Display updated in drawUI now
         }
         // --- Update Displays (Only needed for Store/Indicators now) ---
         function updateDisplays() {
             storeCoinBalance.textContent = coins;
             shieldOwnedDisplay.textContent = shieldsOwned; lifeOwnedDisplay.textContent = livesOwned; magnetOwnedDisplay.textContent = magnetsOwned;
             updatePowerupIndicators();
             // updateMissionDisplay(); // Handled by drawUI
             buyShieldButton.disabled = coins < shieldCost; buyLifeButton.disabled = coins < lifeCost; buyMagnetButton.disabled = coins < magnetCost;
         }
         // --- Update Powerup Indicators (Restored 'owned' logic) ---
         function updatePowerupIndicators() {
            shieldIndicator.classList.toggle('active', isShieldActive);
            magnetIndicator.classList.toggle('active', isMagnetActive);
            lifeIndicator.classList.toggle('active', extraLives > 0);
            lifeIndicator.textContent = extraLives > 0 ? `‚ù§Ô∏è ${extraLives}` : '‚ù§Ô∏è';
            shieldIndicator.classList.toggle('owned', shieldsOwned > 0 && !isShieldActive);
            magnetIndicator.classList.toggle('owned', magnetsOwned > 0 && !isMagnetActive);
            lifeIndicator.classList.toggle('owned', livesOwned > 0 && !(extraLives > 0));
        }
         function showGameOverMessage() { /* Now handled by drawGameOverOverlay */ }
         function showStartMessage() { /* Now handled by drawGameOverOverlay */ }

         function gameOver() { /* Restored Game Over Sound Call */
            if(isGameOver) return; // Prevent multiple calls
            console.log("Game Over triggered");
            isGameOver=true; isGameRunning=false;
            cancelAnimationFrame(animationFrameId);
            if(score > highScore) { highScore = score; localStorage.setItem('llamaHighScore', highScore); }
            localStorage.setItem('llamaCoins',coins); localStorage.setItem('llamaShields',shieldsOwned); localStorage.setItem('llamaLives',livesOwned); localStorage.setItem('llamaMagnets',magnetsOwned);
            // Removed redundant speed reset: gameSpeed = initialGameSpeed;
            updatePowerupIndicators();
            gameLoop(); // Call one last time to draw overlay
            isGameRunning = false;
        }


         // --- Mission Functions (Restored) ---
         function selectNewMission() {
             const availableMissions = missionPool;
             if (availableMissions.length > 0) {
                 activeMission = availableMissions[Math.floor(Math.random() * availableMissions.length)];
                 missionProgress = 0;
                 coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0;
                 console.log("New Mission Selected:", activeMission.description);
                 missionNotificationText = `New Mission: ${activeMission.description}`;
                 missionNotificationTimer = missionNotificationDuration;
             } else {
                 activeMission = null;
                 console.log("No more missions available.");
                 missionNotificationText = "";
                 missionNotificationTimer = 0;
             }
             // updateMissionDisplay(); // Handled by drawUI
         }

         function updateMissionDisplay() { /* Handled by drawUI */ }

         function showMissionCompletePopup() { // Restored sound
             missionCompletePopup.textContent = `Mission Complete! +${activeMission.reward} Coins ü™ô`;
             missionCompletePopup.style.display = 'block';
             missionCompletePopup.style.opacity = 1;
             if(audioReady) missionSynth.triggerAttackRelease("C6", "8n");
             setTimeout(() => {
                 missionCompletePopup.style.opacity = 0;
                 setTimeout(() => { missionCompletePopup.style.display = 'none'; }, 500);
             }, 2000);
         }

         function updateMissionProgress(type, value) { // Restored fully
             if (!activeMission || activeMission.type !== type || !isGameRunning) { return; }
             if(type === 'score') { missionProgress = value; } else { missionProgress = value; }
             if (missionProgress >= activeMission.target) {
                 console.log(`Mission Complete: ${activeMission.description}`);
                 coins += activeMission.reward; localStorage.setItem('llamaCoins', coins);
                 showMissionCompletePopup(); selectNewMission(); updateDisplays();
             }
             // No need to call updateMissionDisplay here
         }
         // --- End Mission Functions ---

         // --- Reset Game (Restored Mission Reset & Speed Reset Log) ---
         function resetGame() {
             console.log("Resetting game...");
             score=0; obstacles=[]; coinObjects=[]; clouds=[]; frameCount=0; lastScoreThreshold=0; isGameOver=false;
             isShieldActive=false; isMagnetActive=false; magnetTimer=0; extraLives=0;
             console.log("Speed BEFORE reset:", gameSpeed); // DEBUG LOG
             gameSpeed=initialGameSpeed; // --- Reset speed here ---
             console.log("Speed AFTER reset:", gameSpeed); // DEBUG LOG
             // Auto-activate Power-ups
             if(shieldsOwned>0){isShieldActive=true;shieldsOwned--;localStorage.setItem('llamaShields',shieldsOwned);}
             if(livesOwned>0){extraLives=1;livesOwned--;localStorage.setItem('llamaLives',livesOwned);}
             if(magnetsOwned>0){isMagnetActive=true;magnetTimer=magnetDuration;magnetsOwned--;localStorage.setItem('llamaMagnets',magnetsOwned);}
             llama.reset();
             coinsCollectedThisRun = 0; cactiJumpedThisRun = 0; birdsDuckedThisRun = 0;
             selectNewMission(); // Select mission for the new run
             updateDisplays(); // Update store button states etc.
             console.log("Game reset complete.");
         }

          // --- Draw UI Elements on Canvas ---
         function drawUI() {
             const padding = 15;
             const fontSizeSmall = 10;
             const uiFont = `${fontSizeSmall}px "Press Start 2P"`;

             ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
             ctx.font = uiFont;

             // Score & High Score (Top Right)
             ctx.textAlign = 'right';
             ctx.fillText(`HI ${highScore}`, canvas.width - padding, padding + fontSizeSmall);
             ctx.fillText(`${score}`, canvas.width - padding, padding * 2 + fontSizeSmall * 2);

             // Coins (Top Left)
             ctx.textAlign = 'left';
             ctx.fillText(`ü™ô ${coins}`, padding, padding + fontSizeSmall);

             // Mission Notification (Top Center) - Fades In/Out
             if (missionNotificationTimer > 0) {
                 console.log("Drawing Mission Notification"); // DEBUG LOG
                 // --- Simplified Drawing (No Alpha) ---
                 ctx.textAlign = 'center';
                 ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
                 ctx.font = `${fontSizeSmall * 0.9}px "Press Start 2P"`;
                 ctx.fillText(missionNotificationText, canvas.width / 2, padding + fontSizeSmall);
                 missionNotificationTimer--;
             }
         }

         // --- Draw Game Over Overlay ---
         function drawGameOverOverlay() {
             const boxWidth = Math.min(canvas.width * 0.7, 400);
             const boxHeight = Math.min(canvas.height * 0.6, 280);
             const boxX = (canvas.width - boxWidth) / 2;
             const boxY = (canvas.height - boxHeight) / 2;

             // Semi-transparent background
             ctx.fillStyle = "rgba(0, 0, 0, 0.75)";
             ctx.fillRect(0, 0, canvas.width, canvas.height);

             // Box
             ctx.fillStyle = isNight ? nightUiBg : "rgba(255, 255, 255, 0.95)";
             ctx.strokeStyle = isNight ? nightUiBorder : "#4a4a4a";
             ctx.lineWidth = 3;
             ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
             ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);

             // Text
             const padding = 20;
             const baseFontSize = Math.max(10, Math.min(16, boxWidth / 20));
             const lineSpacing = baseFontSize * 2.2;
             let currentY = boxY + padding + baseFontSize * 1.5;

             ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
             ctx.font = `bold ${baseFontSize * 1.3}px "Press Start 2P"`;
             ctx.textAlign = "center";
             ctx.fillText("Game Over!", canvas.width / 2, currentY);

             currentY += lineSpacing * 1.2;
             ctx.font = `${baseFontSize}px "Press Start 2P"`;
             ctx.fillText(`Score: ${score}`, canvas.width / 2, currentY);

             currentY += lineSpacing * 0.8;
             ctx.fillText(`Coins: ${coins} ü™ô`, canvas.width / 2, currentY);

             currentY += lineSpacing * 1.5;
             ctx.font = `${baseFontSize * 0.9}px "Press Start 2P"`;
             ctx.fillText("Tap to Restart", canvas.width / 2, currentY);

             // Store Button Area (Draw it)
             currentY += lineSpacing * 0.8;
             const storeButtonHeight = baseFontSize * 2;
             const storeButtonWidth = baseFontSize * 7;
             const storeButtonX = (canvas.width - storeButtonWidth) / 2;
             const storeButtonY = currentY;
             storeButtonBounds = { x: storeButtonX, y: storeButtonY, width: storeButtonWidth, height: storeButtonHeight };

             ctx.fillStyle = isNight ? 'rgba(200, 200, 200, 0.2)' : 'rgba(100, 100, 100, 0.1)';
             ctx.fillRect(storeButtonBounds.x, storeButtonBounds.y, storeButtonBounds.width, storeButtonBounds.height);
             ctx.fillStyle = isNight ? nightTextColor : dayTextColor;
             ctx.fillText("[ Store ]", canvas.width / 2, storeButtonY + storeButtonHeight * 0.65);
         }


         // --- Main Loop ---
         function gameLoop() {
             // Added Log for Speed Debugging
             if (framesAfterReset > 0) {
                 console.log(`Frame ${11 - framesAfterReset} after reset - Speed: ${gameSpeed.toFixed(2)}, Score: ${score}, Threshold: ${lastScoreThreshold}`);
                 framesAfterReset--;
             }

             if (isGameOver) {
                 ctx.fillStyle = isNight ? nightBgColor : dayBgColor;
                 ctx.fillRect(0, 0, canvas.width, canvas.height);
                 drawGround();
                 drawGameOverOverlay();
                 animationFrameId = requestAnimationFrame(gameLoop);
                 return;
             }
             isGameRunning = true;
             const scoreCycle = Math.floor(score / 700); const shouldBeNight = scoreCycle % 2 !== 0; if (shouldBeNight !== isNight) { isNight = shouldBeNight; setBackground(isNight); }
             ctx.fillStyle = isNight ? nightBgColor : dayBgColor; ctx.fillRect(0, 0, canvas.width, canvas.height);
             spawnCloud(); updateClouds(); drawStars(); drawGround();
             llama.update(); llama.draw();
             spawnObstacle(); spawnCoin();
             updateObstacles(); updateCoins();
             updateScore();
             const currentScoreThreshold = Math.floor(score / 100); if (currentScoreThreshold > lastScoreThreshold) { gameSpeed += speedIncrement; lastScoreThreshold = currentScoreThreshold; console.log(`Score reached ${lastScoreThreshold * 100}, Speed increased to: ${gameSpeed.toFixed(2)}`); }
             if (isMagnetActive) { magnetTimer--; if (magnetTimer <= 0) { isMagnetActive = false; updatePowerupIndicators(); } }
             // console.log("Before drawUI"); // DEBUG LOG
             drawUI();
             // console.log("After drawUI"); // DEBUG LOG
             frameCount++;
             animationFrameId = requestAnimationFrame(gameLoop);
         }


        // --- Event Listeners ---
        window.addEventListener('resize', resizeCanvas);
        document.addEventListener('keydown', (e) => { if(isGameOver){if(e.code==='Space'||e.code==='ArrowUp'){if (!storeInterface.style.display || storeInterface.style.display === 'none'){e.preventDefault();handleGameStartInteraction();}return;}} if(isGameRunning){if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();llama.jump();}else if(e.code==='ArrowDown'){e.preventDefault();if (!llama.isDucking){llama.duck(true);}}}});
        document.addEventListener('keyup', (e) => { if(isGameRunning&&e.code==='ArrowDown'){e.preventDefault();llama.duck(false);}});

        // --- Button Click & Start (Restored Audio) ---
        function playUIClick(){ if(audioReady) uiClickSynth.triggerAttackRelease("A5", "16n"); }
        // jumpButton, duckButton listeners removed

        // Function to handle starting audio context and the game (Simplified for Debugging)
        function handleGameStartInteraction() {
            if (isGameRunning && !isGameOver) return;
            console.log("handleGameStartInteraction called - bypassing audio check for now");
            initiateGameStart(); // Start directly for debugging speed reset
            // Original audio handling:
            // if (!audioReady) { try { Tone.start().then(() => { setupAudio(); initiateGameStart(); }).catch(e => { console.error("Tone.start failed:", e); initiateGameStart(); }); } catch (e) { console.error("Error calling Tone.start():", e); initiateGameStart(); } } else { initiateGameStart(); }
        }
        // startButton listener removed

        function startDuck(e){ /* Removed - handled by touch/key */ }
        function endDuck(e){ /* Removed - handled by touch/key */ }

        // --- Touch Controls (Tap Jump / Swipe Duck / Game Over Interaction - FIXED) ---
        gameContainer.addEventListener('touchstart', (e) => { /* ... touchstart code from v35b ... */ if (storeInterface.style.display === 'flex') return; const touch = e.changedTouches[0]; const rect = canvas.getBoundingClientRect(); if (isGameOver) { e.preventDefault(); const touchX = touch.clientX - rect.left; const touchY = touch.clientY - rect.top; if (storeButtonBounds && touchX >= storeButtonBounds.x && touchX <= storeButtonBounds.x + storeButtonBounds.width && touchY >= storeButtonBounds.y && touchY <= storeButtonBounds.y + storeButtonBounds.height) { console.log("Store button tapped on overlay"); playUIClick(); storeInterface.style.display = 'flex'; updateDisplays(); } else { console.log("Tap starting game"); handleGameStartInteraction(); } return; } if (isGameRunning) { touchStartX = touch.screenX; touchStartY = touch.screenY; touchStartTime = Date.now(); isSwiping = false; } }, {passive: false});
        gameContainer.addEventListener('touchmove', (e) => { /* ... touchmove code from v35b ... */ if (!isGameRunning || touchStartY === 0) return; const touch = e.changedTouches[0]; const currentX = touch.screenX; const currentY = touch.screenY; let distY = currentY - touchStartY; let distX = currentX - touchStartX; if (!isSwiping && (Math.abs(distY) > 10 || Math.abs(distX) > 10)) { e.preventDefault(); isSwiping = true; } if (distY > minSwipeYDistance && Math.abs(distX) < maxSwipeXDistance) { if (!llama.isDucking) { console.log("Swipe Down Move -> Duck Start"); llama.duck(true); } } }, {passive: false});
        gameContainer.addEventListener('touchend', (e) => { /* ... touchend code from v35b ... */ if (!isGameRunning || touchStartY === 0) { touchStartY = 0; isSwiping = false; return; } const touchEndTime = Date.now(); const touchDuration = touchEndTime - touchStartTime; touchEndY = e.changedTouches[0].screenY; touchEndX = e.changedTouches[0].screenX; let distY = touchEndY - touchStartY; let distX = touchEndX - touchStartX; if (!isSwiping && touchDuration < maxTapTime && Math.abs(distX) < maxSwipeXDistance && Math.abs(distY) < minSwipeYDistance ) { console.log("Tap detected for Jump"); llama.jump(); } else if (llama.isDucking && isSwiping) { console.log("Swipe End detected, stopping duck."); llama.duck(false); } isSwiping = false; touchStartY = 0; touchEndY = 0; touchStartTime = 0; });

        // Store button listeners
        closeStoreButton.addEventListener('click', ()=>{ playUIClick(); storeInterface.style.display='none';});
        buyShieldButton.addEventListener('click', ()=>{ playUIClick(); const c=shieldCost; if(coins>=c){coins-=c;shieldsOwned++;localStorage.setItem('llamaCoins',coins);localStorage.setItem('llamaShields',shieldsOwned);updateDisplays();}else{showCustomAlert("Not enough coins!");}});
        buyLifeButton.addEventListener('click', ()=>{ playUIClick(); const c=lifeCost; if(coins>=c){coins-=c;livesOwned++;localStorage.setItem('llamaCoins',coins);localStorage.setItem('llamaLives',livesOwned);updateDisplays();}else{showCustomAlert("Not enough coins!");}});
        buyMagnetButton.addEventListener('click', ()=>{ playUIClick(); const c=magnetCost; if(coins>=c){coins-=c;magnetsOwned++;localStorage.setItem('llamaCoins',coins);localStorage.setItem('llamaMagnets',magnetsOwned);updateDisplays();}else{showCustomAlert("Not enough coins!");}});


        // --- PWA Install Prompt Logic ---
        window.addEventListener('beforeinstallprompt', (e) => { e.preventDefault(); deferredPrompt = e; /* installButton.style.display = 'block'; */ console.log('beforeinstallprompt fired - install available'); }); // Install button removed
        // installButton listener removed
        window.addEventListener('appinstalled', () => { /* installButton.style.display = 'none'; */ deferredPrompt = null; console.log('PWA was installed'); });
        // --- End PWA Install ---


        // --- Initialization ---
        function initiateGameStart() {
             if (isGameRunning) return;
             console.log("Initiating game start...");
             resetGame(); // Reset state first
             isGameRunning = true; // Set running flag
             console.log("isGameRunning set to true");
             if (animationFrameId) cancelAnimationFrame(animationFrameId); // Clear previous loop
             animationFrameId = requestAnimationFrame(gameLoop); // Start the loop
             console.log("Game loop started.");
         }
        window.onload = function () {
             console.log("Window loaded. Initializing.");
             resizeCanvas();
             // selectNewMission(); // Called in resetGame now
             updateDisplays(); // Initial UI draw
             // showStartMessage(); // Now handled by overlay
             // startButton.disabled = false; // Button removed
             gameLoop(); // Start loop immediately to show start screen overlay
             console.log("Initialization complete.");
         }

    </script>
</body>
</html>
```

**4. `manifest.json`** (No changes from v35c)

```json
{
  "name": "Llama Time!",
  "short_name": "LlamaTime",
  "description": "Endless runner game where a llama avoids obstacles and collects coins.",
  "id": "/Llama-Time/",
  "start_url": ".",
  "scope": "/",
  "display": "standalone",
  "orientation": "any",
  "background_color": "#87CEEB",
  "theme_color": "#4a4a4a",
  "icons": [
    {
      "src": "icons/llama-icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "icons/llama-icon-512.png",
      "sizes": "512x512",
      "type": "image/png",
       "purpose": "any maskable"
    }
  ],
  "screenshots" : [
    {
      "src": "screenshots/llama-screen-mobile-1.png",
      "type": "image/png",
      "sizes": "540x720",
      "form_factor": "narrow"
    },
    {
      "src": "screenshots/llama-screen-desktop-1.png",
      "type": "image/png",
      "sizes": "1024x768",
      "form_factor": "wide"
    }
  ]
}
